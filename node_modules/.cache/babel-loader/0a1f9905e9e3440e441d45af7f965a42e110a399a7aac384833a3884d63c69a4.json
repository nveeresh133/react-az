{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { isArray, isFunction, objDefine, utcNow } from \"@nevware21/ts-utils\";\nimport { _DYN_COMPLETE, _DYN_GET_CTX, _DYN_IS_ASYNC, _DYN_IS_CHILD_EVT, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SET_CTX, _DYN_TIME } from \"../__DynamicConstants\";\nimport { STR_GET_PERF_MGR, STR_PERF_EVENT } from \"./InternalConstants\";\nvar strExecutionContextKey = \"ctx\";\nvar strParentContextKey = \"ParentContextKey\";\nvar strChildrenContextKey = \"ChildrenContextKey\";\nvar _defaultPerfManager = null;\nvar PerfEvent = /** @class */function () {\n  function PerfEvent(name, payloadDetails, isAsync) {\n    var _self = this;\n    _self.start = utcNow();\n    _self[_DYN_NAME /* @min:%2ename */] = name;\n    _self[_DYN_IS_ASYNC /* @min:%2eisAsync */] = isAsync;\n    _self[_DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */] = function () {\n      return false;\n    };\n    if (isFunction(payloadDetails)) {\n      // Create an accessor to minimize the potential performance impact of executing the payloadDetails callback\n      var theDetails_1;\n      objDefine(_self, \"payload\", {\n        g: function () {\n          // Delay the execution of the payloadDetails until needed\n          if (!theDetails_1 && isFunction(payloadDetails)) {\n            theDetails_1 = payloadDetails();\n            // clear it out now so the referenced objects can be garbage collected\n            payloadDetails = null;\n          }\n          return theDetails_1;\n        }\n      });\n    }\n    _self[_DYN_GET_CTX /* @min:%2egetCtx */] = function (key) {\n      if (key) {\n        // The parent and child links are located directly on the object (for better viewing in the DebugPlugin)\n        if (key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey]) {\n          return _self[key];\n        }\n        return (_self[strExecutionContextKey] || {})[key];\n      }\n      return null;\n    };\n    _self[_DYN_SET_CTX /* @min:%2esetCtx */] = function (key, value) {\n      if (key) {\n        // Put the parent and child links directly on the object (for better viewing in the DebugPlugin)\n        if (key === PerfEvent[strParentContextKey]) {\n          // Simple assumption, if we are setting a parent then we must be a child\n          if (!_self[key]) {\n            _self[_DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */] = function () {\n              return true;\n            };\n          }\n          _self[key] = value;\n        } else if (key === PerfEvent[strChildrenContextKey]) {\n          _self[key] = value;\n        } else {\n          var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};\n          ctx[key] = value;\n        }\n      }\n    };\n    _self[_DYN_COMPLETE /* @min:%2ecomplete */] = function () {\n      var childTime = 0;\n      var childEvts = _self[_DYN_GET_CTX /* @min:%2egetCtx */](PerfEvent[strChildrenContextKey]);\n      if (isArray(childEvts)) {\n        for (var lp = 0; lp < childEvts[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n          var childEvt = childEvts[lp];\n          if (childEvt) {\n            childTime += childEvt[_DYN_TIME /* @min:%2etime */];\n          }\n        }\n      }\n      _self[_DYN_TIME /* @min:%2etime */] = utcNow() - _self.start;\n      _self.exTime = _self[_DYN_TIME /* @min:%2etime */] - childTime;\n      _self[_DYN_COMPLETE /* @min:%2ecomplete */] = function () {};\n    };\n  }\n  PerfEvent.ParentContextKey = \"parent\";\n  PerfEvent.ChildrenContextKey = \"childEvts\";\n  return PerfEvent;\n}();\nexport { PerfEvent };\nvar PerfManager = /** @class */function () {\n  function PerfManager(manager) {\n    /**\r\n     * General bucket used for execution context set and retrieved via setCtx() and getCtx.\r\n     * Defined as private so it can be visualized via the DebugPlugin\r\n     */\n    this.ctx = {};\n    dynamicProto(PerfManager, this, function (_self) {\n      _self.create = function (src, payloadDetails, isAsync) {\n        // TODO (@MSNev): at some point we will want to add additional configuration to \"select\" which events to instrument\n        // for now this is just a simple do everything.\n        return new PerfEvent(src, payloadDetails, isAsync);\n      };\n      _self.fire = function (perfEvent) {\n        if (perfEvent) {\n          perfEvent[_DYN_COMPLETE /* @min:%2ecomplete */]();\n          if (manager && isFunction(manager[STR_PERF_EVENT /* @min:%2eperfEvent */])) {\n            manager[STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);\n          }\n        }\n      };\n      _self[_DYN_SET_CTX /* @min:%2esetCtx */] = function (key, value) {\n        if (key) {\n          var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};\n          ctx[key] = value;\n        }\n      };\n      _self[_DYN_GET_CTX /* @min:%2egetCtx */] = function (key) {\n        return (_self[strExecutionContextKey] || {})[key];\n      };\n    });\n  }\n  // Removed Stub for PerfManager.prototype.create.\n  // Removed Stub for PerfManager.prototype.fire.\n  // Removed Stub for PerfManager.prototype.setCtx.\n  // Removed Stub for PerfManager.prototype.getCtx.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  PerfManager.__ieDyn = 1;\n  return PerfManager;\n}();\nexport { PerfManager };\nvar doPerfActiveKey = \"CoreUtils.doPerf\";\n/**\r\n * Helper function to wrap a function with a perf event\r\n * @param mgrSource - The Performance Manager or a Performance provider source (may be null)\r\n * @param getSource - The callback to create the source name for the event (if perf monitoring is enabled)\r\n * @param func - The function to call and measure\r\n * @param details - A function to return the payload details\r\n * @param isAsync - Is the event / function being call asynchronously or synchronously\r\n */\nexport function doPerf(mgrSource, getSource, func, details, isAsync) {\n  if (mgrSource) {\n    var perfMgr = mgrSource;\n    if (perfMgr[STR_GET_PERF_MGR]) {\n      // Looks like a perf manager provider object\n      perfMgr = perfMgr[STR_GET_PERF_MGR]();\n    }\n    if (perfMgr) {\n      var perfEvt = void 0;\n      var currentActive = perfMgr[_DYN_GET_CTX /* @min:%2egetCtx */](doPerfActiveKey);\n      try {\n        perfEvt = perfMgr.create(getSource(), details, isAsync);\n        if (perfEvt) {\n          if (currentActive && perfEvt[_DYN_SET_CTX /* @min:%2esetCtx */]) {\n            perfEvt[_DYN_SET_CTX /* @min:%2esetCtx */](PerfEvent[strParentContextKey], currentActive);\n            if (currentActive[_DYN_GET_CTX /* @min:%2egetCtx */] && currentActive[_DYN_SET_CTX /* @min:%2esetCtx */]) {\n              var children = currentActive[_DYN_GET_CTX /* @min:%2egetCtx */](PerfEvent[strChildrenContextKey]);\n              if (!children) {\n                children = [];\n                currentActive[_DYN_SET_CTX /* @min:%2esetCtx */](PerfEvent[strChildrenContextKey], children);\n              }\n              children[_DYN_PUSH /* @min:%2epush */](perfEvt);\n            }\n          }\n          // Set this event as the active event now\n          perfMgr[_DYN_SET_CTX /* @min:%2esetCtx */](doPerfActiveKey, perfEvt);\n          return func(perfEvt);\n        }\n      } catch (ex) {\n        if (perfEvt && perfEvt[_DYN_SET_CTX /* @min:%2esetCtx */]) {\n          perfEvt[_DYN_SET_CTX /* @min:%2esetCtx */](\"exception\", ex);\n        }\n      } finally {\n        // fire the perf event\n        if (perfEvt) {\n          perfMgr.fire(perfEvt);\n        }\n        // Reset the active event to the previous value\n        perfMgr[_DYN_SET_CTX /* @min:%2esetCtx */](doPerfActiveKey, currentActive);\n      }\n    }\n  }\n  return func();\n}\n/**\r\n * Set the global performance manager to use when there is no core instance or it has not been initialized yet.\r\n * @param perfManager - The IPerfManager instance to use when no performance manager is supplied.\r\n */\nexport function setGblPerfMgr(perfManager) {\n  _defaultPerfManager = perfManager;\n}\n/**\r\n * Get the current global performance manager that will be used with no performance manager is supplied.\r\n * @returns - The current default manager\r\n */\nexport function getGblPerfMgr() {\n  return _defaultPerfManager;\n}","map":{"version":3,"names":["dynamicProto","isArray","isFunction","objDefine","utcNow","_DYN_COMPLETE","_DYN_GET_CTX","_DYN_IS_ASYNC","_DYN_IS_CHILD_EVT","_DYN_LENGTH","_DYN_NAME","_DYN_PUSH","_DYN_SET_CTX","_DYN_TIME","STR_GET_PERF_MGR","STR_PERF_EVENT","strExecutionContextKey","strParentContextKey","strChildrenContextKey","_defaultPerfManager","PerfEvent","name","payloadDetails","isAsync","_self","start","theDetails_1","g","key","value","ctx","childTime","childEvts","lp","childEvt","exTime","ParentContextKey","ChildrenContextKey","PerfManager","manager","create","src","fire","perfEvent","doPerfActiveKey","doPerf","mgrSource","getSource","func","details","perfMgr","perfEvt","currentActive","children","ex","setGblPerfMgr","perfManager","getGblPerfMgr"],"sources":["/home/veeresh133/app/my-app/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/PerfManager.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { isArray, isFunction, objDefine, utcNow } from \"@nevware21/ts-utils\";\r\nimport { _DYN_COMPLETE, _DYN_GET_CTX, _DYN_IS_ASYNC, _DYN_IS_CHILD_EVT, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SET_CTX, _DYN_TIME } from \"../__DynamicConstants\";\r\nimport { STR_GET_PERF_MGR, STR_PERF_EVENT } from \"./InternalConstants\";\r\nvar strExecutionContextKey = \"ctx\";\r\nvar strParentContextKey = \"ParentContextKey\";\r\nvar strChildrenContextKey = \"ChildrenContextKey\";\r\nvar _defaultPerfManager = null;\r\nvar PerfEvent = /** @class */ (function () {\r\n    function PerfEvent(name, payloadDetails, isAsync) {\r\n        var _self = this;\r\n        _self.start = utcNow();\r\n        _self[_DYN_NAME /* @min:%2ename */] = name;\r\n        _self[_DYN_IS_ASYNC /* @min:%2eisAsync */] = isAsync;\r\n        _self[_DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */] = function () { return false; };\r\n        if (isFunction(payloadDetails)) {\r\n            // Create an accessor to minimize the potential performance impact of executing the payloadDetails callback\r\n            var theDetails_1;\r\n            objDefine(_self, \"payload\", {\r\n                g: function () {\r\n                    // Delay the execution of the payloadDetails until needed\r\n                    if (!theDetails_1 && isFunction(payloadDetails)) {\r\n                        theDetails_1 = payloadDetails();\r\n                        // clear it out now so the referenced objects can be garbage collected\r\n                        payloadDetails = null;\r\n                    }\r\n                    return theDetails_1;\r\n                }\r\n            });\r\n        }\r\n        _self[_DYN_GET_CTX /* @min:%2egetCtx */] = function (key) {\r\n            if (key) {\r\n                // The parent and child links are located directly on the object (for better viewing in the DebugPlugin)\r\n                if (key === PerfEvent[strParentContextKey] || key === PerfEvent[strChildrenContextKey]) {\r\n                    return _self[key];\r\n                }\r\n                return (_self[strExecutionContextKey] || {})[key];\r\n            }\r\n            return null;\r\n        };\r\n        _self[_DYN_SET_CTX /* @min:%2esetCtx */] = function (key, value) {\r\n            if (key) {\r\n                // Put the parent and child links directly on the object (for better viewing in the DebugPlugin)\r\n                if (key === PerfEvent[strParentContextKey]) {\r\n                    // Simple assumption, if we are setting a parent then we must be a child\r\n                    if (!_self[key]) {\r\n                        _self[_DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */] = function () { return true; };\r\n                    }\r\n                    _self[key] = value;\r\n                }\r\n                else if (key === PerfEvent[strChildrenContextKey]) {\r\n                    _self[key] = value;\r\n                }\r\n                else {\r\n                    var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};\r\n                    ctx[key] = value;\r\n                }\r\n            }\r\n        };\r\n        _self[_DYN_COMPLETE /* @min:%2ecomplete */] = function () {\r\n            var childTime = 0;\r\n            var childEvts = _self[_DYN_GET_CTX /* @min:%2egetCtx */](PerfEvent[strChildrenContextKey]);\r\n            if (isArray(childEvts)) {\r\n                for (var lp = 0; lp < childEvts[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n                    var childEvt = childEvts[lp];\r\n                    if (childEvt) {\r\n                        childTime += childEvt[_DYN_TIME /* @min:%2etime */];\r\n                    }\r\n                }\r\n            }\r\n            _self[_DYN_TIME /* @min:%2etime */] = utcNow() - _self.start;\r\n            _self.exTime = _self[_DYN_TIME /* @min:%2etime */] - childTime;\r\n            _self[_DYN_COMPLETE /* @min:%2ecomplete */] = function () { };\r\n        };\r\n    }\r\n    PerfEvent.ParentContextKey = \"parent\";\r\n    PerfEvent.ChildrenContextKey = \"childEvts\";\r\n    return PerfEvent;\r\n}());\r\nexport { PerfEvent };\r\nvar PerfManager = /** @class */ (function () {\r\n    function PerfManager(manager) {\r\n        /**\r\n         * General bucket used for execution context set and retrieved via setCtx() and getCtx.\r\n         * Defined as private so it can be visualized via the DebugPlugin\r\n         */\r\n        this.ctx = {};\r\n        dynamicProto(PerfManager, this, function (_self) {\r\n            _self.create = function (src, payloadDetails, isAsync) {\r\n                // TODO (@MSNev): at some point we will want to add additional configuration to \"select\" which events to instrument\r\n                // for now this is just a simple do everything.\r\n                return new PerfEvent(src, payloadDetails, isAsync);\r\n            };\r\n            _self.fire = function (perfEvent) {\r\n                if (perfEvent) {\r\n                    perfEvent[_DYN_COMPLETE /* @min:%2ecomplete */]();\r\n                    if (manager && isFunction(manager[STR_PERF_EVENT /* @min:%2eperfEvent */])) {\r\n                        manager[STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);\r\n                    }\r\n                }\r\n            };\r\n            _self[_DYN_SET_CTX /* @min:%2esetCtx */] = function (key, value) {\r\n                if (key) {\r\n                    var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};\r\n                    ctx[key] = value;\r\n                }\r\n            };\r\n            _self[_DYN_GET_CTX /* @min:%2egetCtx */] = function (key) {\r\n                return (_self[strExecutionContextKey] || {})[key];\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Create a new event and start timing, the manager may return null/undefined to indicate that it does not\r\n     * want to monitor this source event.\r\n     * @param src - The source name of the event\r\n     * @param payloadDetails - An optional callback function to fetch the payload details for the event.\r\n     * @param isAsync - Is the event occurring from a async event\r\n     */\r\n    PerfManager.prototype.create = function (src, payload, isAsync) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Complete the perfEvent and fire any notifications.\r\n     * @param perfEvent - Fire the event which will also complete the passed event\r\n     */\r\n    PerfManager.prototype.fire = function (perfEvent) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Set an execution context value\r\n     * @param key - The context key name\r\n     * @param value - The value\r\n     */\r\n    PerfManager.prototype.setCtx = function (key, value) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Get the execution context value\r\n     * @param key - The context key\r\n     */\r\n    PerfManager.prototype.getCtx = function (key) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return PerfManager;\r\n}());\r\nexport { PerfManager };\r\nvar doPerfActiveKey = \"CoreUtils.doPerf\";\r\n/**\r\n * Helper function to wrap a function with a perf event\r\n * @param mgrSource - The Performance Manager or a Performance provider source (may be null)\r\n * @param getSource - The callback to create the source name for the event (if perf monitoring is enabled)\r\n * @param func - The function to call and measure\r\n * @param details - A function to return the payload details\r\n * @param isAsync - Is the event / function being call asynchronously or synchronously\r\n */\r\nexport function doPerf(mgrSource, getSource, func, details, isAsync) {\r\n    if (mgrSource) {\r\n        var perfMgr = mgrSource;\r\n        if (perfMgr[STR_GET_PERF_MGR]) {\r\n            // Looks like a perf manager provider object\r\n            perfMgr = perfMgr[STR_GET_PERF_MGR]();\r\n        }\r\n        if (perfMgr) {\r\n            var perfEvt = void 0;\r\n            var currentActive = perfMgr[_DYN_GET_CTX /* @min:%2egetCtx */](doPerfActiveKey);\r\n            try {\r\n                perfEvt = perfMgr.create(getSource(), details, isAsync);\r\n                if (perfEvt) {\r\n                    if (currentActive && perfEvt[_DYN_SET_CTX /* @min:%2esetCtx */]) {\r\n                        perfEvt[_DYN_SET_CTX /* @min:%2esetCtx */](PerfEvent[strParentContextKey], currentActive);\r\n                        if (currentActive[_DYN_GET_CTX /* @min:%2egetCtx */] && currentActive[_DYN_SET_CTX /* @min:%2esetCtx */]) {\r\n                            var children = currentActive[_DYN_GET_CTX /* @min:%2egetCtx */](PerfEvent[strChildrenContextKey]);\r\n                            if (!children) {\r\n                                children = [];\r\n                                currentActive[_DYN_SET_CTX /* @min:%2esetCtx */](PerfEvent[strChildrenContextKey], children);\r\n                            }\r\n                            children[_DYN_PUSH /* @min:%2epush */](perfEvt);\r\n                        }\r\n                    }\r\n                    // Set this event as the active event now\r\n                    perfMgr[_DYN_SET_CTX /* @min:%2esetCtx */](doPerfActiveKey, perfEvt);\r\n                    return func(perfEvt);\r\n                }\r\n            }\r\n            catch (ex) {\r\n                if (perfEvt && perfEvt[_DYN_SET_CTX /* @min:%2esetCtx */]) {\r\n                    perfEvt[_DYN_SET_CTX /* @min:%2esetCtx */](\"exception\", ex);\r\n                }\r\n            }\r\n            finally {\r\n                // fire the perf event\r\n                if (perfEvt) {\r\n                    perfMgr.fire(perfEvt);\r\n                }\r\n                // Reset the active event to the previous value\r\n                perfMgr[_DYN_SET_CTX /* @min:%2esetCtx */](doPerfActiveKey, currentActive);\r\n            }\r\n        }\r\n    }\r\n    return func();\r\n}\r\n/**\r\n * Set the global performance manager to use when there is no core instance or it has not been initialized yet.\r\n * @param perfManager - The IPerfManager instance to use when no performance manager is supplied.\r\n */\r\nexport function setGblPerfMgr(perfManager) {\r\n    _defaultPerfManager = perfManager;\r\n}\r\n/**\r\n * Get the current global performance manager that will be used with no performance manager is supplied.\r\n * @returns - The current default manager\r\n */\r\nexport function getGblPerfMgr() {\r\n    return _defaultPerfManager;\r\n}\r\n//# sourceMappingURL=PerfManager.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}