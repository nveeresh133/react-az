{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Channel, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nimport { __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { utlGetSessionStorage, utlRemoveSessionStorage, utlSetSessionStorage } from \"@microsoft/applicationinsights-common\";\nimport { _throwInternal, arrForEach, arrIndexOf, dumpObj, getExceptionName, getJSON, isArray, isFunction, isNullOrUndefined, isString } from \"@microsoft/applicationinsights-core-js\";\nimport { _DYN_BUFFER_OVERRIDE, _DYN_CLEAR, _DYN_CLEAR_SENT, _DYN_CONCAT, _DYN_COUNT, _DYN_CREATE_NEW, _DYN_EMIT_LINE_DELIMITED_0, _DYN_ENQUEUE, _DYN_EVENTS_LIMIT_IN_MEM, _DYN_ITEM, _DYN_LENGTH, _DYN_MARK_AS_SENT, _DYN_PUSH, _DYN_STRINGIFY, _DYN__BUFFER__KEY, _DYN__GET, _DYN__MAX__BUFFER__SIZE, _DYN__SENT__BUFFER__KEY } from \"./__DynamicConstants\";\nvar BaseSendBuffer = /** @class */function () {\n  function BaseSendBuffer(logger, config) {\n    var _buffer = [];\n    var _bufferFullMessageSent = false;\n    var _maxRetryCnt = config.maxRetryCnt;\n    this[_DYN__GET /* @min:%2e_get */] = function () {\n      return _buffer;\n    };\n    this._set = function (buffer) {\n      _buffer = buffer;\n      return _buffer;\n    };\n    dynamicProto(BaseSendBuffer, this, function (_self) {\n      _self[_DYN_ENQUEUE /* @min:%2eenqueue */] = function (payload) {\n        if (_self[_DYN_COUNT /* @min:%2ecount */]() >= config[_DYN_EVENTS_LIMIT_IN_MEM /* @min:%2eeventsLimitInMem */]) {\n          // sent internal log only once per page view\n          if (!_bufferFullMessageSent) {\n            _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 105 /* _eInternalMessageId.InMemoryStorageBufferFull */, \"Maximum in-memory buffer size reached: \" + _self[_DYN_COUNT /* @min:%2ecount */](), true);\n            _bufferFullMessageSent = true;\n          }\n          return;\n        }\n        payload.cnt = payload.cnt || 0;\n        // max retry is defined, and max retry is reached, do not add the payload to buffer\n        if (!isNullOrUndefined(_maxRetryCnt)) {\n          if (payload.cnt > _maxRetryCnt) {\n            // TODO: add log here on dropping payloads\n            return;\n          }\n        }\n        _buffer[_DYN_PUSH /* @min:%2epush */](payload);\n        return;\n      };\n      _self[_DYN_COUNT /* @min:%2ecount */] = function () {\n        return _buffer[_DYN_LENGTH /* @min:%2elength */];\n      };\n      _self.size = function () {\n        var size = _buffer[_DYN_LENGTH /* @min:%2elength */];\n        for (var lp = 0; lp < _buffer[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n          size += _buffer[lp].item[_DYN_LENGTH /* @min:%2elength */];\n        }\n        if (!config[_DYN_EMIT_LINE_DELIMITED_0 /* @min:%2eemitLineDelimitedJson */]) {\n          size += 2;\n        }\n        return size;\n      };\n      _self[_DYN_CLEAR /* @min:%2eclear */] = function () {\n        _buffer = [];\n        _bufferFullMessageSent = false;\n      };\n      _self.getItems = function () {\n        return _buffer.slice(0);\n      };\n      _self.batchPayloads = function (payloads) {\n        if (payloads && payloads[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          var payloadStr_1 = [];\n          arrForEach(payloads, function (payload) {\n            payloadStr_1[_DYN_PUSH /* @min:%2epush */](payload[_DYN_ITEM /* @min:%2eitem */]);\n          });\n          var batch = config[_DYN_EMIT_LINE_DELIMITED_0 /* @min:%2eemitLineDelimitedJson */] ? payloadStr_1.join(\"\\n\") : \"[\" + payloadStr_1.join(\",\") + \"]\";\n          return batch;\n        }\n        return null;\n      };\n      _self[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = function (newLogger, newConfig, canUseSessionStorage) {\n        var items = _buffer.slice(0);\n        newLogger = newLogger || logger;\n        newConfig = newConfig || {};\n        var newBuffer = !!canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);\n        arrForEach(items, function (payload) {\n          newBuffer[_DYN_ENQUEUE /* @min:%2eenqueue */](payload);\n        });\n        return newBuffer;\n      };\n    });\n  }\n  // Removed Stub for BaseSendBuffer.prototype.enqueue.\n  // Removed Stub for BaseSendBuffer.prototype.count.\n  // Removed Stub for BaseSendBuffer.prototype.size.\n  // Removed Stub for BaseSendBuffer.prototype.clear.\n  // Removed Stub for BaseSendBuffer.prototype.getItems.\n  // Removed Stub for BaseSendBuffer.prototype.batchPayloads.\n  // Removed Stub for BaseSendBuffer.prototype.createNew.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  BaseSendBuffer.__ieDyn = 1;\n  return BaseSendBuffer;\n}();\n/*\r\n * An array based send buffer.\r\n */\nvar ArraySendBuffer = /** @class */function (_super) {\n  __extends(ArraySendBuffer, _super);\n  function ArraySendBuffer(logger, config) {\n    var _this = _super.call(this, logger, config) || this;\n    dynamicProto(ArraySendBuffer, _this, function (_self, _base) {\n      _self[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */] = function (payload) {\n        _base[_DYN_CLEAR /* @min:%2eclear */]();\n      };\n      _self[_DYN_CLEAR_SENT /* @min:%2eclearSent */] = function (payload) {\n        // not supported\n      };\n    });\n    return _this;\n  }\n  // Removed Stub for ArraySendBuffer.prototype.markAsSent.\n  // Removed Stub for ArraySendBuffer.prototype.clearSent.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  ArraySendBuffer.__ieDyn = 1;\n  return ArraySendBuffer;\n}(BaseSendBuffer);\nexport { ArraySendBuffer };\nvar PREVIOUS_KEYS = [\"AI_buffer\", \"AI_sentBuffer\"];\n/*\r\n * Session storage buffer holds a copy of all unsent items in the browser session storage.\r\n */\nvar SessionStorageSendBuffer = /** @class */function (_super) {\n  __extends(SessionStorageSendBuffer, _super);\n  function SessionStorageSendBuffer(logger, config) {\n    var _this = _super.call(this, logger, config) || this;\n    var _bufferFullMessageSent = false;\n    //Note: should not use config.namePrefix directly, because it will always refers to the latest namePrefix\n    var _namePrefix = config === null || config === void 0 ? void 0 : config.namePrefix;\n    // TODO: add remove buffer override as well\n    var _b = config[_DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */] || {\n        getItem: utlGetSessionStorage,\n        setItem: utlSetSessionStorage\n      },\n      getItem = _b.getItem,\n      setItem = _b.setItem;\n    var _maxRetryCnt = config.maxRetryCnt;\n    dynamicProto(SessionStorageSendBuffer, _this, function (_self, _base) {\n      var bufferItems = _getBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */]);\n      var itemsInSentBuffer = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);\n      var previousItems = _getPreviousEvents();\n      var notDeliveredItems = itemsInSentBuffer[_DYN_CONCAT /* @min:%2econcat */](previousItems);\n      var buffer = _self._set(bufferItems[_DYN_CONCAT /* @min:%2econcat */](notDeliveredItems));\n      // If the buffer has too many items, drop items from the end.\n      if (buffer[_DYN_LENGTH /* @min:%2elength */] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {\n        buffer[_DYN_LENGTH /* @min:%2elength */] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */];\n      }\n      _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], []);\n      _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], buffer);\n      _self[_DYN_ENQUEUE /* @min:%2eenqueue */] = function (payload) {\n        if (_self[_DYN_COUNT /* @min:%2ecount */]() >= SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {\n          // sent internal log only once per page view\n          if (!_bufferFullMessageSent) {\n            _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 67 /* _eInternalMessageId.SessionStorageBufferFull */, \"Maximum buffer size reached: \" + _self[_DYN_COUNT /* @min:%2ecount */](), true);\n            _bufferFullMessageSent = true;\n          }\n          return;\n        }\n        payload.cnt = payload.cnt || 0;\n        // max retry is defined, and max retry is reached, do not add the payload to buffer\n        if (!isNullOrUndefined(_maxRetryCnt)) {\n          if (payload.cnt > _maxRetryCnt) {\n            // TODO: add log here on dropping payloads\n            return;\n          }\n        }\n        _base[_DYN_ENQUEUE /* @min:%2eenqueue */](payload);\n        _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DYN__GET /* @min:%2e_get */]());\n      };\n      _self[_DYN_CLEAR /* @min:%2eclear */] = function () {\n        _base[_DYN_CLEAR /* @min:%2eclear */]();\n        _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DYN__GET /* @min:%2e_get */]());\n        _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], []);\n        _bufferFullMessageSent = false;\n      };\n      _self[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */] = function (payload) {\n        _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], _self._set(_removePayloadsFromBuffer(payload, _self[_DYN__GET /* @min:%2e_get */]())));\n        var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);\n        if (sentElements instanceof Array && payload instanceof Array) {\n          sentElements = sentElements[_DYN_CONCAT /* @min:%2econcat */](payload);\n          if (sentElements[_DYN_LENGTH /* @min:%2elength */] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {\n            // We send telemetry normally. If the SENT_BUFFER is too big we don't add new elements\n            // until we receive a response from the backend and the buffer has free space again (see clearSent method)\n            _throwInternal(logger, 1 /* eLoggingSeverity.CRITICAL */, 67 /* _eInternalMessageId.SessionStorageBufferFull */, \"Sent buffer reached its maximum size: \" + sentElements[_DYN_LENGTH /* @min:%2elength */], true);\n            sentElements[_DYN_LENGTH /* @min:%2elength */] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */];\n          }\n          _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], sentElements);\n        }\n      };\n      _self[_DYN_CLEAR_SENT /* @min:%2eclearSent */] = function (payload) {\n        var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);\n        sentElements = _removePayloadsFromBuffer(payload, sentElements);\n        _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], sentElements);\n      };\n      _self[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = function (newLogger, newConfig, canUseSessionStorage) {\n        canUseSessionStorage = !!canUseSessionStorage;\n        var unsentItems = _self[_DYN__GET /* @min:%2e_get */]().slice(0);\n        var sentItems = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]).slice(0);\n        newLogger = newLogger || logger;\n        newConfig = newConfig || {};\n        // to make sure that we do not send duplicated payloads when it is switched back to previous one\n        _self[_DYN_CLEAR /* @min:%2eclear */]();\n        var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);\n        arrForEach(unsentItems, function (payload) {\n          newBuffer[_DYN_ENQUEUE /* @min:%2eenqueue */](payload);\n        });\n        if (canUseSessionStorage) {\n          // arr buffer will clear all payloads if markAsSent() is called\n          newBuffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](sentItems);\n        }\n        return newBuffer;\n      };\n      function _removePayloadsFromBuffer(payloads, buffer) {\n        var remaining = [];\n        var payloadStr = [];\n        arrForEach(payloads, function (payload) {\n          payloadStr[_DYN_PUSH /* @min:%2epush */](payload[_DYN_ITEM /* @min:%2eitem */]);\n        });\n        arrForEach(buffer, function (value) {\n          if (!isFunction(value) && arrIndexOf(payloadStr, value[_DYN_ITEM /* @min:%2eitem */]) === -1) {\n            remaining[_DYN_PUSH /* @min:%2epush */](value);\n          }\n        });\n        return remaining;\n      }\n      function _getBuffer(key) {\n        var prefixedKey = key;\n        prefixedKey = _namePrefix ? _namePrefix + \"_\" + prefixedKey : prefixedKey;\n        return _getBufferBase(prefixedKey);\n      }\n      function _getBufferBase(key) {\n        try {\n          var bufferJson = getItem(logger, key);\n          if (bufferJson) {\n            var buffer_1 = getJSON().parse(bufferJson);\n            if (isString(buffer_1)) {\n              // When using some version prototype.js the stringify / parse cycle does not decode array's correctly\n              buffer_1 = getJSON().parse(buffer_1);\n            }\n            if (buffer_1 && isArray(buffer_1)) {\n              return buffer_1;\n            }\n          }\n        } catch (e) {\n          _throwInternal(logger, 1 /* eLoggingSeverity.CRITICAL */, 42 /* _eInternalMessageId.FailedToRestoreStorageBuffer */, \" storage key: \" + key + \", \" + getExceptionName(e), {\n            exception: dumpObj(e)\n          });\n        }\n        return [];\n      }\n      function _setBuffer(key, buffer) {\n        var prefixedKey = key;\n        try {\n          prefixedKey = _namePrefix ? _namePrefix + \"_\" + prefixedKey : prefixedKey;\n          var bufferJson = JSON[_DYN_STRINGIFY /* @min:%2estringify */](buffer);\n          setItem(logger, prefixedKey, bufferJson);\n        } catch (e) {\n          // if there was an error, clear the buffer\n          // telemetry is stored in the _buffer array so we won't loose any items\n          setItem(logger, prefixedKey, JSON[_DYN_STRINGIFY /* @min:%2estringify */]([]));\n          _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 41 /* _eInternalMessageId.FailedToSetStorageBuffer */, \" storage key: \" + prefixedKey + \", \" + getExceptionName(e) + \". Buffer cleared\", {\n            exception: dumpObj(e)\n          });\n        }\n      }\n      // this removes buffer with prefix+key\n      function _getPreviousEvents() {\n        var items = [];\n        try {\n          arrForEach(PREVIOUS_KEYS, function (key) {\n            var events = _getItemsFromPreviousKey(key);\n            items = items[_DYN_CONCAT /* @min:%2econcat */](events);\n            // to make sure that we also transfer items from old prefixed + key buffer\n            if (_namePrefix) {\n              var prefixedKey = _namePrefix + \"_\" + key;\n              var prefixEvents = _getItemsFromPreviousKey(prefixedKey);\n              items = items[_DYN_CONCAT /* @min:%2econcat */](prefixEvents);\n            }\n          });\n          return items;\n        } catch (e) {\n          _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 41 /* _eInternalMessageId.FailedToSetStorageBuffer */, \"Transfer events from previous buffers: \" + getExceptionName(e) + \". previous Buffer items can not be removed\", {\n            exception: dumpObj(e)\n          });\n        }\n        return [];\n      }\n      // transform string[] to IInternalStorageItem[]\n      function _getItemsFromPreviousKey(key) {\n        try {\n          var items = _getBufferBase(key);\n          var transFormedItems_1 = [];\n          arrForEach(items, function (item) {\n            var internalItem = {\n              item: item,\n              cnt: 0 // previous events will be default to 0 count\n            };\n            transFormedItems_1[_DYN_PUSH /* @min:%2epush */](internalItem);\n          });\n          // remove the session storage if we can add events back\n          utlRemoveSessionStorage(logger, key);\n          return transFormedItems_1;\n        } catch (e) {\n          // eslint-disable-next-line no-empty\n        }\n        return [];\n      }\n    });\n    return _this;\n  }\n  // Removed Stub for SessionStorageSendBuffer.prototype.enqueue.\n  // Removed Stub for SessionStorageSendBuffer.prototype.clear.\n  // Removed Stub for SessionStorageSendBuffer.prototype.markAsSent.\n  // Removed Stub for SessionStorageSendBuffer.prototype.clearSent.\n  // Removed Stub for SessionStorageSendBuffer.prototype.createNew.\n  var _a;\n  _a = SessionStorageSendBuffer;\n  SessionStorageSendBuffer.VERSION = \"_1\";\n  SessionStorageSendBuffer.BUFFER_KEY = \"AI_buffer\" + _a.VERSION;\n  SessionStorageSendBuffer.SENT_BUFFER_KEY = \"AI_sentBuffer\" + _a.VERSION;\n  // Maximum number of payloads stored in the buffer. If the buffer is full, new elements will be dropped.\n  SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2000;\n  return SessionStorageSendBuffer;\n}(BaseSendBuffer);\nexport { SessionStorageSendBuffer };","map":{"version":3,"names":["__extendsFn","__extends","dynamicProto","utlGetSessionStorage","utlRemoveSessionStorage","utlSetSessionStorage","_throwInternal","arrForEach","arrIndexOf","dumpObj","getExceptionName","getJSON","isArray","isFunction","isNullOrUndefined","isString","_DYN_BUFFER_OVERRIDE","_DYN_CLEAR","_DYN_CLEAR_SENT","_DYN_CONCAT","_DYN_COUNT","_DYN_CREATE_NEW","_DYN_EMIT_LINE_DELIMITED_0","_DYN_ENQUEUE","_DYN_EVENTS_LIMIT_IN_MEM","_DYN_ITEM","_DYN_LENGTH","_DYN_MARK_AS_SENT","_DYN_PUSH","_DYN_STRINGIFY","_DYN__BUFFER__KEY","_DYN__GET","_DYN__MAX__BUFFER__SIZE","_DYN__SENT__BUFFER__KEY","BaseSendBuffer","logger","config","_buffer","_bufferFullMessageSent","_maxRetryCnt","maxRetryCnt","_set","buffer","_self","payload","cnt","size","lp","item","getItems","slice","batchPayloads","payloads","payloadStr_1","batch","join","newLogger","newConfig","canUseSessionStorage","items","newBuffer","SessionStorageSendBuffer","ArraySendBuffer","_super","_this","call","_base","PREVIOUS_KEYS","_namePrefix","namePrefix","_b","getItem","setItem","bufferItems","_getBuffer","itemsInSentBuffer","previousItems","_getPreviousEvents","notDeliveredItems","_setBuffer","BUFFER_KEY","_removePayloadsFromBuffer","sentElements","Array","unsentItems","sentItems","remaining","payloadStr","value","key","prefixedKey","_getBufferBase","bufferJson","buffer_1","parse","e","exception","JSON","events","_getItemsFromPreviousKey","prefixEvents","transFormedItems_1","internalItem","_a","VERSION","SENT_BUFFER_KEY","MAX_BUFFER_SIZE"],"sources":["/home/veeresh133/app/my-app/node_modules/@microsoft/applicationinsights-channel-js/dist-es5/SendBuffer.js"],"sourcesContent":["import { __extends } from \"tslib\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { utlGetSessionStorage, utlRemoveSessionStorage, utlSetSessionStorage } from \"@microsoft/applicationinsights-common\";\r\nimport { _throwInternal, arrForEach, arrIndexOf, dumpObj, getExceptionName, getJSON, isArray, isFunction, isNullOrUndefined, isString } from \"@microsoft/applicationinsights-core-js\";\r\nimport { _DYN_BUFFER_OVERRIDE, _DYN_CLEAR, _DYN_CLEAR_SENT, _DYN_CONCAT, _DYN_COUNT, _DYN_CREATE_NEW, _DYN_EMIT_LINE_DELIMITED_0, _DYN_ENQUEUE, _DYN_EVENTS_LIMIT_IN_MEM, _DYN_ITEM, _DYN_LENGTH, _DYN_MARK_AS_SENT, _DYN_PUSH, _DYN_STRINGIFY, _DYN__BUFFER__KEY, _DYN__GET, _DYN__MAX__BUFFER__SIZE, _DYN__SENT__BUFFER__KEY } from \"./__DynamicConstants\";\r\nvar BaseSendBuffer = /** @class */ (function () {\r\n    function BaseSendBuffer(logger, config) {\r\n        var _buffer = [];\r\n        var _bufferFullMessageSent = false;\r\n        var _maxRetryCnt = config.maxRetryCnt;\r\n        this[_DYN__GET /* @min:%2e_get */] = function () {\r\n            return _buffer;\r\n        };\r\n        this._set = function (buffer) {\r\n            _buffer = buffer;\r\n            return _buffer;\r\n        };\r\n        dynamicProto(BaseSendBuffer, this, function (_self) {\r\n            _self[_DYN_ENQUEUE /* @min:%2eenqueue */] = function (payload) {\r\n                if (_self[_DYN_COUNT /* @min:%2ecount */]() >= config[_DYN_EVENTS_LIMIT_IN_MEM /* @min:%2eeventsLimitInMem */]) {\r\n                    // sent internal log only once per page view\r\n                    if (!_bufferFullMessageSent) {\r\n                        _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 105 /* _eInternalMessageId.InMemoryStorageBufferFull */, \"Maximum in-memory buffer size reached: \" + _self[_DYN_COUNT /* @min:%2ecount */](), true);\r\n                        _bufferFullMessageSent = true;\r\n                    }\r\n                    return;\r\n                }\r\n                payload.cnt = payload.cnt || 0;\r\n                // max retry is defined, and max retry is reached, do not add the payload to buffer\r\n                if (!isNullOrUndefined(_maxRetryCnt)) {\r\n                    if (payload.cnt > _maxRetryCnt) {\r\n                        // TODO: add log here on dropping payloads\r\n                        return;\r\n                    }\r\n                }\r\n                _buffer[_DYN_PUSH /* @min:%2epush */](payload);\r\n                return;\r\n            };\r\n            _self[_DYN_COUNT /* @min:%2ecount */] = function () {\r\n                return _buffer[_DYN_LENGTH /* @min:%2elength */];\r\n            };\r\n            _self.size = function () {\r\n                var size = _buffer[_DYN_LENGTH /* @min:%2elength */];\r\n                for (var lp = 0; lp < _buffer[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n                    size += (_buffer[lp].item)[_DYN_LENGTH /* @min:%2elength */];\r\n                }\r\n                if (!config[_DYN_EMIT_LINE_DELIMITED_0 /* @min:%2eemitLineDelimitedJson */]) {\r\n                    size += 2;\r\n                }\r\n                return size;\r\n            };\r\n            _self[_DYN_CLEAR /* @min:%2eclear */] = function () {\r\n                _buffer = [];\r\n                _bufferFullMessageSent = false;\r\n            };\r\n            _self.getItems = function () {\r\n                return _buffer.slice(0);\r\n            };\r\n            _self.batchPayloads = function (payloads) {\r\n                if (payloads && payloads[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    var payloadStr_1 = [];\r\n                    arrForEach(payloads, function (payload) {\r\n                        payloadStr_1[_DYN_PUSH /* @min:%2epush */](payload[_DYN_ITEM /* @min:%2eitem */]);\r\n                    });\r\n                    var batch = config[_DYN_EMIT_LINE_DELIMITED_0 /* @min:%2eemitLineDelimitedJson */] ?\r\n                        payloadStr_1.join(\"\\n\") :\r\n                        \"[\" + payloadStr_1.join(\",\") + \"]\";\r\n                    return batch;\r\n                }\r\n                return null;\r\n            };\r\n            _self[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = function (newLogger, newConfig, canUseSessionStorage) {\r\n                var items = _buffer.slice(0);\r\n                newLogger = newLogger || logger;\r\n                newConfig = newConfig || {};\r\n                var newBuffer = !!canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);\r\n                arrForEach(items, function (payload) {\r\n                    newBuffer[_DYN_ENQUEUE /* @min:%2eenqueue */](payload);\r\n                });\r\n                return newBuffer;\r\n            };\r\n        });\r\n    }\r\n    BaseSendBuffer.prototype.enqueue = function (payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    BaseSendBuffer.prototype.count = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 0;\r\n    };\r\n    BaseSendBuffer.prototype.size = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 0;\r\n    };\r\n    BaseSendBuffer.prototype.clear = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    BaseSendBuffer.prototype.getItems = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    BaseSendBuffer.prototype.batchPayloads = function (payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    BaseSendBuffer.prototype.createNew = function (newLogger, newConfig, canUseSessionStorage) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    return BaseSendBuffer;\r\n}());\r\n/*\r\n * An array based send buffer.\r\n */\r\nvar ArraySendBuffer = /** @class */ (function (_super) {\r\n    __extends(ArraySendBuffer, _super);\r\n    function ArraySendBuffer(logger, config) {\r\n        var _this = _super.call(this, logger, config) || this;\r\n        dynamicProto(ArraySendBuffer, _this, function (_self, _base) {\r\n            _self[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */] = function (payload) {\r\n                _base[_DYN_CLEAR /* @min:%2eclear */]();\r\n            };\r\n            _self[_DYN_CLEAR_SENT /* @min:%2eclearSent */] = function (payload) {\r\n                // not supported\r\n            };\r\n        });\r\n        return _this;\r\n    }\r\n    ArraySendBuffer.prototype.markAsSent = function (payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    ArraySendBuffer.prototype.clearSent = function (payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return ArraySendBuffer;\r\n}(BaseSendBuffer));\r\nexport { ArraySendBuffer };\r\nvar PREVIOUS_KEYS = [\"AI_buffer\", \"AI_sentBuffer\"];\r\n/*\r\n * Session storage buffer holds a copy of all unsent items in the browser session storage.\r\n */\r\nvar SessionStorageSendBuffer = /** @class */ (function (_super) {\r\n    __extends(SessionStorageSendBuffer, _super);\r\n    function SessionStorageSendBuffer(logger, config) {\r\n        var _this = _super.call(this, logger, config) || this;\r\n        var _bufferFullMessageSent = false;\r\n        //Note: should not use config.namePrefix directly, because it will always refers to the latest namePrefix\r\n        var _namePrefix = config === null || config === void 0 ? void 0 : config.namePrefix;\r\n        // TODO: add remove buffer override as well\r\n        var _b = config[_DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */] || { getItem: utlGetSessionStorage, setItem: utlSetSessionStorage }, getItem = _b.getItem, setItem = _b.setItem;\r\n        var _maxRetryCnt = config.maxRetryCnt;\r\n        dynamicProto(SessionStorageSendBuffer, _this, function (_self, _base) {\r\n            var bufferItems = _getBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */]);\r\n            var itemsInSentBuffer = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);\r\n            var previousItems = _getPreviousEvents();\r\n            var notDeliveredItems = itemsInSentBuffer[_DYN_CONCAT /* @min:%2econcat */](previousItems);\r\n            var buffer = _self._set(bufferItems[_DYN_CONCAT /* @min:%2econcat */](notDeliveredItems));\r\n            // If the buffer has too many items, drop items from the end.\r\n            if (buffer[_DYN_LENGTH /* @min:%2elength */] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {\r\n                buffer[_DYN_LENGTH /* @min:%2elength */] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */];\r\n            }\r\n            _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], []);\r\n            _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], buffer);\r\n            _self[_DYN_ENQUEUE /* @min:%2eenqueue */] = function (payload) {\r\n                if (_self[_DYN_COUNT /* @min:%2ecount */]() >= SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {\r\n                    // sent internal log only once per page view\r\n                    if (!_bufferFullMessageSent) {\r\n                        _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 67 /* _eInternalMessageId.SessionStorageBufferFull */, \"Maximum buffer size reached: \" + _self[_DYN_COUNT /* @min:%2ecount */](), true);\r\n                        _bufferFullMessageSent = true;\r\n                    }\r\n                    return;\r\n                }\r\n                payload.cnt = payload.cnt || 0;\r\n                // max retry is defined, and max retry is reached, do not add the payload to buffer\r\n                if (!isNullOrUndefined(_maxRetryCnt)) {\r\n                    if (payload.cnt > _maxRetryCnt) {\r\n                        // TODO: add log here on dropping payloads\r\n                        return;\r\n                    }\r\n                }\r\n                _base[_DYN_ENQUEUE /* @min:%2eenqueue */](payload);\r\n                _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DYN__GET /* @min:%2e_get */]());\r\n            };\r\n            _self[_DYN_CLEAR /* @min:%2eclear */] = function () {\r\n                _base[_DYN_CLEAR /* @min:%2eclear */]();\r\n                _setBuffer(SessionStorageSendBuffer.BUFFER_KEY, _self[_DYN__GET /* @min:%2e_get */]());\r\n                _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], []);\r\n                _bufferFullMessageSent = false;\r\n            };\r\n            _self[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */] = function (payload) {\r\n                _setBuffer(SessionStorageSendBuffer[_DYN__BUFFER__KEY /* @min:%2eBUFFER_KEY */], _self._set(_removePayloadsFromBuffer(payload, _self[_DYN__GET /* @min:%2e_get */]())));\r\n                var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);\r\n                if (sentElements instanceof Array && payload instanceof Array) {\r\n                    sentElements = sentElements[_DYN_CONCAT /* @min:%2econcat */](payload);\r\n                    if (sentElements[_DYN_LENGTH /* @min:%2elength */] > SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */]) {\r\n                        // We send telemetry normally. If the SENT_BUFFER is too big we don't add new elements\r\n                        // until we receive a response from the backend and the buffer has free space again (see clearSent method)\r\n                        _throwInternal(logger, 1 /* eLoggingSeverity.CRITICAL */, 67 /* _eInternalMessageId.SessionStorageBufferFull */, \"Sent buffer reached its maximum size: \" + sentElements[_DYN_LENGTH /* @min:%2elength */], true);\r\n                        sentElements[_DYN_LENGTH /* @min:%2elength */] = SessionStorageSendBuffer[_DYN__MAX__BUFFER__SIZE /* @min:%2eMAX_BUFFER_SIZE */];\r\n                    }\r\n                    _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], sentElements);\r\n                }\r\n            };\r\n            _self[_DYN_CLEAR_SENT /* @min:%2eclearSent */] = function (payload) {\r\n                var sentElements = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]);\r\n                sentElements = _removePayloadsFromBuffer(payload, sentElements);\r\n                _setBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */], sentElements);\r\n            };\r\n            _self[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = function (newLogger, newConfig, canUseSessionStorage) {\r\n                canUseSessionStorage = !!canUseSessionStorage;\r\n                var unsentItems = _self[_DYN__GET /* @min:%2e_get */]().slice(0);\r\n                var sentItems = _getBuffer(SessionStorageSendBuffer[_DYN__SENT__BUFFER__KEY /* @min:%2eSENT_BUFFER_KEY */]).slice(0);\r\n                newLogger = newLogger || logger;\r\n                newConfig = newConfig || {};\r\n                // to make sure that we do not send duplicated payloads when it is switched back to previous one\r\n                _self[_DYN_CLEAR /* @min:%2eclear */]();\r\n                var newBuffer = canUseSessionStorage ? new SessionStorageSendBuffer(newLogger, newConfig) : new ArraySendBuffer(newLogger, newConfig);\r\n                arrForEach(unsentItems, function (payload) {\r\n                    newBuffer[_DYN_ENQUEUE /* @min:%2eenqueue */](payload);\r\n                });\r\n                if (canUseSessionStorage) {\r\n                    // arr buffer will clear all payloads if markAsSent() is called\r\n                    newBuffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](sentItems);\r\n                }\r\n                return newBuffer;\r\n            };\r\n            function _removePayloadsFromBuffer(payloads, buffer) {\r\n                var remaining = [];\r\n                var payloadStr = [];\r\n                arrForEach(payloads, function (payload) {\r\n                    payloadStr[_DYN_PUSH /* @min:%2epush */](payload[_DYN_ITEM /* @min:%2eitem */]);\r\n                });\r\n                arrForEach(buffer, function (value) {\r\n                    if (!isFunction(value) && arrIndexOf(payloadStr, value[_DYN_ITEM /* @min:%2eitem */]) === -1) {\r\n                        remaining[_DYN_PUSH /* @min:%2epush */](value);\r\n                    }\r\n                });\r\n                return remaining;\r\n            }\r\n            function _getBuffer(key) {\r\n                var prefixedKey = key;\r\n                prefixedKey = _namePrefix ? _namePrefix + \"_\" + prefixedKey : prefixedKey;\r\n                return _getBufferBase(prefixedKey);\r\n            }\r\n            function _getBufferBase(key) {\r\n                try {\r\n                    var bufferJson = getItem(logger, key);\r\n                    if (bufferJson) {\r\n                        var buffer_1 = getJSON().parse(bufferJson);\r\n                        if (isString(buffer_1)) {\r\n                            // When using some version prototype.js the stringify / parse cycle does not decode array's correctly\r\n                            buffer_1 = getJSON().parse(buffer_1);\r\n                        }\r\n                        if (buffer_1 && isArray(buffer_1)) {\r\n                            return buffer_1;\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    _throwInternal(logger, 1 /* eLoggingSeverity.CRITICAL */, 42 /* _eInternalMessageId.FailedToRestoreStorageBuffer */, \" storage key: \" + key + \", \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                }\r\n                return [];\r\n            }\r\n            function _setBuffer(key, buffer) {\r\n                var prefixedKey = key;\r\n                try {\r\n                    prefixedKey = _namePrefix ? _namePrefix + \"_\" + prefixedKey : prefixedKey;\r\n                    var bufferJson = JSON[_DYN_STRINGIFY /* @min:%2estringify */](buffer);\r\n                    setItem(logger, prefixedKey, bufferJson);\r\n                }\r\n                catch (e) {\r\n                    // if there was an error, clear the buffer\r\n                    // telemetry is stored in the _buffer array so we won't loose any items\r\n                    setItem(logger, prefixedKey, JSON[_DYN_STRINGIFY /* @min:%2estringify */]([]));\r\n                    _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 41 /* _eInternalMessageId.FailedToSetStorageBuffer */, \" storage key: \" + prefixedKey + \", \" + getExceptionName(e) + \". Buffer cleared\", { exception: dumpObj(e) });\r\n                }\r\n            }\r\n            // this removes buffer with prefix+key\r\n            function _getPreviousEvents() {\r\n                var items = [];\r\n                try {\r\n                    arrForEach(PREVIOUS_KEYS, function (key) {\r\n                        var events = _getItemsFromPreviousKey(key);\r\n                        items = items[_DYN_CONCAT /* @min:%2econcat */](events);\r\n                        // to make sure that we also transfer items from old prefixed + key buffer\r\n                        if (_namePrefix) {\r\n                            var prefixedKey = _namePrefix + \"_\" + key;\r\n                            var prefixEvents = _getItemsFromPreviousKey(prefixedKey);\r\n                            items = items[_DYN_CONCAT /* @min:%2econcat */](prefixEvents);\r\n                        }\r\n                    });\r\n                    return items;\r\n                }\r\n                catch (e) {\r\n                    _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 41 /* _eInternalMessageId.FailedToSetStorageBuffer */, \"Transfer events from previous buffers: \" + getExceptionName(e) + \". previous Buffer items can not be removed\", { exception: dumpObj(e) });\r\n                }\r\n                return [];\r\n            }\r\n            // transform string[] to IInternalStorageItem[]\r\n            function _getItemsFromPreviousKey(key) {\r\n                try {\r\n                    var items = _getBufferBase(key);\r\n                    var transFormedItems_1 = [];\r\n                    arrForEach(items, function (item) {\r\n                        var internalItem = {\r\n                            item: item,\r\n                            cnt: 0 // previous events will be default to 0 count\r\n                        };\r\n                        transFormedItems_1[_DYN_PUSH /* @min:%2epush */](internalItem);\r\n                    });\r\n                    // remove the session storage if we can add events back\r\n                    utlRemoveSessionStorage(logger, key);\r\n                    return transFormedItems_1;\r\n                }\r\n                catch (e) {\r\n                    // eslint-disable-next-line no-empty\r\n                }\r\n                return [];\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    SessionStorageSendBuffer.prototype.enqueue = function (payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    SessionStorageSendBuffer.prototype.clear = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    SessionStorageSendBuffer.prototype.markAsSent = function (payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    SessionStorageSendBuffer.prototype.clearSent = function (payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    SessionStorageSendBuffer.prototype.createNew = function (newLogger, newConfig, canUseSessionStorage) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    var _a;\r\n    _a = SessionStorageSendBuffer;\r\n    SessionStorageSendBuffer.VERSION = \"_1\";\r\n    SessionStorageSendBuffer.BUFFER_KEY = \"AI_buffer\" + _a.VERSION;\r\n    SessionStorageSendBuffer.SENT_BUFFER_KEY = \"AI_sentBuffer\" + _a.VERSION;\r\n    // Maximum number of payloads stored in the buffer. If the buffer is full, new elements will be dropped.\r\n    SessionStorageSendBuffer.MAX_BUFFER_SIZE = 2000;\r\n    return SessionStorageSendBuffer;\r\n}(BaseSendBuffer));\r\nexport { SessionStorageSendBuffer };\r\n//# sourceMappingURL=SendBuffer.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}