{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nvar _a;\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { dumpObj, isFunction, isUndefined } from \"@nevware21/ts-utils\";\nimport { createDynamicConfig, onConfigChange } from \"../Config/DynamicConfig\";\nimport { _DYN_DIAG_LOG, _DYN_LOGGER, _DYN_LOGGING_LEVEL_CONSOL4, _DYN_LOG_INTERNAL_MESSAGE, _DYN_MESSAGE, _DYN_MESSAGE_ID, _DYN_PUSH, _DYN_REPLACE, _DYN_THROW_INTERNAL, _DYN_UNLOAD, _DYN_WARN_TO_CONSOLE } from \"../__DynamicConstants\";\nimport { getDebugExt } from \"./DbgExtensionUtils\";\nimport { getConsole, getJSON, hasJSON } from \"./EnvUtils\";\nimport { STR_EMPTY } from \"./InternalConstants\";\nvar STR_WARN_TO_CONSOLE = \"warnToConsole\";\n/**\r\n * For user non actionable traces use AI Internal prefix.\r\n */\nvar AiNonUserActionablePrefix = \"AI (Internal): \";\n/**\r\n * Prefix of the traces in portal.\r\n */\nvar AiUserActionablePrefix = \"AI: \";\n/**\r\n *  Session storage key for the prefix for the key indicating message type already logged\r\n */\nvar AIInternalMessagePrefix = \"AITR_\";\nvar defaultValues = {\n  loggingLevelConsole: 0,\n  loggingLevelTelemetry: 1,\n  maxMessageLimit: 25,\n  enableDebug: false\n};\nvar _logFuncs = (_a = {}, _a[0 /* eLoggingSeverity.DISABLED */] = null, _a[1 /* eLoggingSeverity.CRITICAL */] = \"errorToConsole\", _a[2 /* eLoggingSeverity.WARNING */] = STR_WARN_TO_CONSOLE, _a[3 /* eLoggingSeverity.DEBUG */] = \"debugToConsole\", _a);\nfunction _sanitizeDiagnosticText(text) {\n  if (text) {\n    return \"\\\"\" + text[_DYN_REPLACE /* @min:%2ereplace */](/\\\"/g, STR_EMPTY) + \"\\\"\";\n  }\n  return STR_EMPTY;\n}\nfunction _logToConsole(func, message) {\n  var theConsole = getConsole();\n  if (!!theConsole) {\n    var logFunc = \"log\";\n    if (theConsole[func]) {\n      logFunc = func;\n    }\n    if (isFunction(theConsole[logFunc])) {\n      theConsole[logFunc](message);\n    }\n  }\n}\nvar _InternalLogMessage = /** @class */function () {\n  function _InternalLogMessage(msgId, msg, isUserAct, properties) {\n    if (isUserAct === void 0) {\n      isUserAct = false;\n    }\n    var _self = this;\n    _self[_DYN_MESSAGE_ID /* @min:%2emessageId */] = msgId;\n    _self[_DYN_MESSAGE /* @min:%2emessage */] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;\n    var strProps = STR_EMPTY;\n    if (hasJSON()) {\n      strProps = getJSON().stringify(properties);\n    }\n    var diagnosticText = (msg ? \" message:\" + _sanitizeDiagnosticText(msg) : STR_EMPTY) + (properties ? \" props:\" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);\n    _self[_DYN_MESSAGE /* @min:%2emessage */] += diagnosticText;\n  }\n  _InternalLogMessage.dataType = \"MessageData\";\n  return _InternalLogMessage;\n}();\nexport { _InternalLogMessage };\nexport function safeGetLogger(core, config) {\n  return (core || {})[_DYN_LOGGER /* @min:%2elogger */] || new DiagnosticLogger(config);\n}\nvar DiagnosticLogger = /** @class */function () {\n  function DiagnosticLogger(config) {\n    this.identifier = \"DiagnosticLogger\";\n    /**\r\n     * The internal logging queue\r\n     */\n    this.queue = [];\n    /**\r\n     * Count of internal messages sent\r\n     */\n    var _messageCount = 0;\n    /**\r\n     * Holds information about what message types were already logged to console or sent to server.\r\n     */\n    var _messageLogged = {};\n    var _loggingLevelConsole;\n    var _loggingLevelTelemetry;\n    var _maxInternalMessageLimit;\n    var _enableDebug;\n    var _unloadHandler;\n    dynamicProto(DiagnosticLogger, this, function (_self) {\n      _unloadHandler = _setDefaultsFromConfig(config || {});\n      _self.consoleLoggingLevel = function () {\n        return _loggingLevelConsole;\n      };\n      /**\r\n       * This method will throw exceptions in debug mode or attempt to log the error as a console warning.\r\n       * @param severity - {LoggingSeverity} - The severity of the log message\r\n       * @param message - {_InternalLogMessage} - The log message.\r\n       */\n      _self[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */] = function (severity, msgId, msg, properties, isUserAct) {\n        if (isUserAct === void 0) {\n          isUserAct = false;\n        }\n        var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);\n        if (_enableDebug) {\n          throw dumpObj(message);\n        } else {\n          // Get the logging function and fallback to warnToConsole of for some reason errorToConsole doesn't exist\n          var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;\n          if (!isUndefined(message[_DYN_MESSAGE /* @min:%2emessage */])) {\n            if (isUserAct) {\n              // check if this message type was already logged to console for this page view and if so, don't log it again\n              var messageKey = +message[_DYN_MESSAGE_ID /* @min:%2emessageId */];\n              if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {\n                _self[logFunc](message[_DYN_MESSAGE /* @min:%2emessage */]);\n                _messageLogged[messageKey] = true;\n              }\n            } else {\n              // Only log traces if the console Logging Level is >= the throwInternal severity level\n              if (_loggingLevelConsole >= severity) {\n                _self[logFunc](message[_DYN_MESSAGE /* @min:%2emessage */]);\n              }\n            }\n            _logInternalMessage(severity, message);\n          } else {\n            _debugExtMsg(\"throw\" + (severity === 1 /* eLoggingSeverity.CRITICAL */ ? \"Critical\" : \"Warning\"), message);\n          }\n        }\n      };\n      _self.debugToConsole = function (message) {\n        _logToConsole(\"debug\", message);\n        _debugExtMsg(\"warning\", message);\n      };\n      _self[_DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */] = function (message) {\n        _logToConsole(\"warn\", message);\n        _debugExtMsg(\"warning\", message);\n      };\n      _self.errorToConsole = function (message) {\n        _logToConsole(\"error\", message);\n        _debugExtMsg(\"error\", message);\n      };\n      _self.resetInternalMessageCount = function () {\n        _messageCount = 0;\n        _messageLogged = {};\n      };\n      _self[_DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */] = _logInternalMessage;\n      _self[_DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {\n        _unloadHandler && _unloadHandler.rm();\n        _unloadHandler = null;\n      };\n      function _logInternalMessage(severity, message) {\n        if (_areInternalMessagesThrottled()) {\n          return;\n        }\n        // check if this message type was already logged for this session and if so, don't log it again\n        var logMessage = true;\n        var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID /* @min:%2emessageId */];\n        // if the session storage is not available, limit to only one message type per page view\n        if (_messageLogged[messageKey]) {\n          logMessage = false;\n        } else {\n          _messageLogged[messageKey] = true;\n        }\n        if (logMessage) {\n          // Push the event in the internal queue\n          if (severity <= _loggingLevelTelemetry) {\n            _self.queue[_DYN_PUSH /* @min:%2epush */](message);\n            _messageCount++;\n            _debugExtMsg(severity === 1 /* eLoggingSeverity.CRITICAL */ ? \"error\" : \"warn\", message);\n          }\n          // When throttle limit reached, send a special event\n          if (_messageCount === _maxInternalMessageLimit) {\n            var throttleLimitMessage = \"Internal events throttle limit per PageView reached for this app.\";\n            var throttleMessage = new _InternalLogMessage(23 /* _eInternalMessageId.MessageLimitPerPVExceeded */, throttleLimitMessage, false);\n            _self.queue[_DYN_PUSH /* @min:%2epush */](throttleMessage);\n            if (severity === 1 /* eLoggingSeverity.CRITICAL */) {\n              _self.errorToConsole(throttleLimitMessage);\n            } else {\n              _self[_DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](throttleLimitMessage);\n            }\n          }\n        }\n      }\n      function _setDefaultsFromConfig(config) {\n        // make sure the config is dynamic\n        return onConfigChange(createDynamicConfig(config, defaultValues, _self).cfg, function (details) {\n          var config = details.cfg;\n          _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4 /* @min:%2eloggingLevelConsole */];\n          _loggingLevelTelemetry = config.loggingLevelTelemetry;\n          _maxInternalMessageLimit = config.maxMessageLimit;\n          _enableDebug = config.enableDebug;\n        });\n      }\n      function _areInternalMessagesThrottled() {\n        return _messageCount >= _maxInternalMessageLimit;\n      }\n      function _debugExtMsg(name, data) {\n        var dbgExt = getDebugExt(config || {});\n        if (dbgExt && dbgExt[_DYN_DIAG_LOG /* @min:%2ediagLog */]) {\n          dbgExt[_DYN_DIAG_LOG /* @min:%2ediagLog */](name, data);\n        }\n      }\n    });\n  }\n  // Removed Stub for DiagnosticLogger.prototype.consoleLoggingLevel.\n  // Removed Stub for DiagnosticLogger.prototype.throwInternal.\n  // Removed Stub for DiagnosticLogger.prototype.debugToConsole.\n  // Removed Stub for DiagnosticLogger.prototype.warnToConsole.\n  // Removed Stub for DiagnosticLogger.prototype.errorToConsole.\n  // Removed Stub for DiagnosticLogger.prototype.resetInternalMessageCount.\n  // Removed Stub for DiagnosticLogger.prototype.logInternalMessage.\n  // Removed Stub for DiagnosticLogger.prototype.unload.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  DiagnosticLogger.__ieDyn = 1;\n  return DiagnosticLogger;\n}();\nexport { DiagnosticLogger };\nfunction _getLogger(logger) {\n  return logger || new DiagnosticLogger();\n}\n/**\r\n * This is a helper method which will call throwInternal on the passed logger, will throw exceptions in\r\n * debug mode or attempt to log the error as a console warning. This helper is provided mostly to better\r\n * support minification as logger.throwInternal() will not compress the publish \"throwInternal\" used throughout\r\n * the code.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param severity - {LoggingSeverity} - The severity of the log message\r\n * @param message - {_InternalLogMessage} - The log message.\r\n */\nexport function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {\n  if (isUserAct === void 0) {\n    isUserAct = false;\n  }\n  _getLogger(logger)[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](severity, msgId, msg, properties, isUserAct);\n}\n/**\r\n * This is a helper method which will call warnToConsole on the passed logger with the provided message.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param message - {_InternalLogMessage} - The log message.\r\n */\nexport function _warnToConsole(logger, message) {\n  _getLogger(logger)[_DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);\n}\n/**\r\n * Logs a message to the internal queue.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param severity - {LoggingSeverity} - The severity of the log message\r\n * @param message - {_InternalLogMessage} - The message to log.\r\n */\nexport function _logInternalMessage(logger, severity, message) {\n  _getLogger(logger)[_DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */](severity, message);\n}","map":{"version":3,"names":["_a","dynamicProto","dumpObj","isFunction","isUndefined","createDynamicConfig","onConfigChange","_DYN_DIAG_LOG","_DYN_LOGGER","_DYN_LOGGING_LEVEL_CONSOL4","_DYN_LOG_INTERNAL_MESSAGE","_DYN_MESSAGE","_DYN_MESSAGE_ID","_DYN_PUSH","_DYN_REPLACE","_DYN_THROW_INTERNAL","_DYN_UNLOAD","_DYN_WARN_TO_CONSOLE","getDebugExt","getConsole","getJSON","hasJSON","STR_EMPTY","STR_WARN_TO_CONSOLE","AiNonUserActionablePrefix","AiUserActionablePrefix","AIInternalMessagePrefix","defaultValues","loggingLevelConsole","loggingLevelTelemetry","maxMessageLimit","enableDebug","_logFuncs","_sanitizeDiagnosticText","text","_logToConsole","func","message","theConsole","logFunc","_InternalLogMessage","msgId","msg","isUserAct","properties","_self","strProps","stringify","diagnosticText","dataType","safeGetLogger","core","config","DiagnosticLogger","identifier","queue","_messageCount","_messageLogged","_loggingLevelConsole","_loggingLevelTelemetry","_maxInternalMessageLimit","_enableDebug","_unloadHandler","_setDefaultsFromConfig","consoleLoggingLevel","severity","messageKey","_logInternalMessage","_debugExtMsg","debugToConsole","errorToConsole","resetInternalMessageCount","isAsync","rm","_areInternalMessagesThrottled","logMessage","throttleLimitMessage","throttleMessage","cfg","details","name","data","dbgExt","_getLogger","logger","_throwInternal","_warnToConsole"],"sources":["/home/veeresh133/app/my-app/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/DiagnosticLogger.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nvar _a;\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { dumpObj, isFunction, isUndefined } from \"@nevware21/ts-utils\";\r\nimport { createDynamicConfig, onConfigChange } from \"../Config/DynamicConfig\";\r\nimport { _DYN_DIAG_LOG, _DYN_LOGGER, _DYN_LOGGING_LEVEL_CONSOL4, _DYN_LOG_INTERNAL_MESSAGE, _DYN_MESSAGE, _DYN_MESSAGE_ID, _DYN_PUSH, _DYN_REPLACE, _DYN_THROW_INTERNAL, _DYN_UNLOAD, _DYN_WARN_TO_CONSOLE } from \"../__DynamicConstants\";\r\nimport { getDebugExt } from \"./DbgExtensionUtils\";\r\nimport { getConsole, getJSON, hasJSON } from \"./EnvUtils\";\r\nimport { STR_EMPTY } from \"./InternalConstants\";\r\nvar STR_WARN_TO_CONSOLE = \"warnToConsole\";\r\n/**\r\n * For user non actionable traces use AI Internal prefix.\r\n */\r\nvar AiNonUserActionablePrefix = \"AI (Internal): \";\r\n/**\r\n * Prefix of the traces in portal.\r\n */\r\nvar AiUserActionablePrefix = \"AI: \";\r\n/**\r\n *  Session storage key for the prefix for the key indicating message type already logged\r\n */\r\nvar AIInternalMessagePrefix = \"AITR_\";\r\nvar defaultValues = {\r\n    loggingLevelConsole: 0,\r\n    loggingLevelTelemetry: 1,\r\n    maxMessageLimit: 25,\r\n    enableDebug: false\r\n};\r\nvar _logFuncs = (_a = {},\r\n    _a[0 /* eLoggingSeverity.DISABLED */] = null,\r\n    _a[1 /* eLoggingSeverity.CRITICAL */] = \"errorToConsole\",\r\n    _a[2 /* eLoggingSeverity.WARNING */] = STR_WARN_TO_CONSOLE,\r\n    _a[3 /* eLoggingSeverity.DEBUG */] = \"debugToConsole\",\r\n    _a);\r\nfunction _sanitizeDiagnosticText(text) {\r\n    if (text) {\r\n        return \"\\\"\" + text[_DYN_REPLACE /* @min:%2ereplace */](/\\\"/g, STR_EMPTY) + \"\\\"\";\r\n    }\r\n    return STR_EMPTY;\r\n}\r\nfunction _logToConsole(func, message) {\r\n    var theConsole = getConsole();\r\n    if (!!theConsole) {\r\n        var logFunc = \"log\";\r\n        if (theConsole[func]) {\r\n            logFunc = func;\r\n        }\r\n        if (isFunction(theConsole[logFunc])) {\r\n            theConsole[logFunc](message);\r\n        }\r\n    }\r\n}\r\nvar _InternalLogMessage = /** @class */ (function () {\r\n    function _InternalLogMessage(msgId, msg, isUserAct, properties) {\r\n        if (isUserAct === void 0) { isUserAct = false; }\r\n        var _self = this;\r\n        _self[_DYN_MESSAGE_ID /* @min:%2emessageId */] = msgId;\r\n        _self[_DYN_MESSAGE /* @min:%2emessage */] =\r\n            (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) +\r\n                msgId;\r\n        var strProps = STR_EMPTY;\r\n        if (hasJSON()) {\r\n            strProps = getJSON().stringify(properties);\r\n        }\r\n        var diagnosticText = (msg ? \" message:\" + _sanitizeDiagnosticText(msg) : STR_EMPTY) +\r\n            (properties ? \" props:\" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);\r\n        _self[_DYN_MESSAGE /* @min:%2emessage */] += diagnosticText;\r\n    }\r\n    _InternalLogMessage.dataType = \"MessageData\";\r\n    return _InternalLogMessage;\r\n}());\r\nexport { _InternalLogMessage };\r\nexport function safeGetLogger(core, config) {\r\n    return (core || {})[_DYN_LOGGER /* @min:%2elogger */] || new DiagnosticLogger(config);\r\n}\r\nvar DiagnosticLogger = /** @class */ (function () {\r\n    function DiagnosticLogger(config) {\r\n        this.identifier = \"DiagnosticLogger\";\r\n        /**\r\n         * The internal logging queue\r\n         */\r\n        this.queue = [];\r\n        /**\r\n         * Count of internal messages sent\r\n         */\r\n        var _messageCount = 0;\r\n        /**\r\n         * Holds information about what message types were already logged to console or sent to server.\r\n         */\r\n        var _messageLogged = {};\r\n        var _loggingLevelConsole;\r\n        var _loggingLevelTelemetry;\r\n        var _maxInternalMessageLimit;\r\n        var _enableDebug;\r\n        var _unloadHandler;\r\n        dynamicProto(DiagnosticLogger, this, function (_self) {\r\n            _unloadHandler = _setDefaultsFromConfig(config || {});\r\n            _self.consoleLoggingLevel = function () { return _loggingLevelConsole; };\r\n            /**\r\n             * This method will throw exceptions in debug mode or attempt to log the error as a console warning.\r\n             * @param severity - {LoggingSeverity} - The severity of the log message\r\n             * @param message - {_InternalLogMessage} - The log message.\r\n             */\r\n            _self[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */] = function (severity, msgId, msg, properties, isUserAct) {\r\n                if (isUserAct === void 0) { isUserAct = false; }\r\n                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);\r\n                if (_enableDebug) {\r\n                    throw dumpObj(message);\r\n                }\r\n                else {\r\n                    // Get the logging function and fallback to warnToConsole of for some reason errorToConsole doesn't exist\r\n                    var logFunc = _logFuncs[severity] || STR_WARN_TO_CONSOLE;\r\n                    if (!isUndefined(message[_DYN_MESSAGE /* @min:%2emessage */])) {\r\n                        if (isUserAct) {\r\n                            // check if this message type was already logged to console for this page view and if so, don't log it again\r\n                            var messageKey = +message[_DYN_MESSAGE_ID /* @min:%2emessageId */];\r\n                            if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {\r\n                                _self[logFunc](message[_DYN_MESSAGE /* @min:%2emessage */]);\r\n                                _messageLogged[messageKey] = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            // Only log traces if the console Logging Level is >= the throwInternal severity level\r\n                            if (_loggingLevelConsole >= severity) {\r\n                                _self[logFunc](message[_DYN_MESSAGE /* @min:%2emessage */]);\r\n                            }\r\n                        }\r\n                        _logInternalMessage(severity, message);\r\n                    }\r\n                    else {\r\n                        _debugExtMsg(\"throw\" + (severity === 1 /* eLoggingSeverity.CRITICAL */ ? \"Critical\" : \"Warning\"), message);\r\n                    }\r\n                }\r\n            };\r\n            _self.debugToConsole = function (message) {\r\n                _logToConsole(\"debug\", message);\r\n                _debugExtMsg(\"warning\", message);\r\n            };\r\n            _self[_DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */] = function (message) {\r\n                _logToConsole(\"warn\", message);\r\n                _debugExtMsg(\"warning\", message);\r\n            };\r\n            _self.errorToConsole = function (message) {\r\n                _logToConsole(\"error\", message);\r\n                _debugExtMsg(\"error\", message);\r\n            };\r\n            _self.resetInternalMessageCount = function () {\r\n                _messageCount = 0;\r\n                _messageLogged = {};\r\n            };\r\n            _self[_DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */] = _logInternalMessage;\r\n            _self[_DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {\r\n                _unloadHandler && _unloadHandler.rm();\r\n                _unloadHandler = null;\r\n            };\r\n            function _logInternalMessage(severity, message) {\r\n                if (_areInternalMessagesThrottled()) {\r\n                    return;\r\n                }\r\n                // check if this message type was already logged for this session and if so, don't log it again\r\n                var logMessage = true;\r\n                var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID /* @min:%2emessageId */];\r\n                // if the session storage is not available, limit to only one message type per page view\r\n                if (_messageLogged[messageKey]) {\r\n                    logMessage = false;\r\n                }\r\n                else {\r\n                    _messageLogged[messageKey] = true;\r\n                }\r\n                if (logMessage) {\r\n                    // Push the event in the internal queue\r\n                    if (severity <= _loggingLevelTelemetry) {\r\n                        _self.queue[_DYN_PUSH /* @min:%2epush */](message);\r\n                        _messageCount++;\r\n                        _debugExtMsg((severity === 1 /* eLoggingSeverity.CRITICAL */ ? \"error\" : \"warn\"), message);\r\n                    }\r\n                    // When throttle limit reached, send a special event\r\n                    if (_messageCount === _maxInternalMessageLimit) {\r\n                        var throttleLimitMessage = \"Internal events throttle limit per PageView reached for this app.\";\r\n                        var throttleMessage = new _InternalLogMessage(23 /* _eInternalMessageId.MessageLimitPerPVExceeded */, throttleLimitMessage, false);\r\n                        _self.queue[_DYN_PUSH /* @min:%2epush */](throttleMessage);\r\n                        if (severity === 1 /* eLoggingSeverity.CRITICAL */) {\r\n                            _self.errorToConsole(throttleLimitMessage);\r\n                        }\r\n                        else {\r\n                            _self[_DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](throttleLimitMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            function _setDefaultsFromConfig(config) {\r\n                // make sure the config is dynamic\r\n                return onConfigChange(createDynamicConfig(config, defaultValues, _self).cfg, function (details) {\r\n                    var config = details.cfg;\r\n                    _loggingLevelConsole = config[_DYN_LOGGING_LEVEL_CONSOL4 /* @min:%2eloggingLevelConsole */];\r\n                    _loggingLevelTelemetry = config.loggingLevelTelemetry;\r\n                    _maxInternalMessageLimit = config.maxMessageLimit;\r\n                    _enableDebug = config.enableDebug;\r\n                });\r\n            }\r\n            function _areInternalMessagesThrottled() {\r\n                return _messageCount >= _maxInternalMessageLimit;\r\n            }\r\n            function _debugExtMsg(name, data) {\r\n                var dbgExt = getDebugExt(config || {});\r\n                if (dbgExt && dbgExt[_DYN_DIAG_LOG /* @min:%2ediagLog */]) {\r\n                    dbgExt[_DYN_DIAG_LOG /* @min:%2ediagLog */](name, data);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * 0: OFF (default)\r\n     * 1: CRITICAL\r\n     * 2: >= WARNING\r\n     */\r\n    DiagnosticLogger.prototype.consoleLoggingLevel = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 0;\r\n    };\r\n    /**\r\n     * This method will throw exceptions in debug mode or attempt to log the error as a console warning.\r\n     * @param severity - {LoggingSeverity} - The severity of the log message\r\n     * @param message - {_InternalLogMessage} - The log message.\r\n     */\r\n    DiagnosticLogger.prototype.throwInternal = function (severity, msgId, msg, properties, isUserAct) {\r\n        if (isUserAct === void 0) { isUserAct = false; }\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * This will write a debug message to the console if possible\r\n     * @param message - {string} - The debug message\r\n     */\r\n    DiagnosticLogger.prototype.debugToConsole = function (message) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * This will write a warning to the console if possible\r\n     * @param message - {string} - The warning message\r\n     */\r\n    DiagnosticLogger.prototype.warnToConsole = function (message) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * This will write an error to the console if possible\r\n     * @param message - {string} - The warning message\r\n     */\r\n    DiagnosticLogger.prototype.errorToConsole = function (message) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Resets the internal message count\r\n     */\r\n    DiagnosticLogger.prototype.resetInternalMessageCount = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Logs a message to the internal queue.\r\n     * @param severity - {LoggingSeverity} - The severity of the log message\r\n     * @param message - {_InternalLogMessage} - The message to log.\r\n     */\r\n    DiagnosticLogger.prototype.logInternalMessage = function (severity, message) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Unload and remove any state that this IDiagnosticLogger may be holding, this is generally called when the\r\n     * owning SDK is being unloaded.\r\n     * @param isAsync - Can the unload be performed asynchronously (default)\r\n     * @return If the unload occurs synchronously then nothing should be returned, if happening asynchronously then\r\n     * the function should return an [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * / Promise to allow any listeners to wait for the operation to complete.\r\n     */\r\n    DiagnosticLogger.prototype.unload = function (isAsync) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return DiagnosticLogger;\r\n}());\r\nexport { DiagnosticLogger };\r\nfunction _getLogger(logger) {\r\n    return (logger || new DiagnosticLogger());\r\n}\r\n/**\r\n * This is a helper method which will call throwInternal on the passed logger, will throw exceptions in\r\n * debug mode or attempt to log the error as a console warning. This helper is provided mostly to better\r\n * support minification as logger.throwInternal() will not compress the publish \"throwInternal\" used throughout\r\n * the code.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param severity - {LoggingSeverity} - The severity of the log message\r\n * @param message - {_InternalLogMessage} - The log message.\r\n */\r\nexport function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {\r\n    if (isUserAct === void 0) { isUserAct = false; }\r\n    _getLogger(logger)[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](severity, msgId, msg, properties, isUserAct);\r\n}\r\n/**\r\n * This is a helper method which will call warnToConsole on the passed logger with the provided message.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param message - {_InternalLogMessage} - The log message.\r\n */\r\nexport function _warnToConsole(logger, message) {\r\n    _getLogger(logger)[_DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);\r\n}\r\n/**\r\n * Logs a message to the internal queue.\r\n * @param logger - The Diagnostic Logger instance to use.\r\n * @param severity - {LoggingSeverity} - The severity of the log message\r\n * @param message - {_InternalLogMessage} - The message to log.\r\n */\r\nexport function _logInternalMessage(logger, severity, message) {\r\n    _getLogger(logger)[_DYN_LOG_INTERNAL_MESSAGE /* @min:%2elogInternalMessage */](severity, message);\r\n}\r\n//# sourceMappingURL=DiagnosticLogger.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}