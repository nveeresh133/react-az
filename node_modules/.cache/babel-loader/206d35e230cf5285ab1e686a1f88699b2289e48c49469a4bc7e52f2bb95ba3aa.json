{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Properties Plugin, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { utlCanUseLocalStorage, utlGetLocalStorage, utlSetLocalStorage } from \"@microsoft/applicationinsights-common\";\nimport { _throwInternal, dateNow, dumpObj, getExceptionName, isFunction, newId, onConfigChange, safeGetCookieMgr, safeGetLogger } from \"@microsoft/applicationinsights-core-js\";\nimport { _DYN_ACQUISITION_DATE, _DYN_AUTOMATIC_SESSION, _DYN_GET_NEW_ID, _DYN_ID_LENGTH, _DYN_JOIN, _DYN_LENGTH, _DYN_NAME_PREFIX, _DYN_RENEWAL_DATE, _DYN_UPDATE } from \"../__DynamicConstants\";\nvar SESSION_COOKIE_NAME = \"ai_session\";\nvar ACQUISITION_SPAN = 86400000; // 24 hours in ms\nvar RENEWAL_SPAN = 1800000; // 30 minutes in ms\nvar COOKIE_UPDATE_INTERVAL = 60000; // 1 minute in ms\nvar Session = /** @class */function () {\n  function Session() {}\n  return Session;\n}();\nexport { Session };\nvar _SessionManager = /** @class */function () {\n  function _SessionManager(config, core, unloadHookContainer) {\n    var self = this;\n    var _storageNamePrefix;\n    var _cookieUpdatedTimestamp;\n    var _logger = safeGetLogger(core);\n    var _cookieManager = safeGetCookieMgr(core);\n    var _sessionExpirationMs;\n    var _sessionRenewalMs;\n    dynamicProto(_SessionManager, self, function (_self) {\n      if (!config) {\n        config = {};\n      }\n      var unloadHook = onConfigChange(config, function (details) {\n        _sessionExpirationMs = config.sessionExpirationMs || ACQUISITION_SPAN;\n        _sessionRenewalMs = config.sessionRenewalMs || RENEWAL_SPAN;\n        // sessionCookiePostfix takes the preference if it is configured, otherwise takes namePrefix if configured.\n        var sessionCookiePostfix = config.sessionCookiePostfix || config[_DYN_NAME_PREFIX /* @min:%2enamePrefix */] || \"\";\n        _storageNamePrefix = SESSION_COOKIE_NAME + sessionCookiePostfix;\n      });\n      unloadHookContainer && unloadHookContainer.add(unloadHook);\n      _self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */] = new Session();\n      _self[_DYN_UPDATE /* @min:%2eupdate */] = function () {\n        // Always using Date getTime() as there is a bug in older IE instances that causes the performance timings to have the hi-bit set eg 0x800000000 causing\n        // the number to be incorrect.\n        var nowMs = dateNow();\n        var isExpired = false;\n        var session = _self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */];\n        if (!session.id) {\n          isExpired = !_initializeAutomaticSession(session, nowMs);\n        }\n        if (!isExpired && _sessionExpirationMs > 0) {\n          var timeSinceAcqMs = nowMs - session[_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */];\n          var timeSinceRenewalMs = nowMs - session[_DYN_RENEWAL_DATE /* @min:%2erenewalDate */];\n          isExpired = timeSinceAcqMs < 0 || timeSinceRenewalMs < 0; // expired if the acquisition or last renewal are in the future\n          isExpired = isExpired || timeSinceAcqMs > _sessionExpirationMs; // expired if the time since acquisition is more than session Expiration\n          isExpired = isExpired || timeSinceRenewalMs > _sessionRenewalMs; // expired if the time since last renewal is more than renewal period\n        }\n        // renew if acquisitionSpan or renewalSpan has elapsed\n        if (isExpired) {\n          // update automaticSession so session state has correct id\n          _renew(nowMs);\n        } else {\n          // do not update the cookie more often than cookieUpdateInterval\n          if (!_cookieUpdatedTimestamp || nowMs - _cookieUpdatedTimestamp > COOKIE_UPDATE_INTERVAL) {\n            _setCookie(session, nowMs);\n          }\n        }\n      };\n      /**\r\n       *  Record the current state of the automatic session and store it in our cookie string format\r\n       *  into the browser's local storage. This is used to restore the session data when the cookie\r\n       *  expires.\r\n       */\n      _self.backup = function () {\n        var session = _self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */];\n        _setStorage(session.id, session[_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */], session[_DYN_RENEWAL_DATE /* @min:%2erenewalDate */]);\n      };\n      /**\r\n       * Use config.namePrefix + ai_session cookie data or local storage data (when the cookie is unavailable) to\r\n       * initialize the automatic session.\r\n       * @returns true if values set otherwise false\r\n       */\n      function _initializeAutomaticSession(session, now) {\n        var isValid = false;\n        var cookieValue = _cookieManager.get(_storageNamePrefix);\n        if (cookieValue && isFunction(cookieValue.split)) {\n          isValid = _initializeAutomaticSessionWithData(session, cookieValue);\n        } else {\n          // There's no cookie, but we might have session data in local storage\n          // This can happen if the session expired or the user actively deleted the cookie\n          // We only want to recover data if the cookie is missing from expiry. We should respect the user's wishes if the cookie was deleted actively.\n          // The User class handles this for us and deletes our local storage object if the persistent user cookie was removed.\n          var storageValue = utlGetLocalStorage(_logger, _storageNamePrefix);\n          if (storageValue) {\n            isValid = _initializeAutomaticSessionWithData(session, storageValue);\n          }\n        }\n        return isValid || !!session.id;\n      }\n      /**\r\n       * Extract id, acquisitionDate, and renewalDate from an ai_session payload string and\r\n       * use this data to initialize automaticSession.\r\n       *\r\n       * @param sessionData - The string stored in an ai_session cookie or local storage backup\r\n       * @returns true if values set otherwise false\r\n       */\n      function _initializeAutomaticSessionWithData(session, sessionData) {\n        var isValid = false;\n        var sessionReset = \", session will be reset\";\n        var tokens = sessionData.split(\"|\");\n        if (tokens[_DYN_LENGTH /* @min:%2elength */] >= 2) {\n          try {\n            var acqMs = +tokens[1] || 0;\n            var renewalMs = +tokens[2] || 0;\n            if (isNaN(acqMs) || acqMs <= 0) {\n              _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 27 /* _eInternalMessageId.SessionRenewalDateIsZero */, \"AI session acquisition date is 0\" + sessionReset);\n            } else if (isNaN(renewalMs) || renewalMs <= 0) {\n              _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 27 /* _eInternalMessageId.SessionRenewalDateIsZero */, \"AI session renewal date is 0\" + sessionReset);\n            } else if (tokens[0]) {\n              // Everything looks valid so set the values\n              session.id = tokens[0];\n              session[_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */] = acqMs;\n              session[_DYN_RENEWAL_DATE /* @min:%2erenewalDate */] = renewalMs;\n              isValid = true;\n            }\n          } catch (e) {\n            _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 9 /* _eInternalMessageId.ErrorParsingAISessionCookie */, \"Error parsing ai_session value [\" + (sessionData || \"\") + \"]\" + sessionReset + \" - \" + getExceptionName(e), {\n              exception: dumpObj(e)\n            });\n          }\n        }\n        return isValid;\n      }\n      function _renew(nowMs) {\n        var getNewId = config[_DYN_GET_NEW_ID /* @min:%2egetNewId */] || newId;\n        _self.automaticSession.id = getNewId(config[_DYN_ID_LENGTH /* @min:%2eidLength */] || 22);\n        _self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */][_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */] = nowMs;\n        _setCookie(_self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */], nowMs);\n        // If this browser does not support local storage, fire an internal log to keep track of it at this point\n        if (!utlCanUseLocalStorage()) {\n          _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 0 /* _eInternalMessageId.BrowserDoesNotSupportLocalStorage */, \"Browser does not support local storage. Session durations will be inaccurate.\");\n        }\n      }\n      function _setCookie(session, nowMs) {\n        var acq = session[_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */];\n        session[_DYN_RENEWAL_DATE /* @min:%2erenewalDate */] = nowMs;\n        var renewalPeriodMs = _sessionRenewalMs;\n        // Set cookie to expire after the session expiry time passes or the session renewal deadline, whichever is sooner\n        // Expiring the cookie will cause the session to expire even if the user isn't on the page\n        var acqTimeLeftMs = acq + _sessionExpirationMs - nowMs;\n        var cookie = [session.id, acq, nowMs];\n        var maxAgeSec = 0;\n        if (acqTimeLeftMs < renewalPeriodMs) {\n          maxAgeSec = acqTimeLeftMs / 1000;\n        } else {\n          maxAgeSec = renewalPeriodMs / 1000;\n        }\n        var cookieDomain = config.cookieDomain || null;\n        // if sessionExpirationMs is set to 0, it means the expiry is set to 0 for this session cookie\n        // A cookie with 0 expiry in the session cookie will never expire for that browser session.  If the browser is closed the cookie expires.\n        // Depending on the browser, another instance does not inherit this cookie, however, another tab will\n        _cookieManager.set(_storageNamePrefix, cookie[_DYN_JOIN /* @min:%2ejoin */](\"|\"), _sessionExpirationMs > 0 ? maxAgeSec : null, cookieDomain);\n        _cookieUpdatedTimestamp = nowMs;\n      }\n      function _setStorage(guid, acq, renewal) {\n        // Keep data in local storage to retain the last session id, allowing us to cleanly end the session when it expires\n        // Browsers that don't support local storage won't be able to end sessions cleanly from the client\n        // The server will notice this and end the sessions itself, with loss of accurate session duration\n        utlSetLocalStorage(_logger, _storageNamePrefix, [guid, acq, renewal][_DYN_JOIN /* @min:%2ejoin */](\"|\"));\n      }\n    });\n  }\n  // Removed Stub for _SessionManager.prototype.update.\n  // Removed Stub for _SessionManager.prototype.backup.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  _SessionManager.__ieDyn = 1;\n  return _SessionManager;\n}();\nexport { _SessionManager };","map":{"version":3,"names":["dynamicProto","utlCanUseLocalStorage","utlGetLocalStorage","utlSetLocalStorage","_throwInternal","dateNow","dumpObj","getExceptionName","isFunction","newId","onConfigChange","safeGetCookieMgr","safeGetLogger","_DYN_ACQUISITION_DATE","_DYN_AUTOMATIC_SESSION","_DYN_GET_NEW_ID","_DYN_ID_LENGTH","_DYN_JOIN","_DYN_LENGTH","_DYN_NAME_PREFIX","_DYN_RENEWAL_DATE","_DYN_UPDATE","SESSION_COOKIE_NAME","ACQUISITION_SPAN","RENEWAL_SPAN","COOKIE_UPDATE_INTERVAL","Session","_SessionManager","config","core","unloadHookContainer","self","_storageNamePrefix","_cookieUpdatedTimestamp","_logger","_cookieManager","_sessionExpirationMs","_sessionRenewalMs","_self","unloadHook","details","sessionExpirationMs","sessionRenewalMs","sessionCookiePostfix","add","nowMs","isExpired","session","id","_initializeAutomaticSession","timeSinceAcqMs","timeSinceRenewalMs","_renew","_setCookie","backup","_setStorage","now","isValid","cookieValue","get","split","_initializeAutomaticSessionWithData","storageValue","sessionData","sessionReset","tokens","acqMs","renewalMs","isNaN","e","exception","getNewId","automaticSession","acq","renewalPeriodMs","acqTimeLeftMs","cookie","maxAgeSec","cookieDomain","set","guid","renewal"],"sources":["/home/veeresh133/app/react-az/node_modules/@microsoft/applicationinsights-properties-js/dist-es5/Context/Session.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { utlCanUseLocalStorage, utlGetLocalStorage, utlSetLocalStorage } from \"@microsoft/applicationinsights-common\";\r\nimport { _throwInternal, dateNow, dumpObj, getExceptionName, isFunction, newId, onConfigChange, safeGetCookieMgr, safeGetLogger } from \"@microsoft/applicationinsights-core-js\";\r\nimport { _DYN_ACQUISITION_DATE, _DYN_AUTOMATIC_SESSION, _DYN_GET_NEW_ID, _DYN_ID_LENGTH, _DYN_JOIN, _DYN_LENGTH, _DYN_NAME_PREFIX, _DYN_RENEWAL_DATE, _DYN_UPDATE } from \"../__DynamicConstants\";\r\nvar SESSION_COOKIE_NAME = \"ai_session\";\r\nvar ACQUISITION_SPAN = 86400000; // 24 hours in ms\r\nvar RENEWAL_SPAN = 1800000; // 30 minutes in ms\r\nvar COOKIE_UPDATE_INTERVAL = 60000; // 1 minute in ms\r\nvar Session = /** @class */ (function () {\r\n    function Session() {\r\n    }\r\n    return Session;\r\n}());\r\nexport { Session };\r\nvar _SessionManager = /** @class */ (function () {\r\n    function _SessionManager(config, core, unloadHookContainer) {\r\n        var self = this;\r\n        var _storageNamePrefix;\r\n        var _cookieUpdatedTimestamp;\r\n        var _logger = safeGetLogger(core);\r\n        var _cookieManager = safeGetCookieMgr(core);\r\n        var _sessionExpirationMs;\r\n        var _sessionRenewalMs;\r\n        dynamicProto(_SessionManager, self, function (_self) {\r\n            if (!config) {\r\n                config = {};\r\n            }\r\n            var unloadHook = onConfigChange(config, function (details) {\r\n                _sessionExpirationMs = config.sessionExpirationMs || ACQUISITION_SPAN;\r\n                _sessionRenewalMs = config.sessionRenewalMs || RENEWAL_SPAN;\r\n                // sessionCookiePostfix takes the preference if it is configured, otherwise takes namePrefix if configured.\r\n                var sessionCookiePostfix = config.sessionCookiePostfix || config[_DYN_NAME_PREFIX /* @min:%2enamePrefix */] || \"\";\r\n                _storageNamePrefix = SESSION_COOKIE_NAME + sessionCookiePostfix;\r\n            });\r\n            unloadHookContainer && unloadHookContainer.add(unloadHook);\r\n            _self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */] = new Session();\r\n            _self[_DYN_UPDATE /* @min:%2eupdate */] = function () {\r\n                // Always using Date getTime() as there is a bug in older IE instances that causes the performance timings to have the hi-bit set eg 0x800000000 causing\r\n                // the number to be incorrect.\r\n                var nowMs = dateNow();\r\n                var isExpired = false;\r\n                var session = _self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */];\r\n                if (!session.id) {\r\n                    isExpired = !_initializeAutomaticSession(session, nowMs);\r\n                }\r\n                if (!isExpired && _sessionExpirationMs > 0) {\r\n                    var timeSinceAcqMs = nowMs - session[_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */];\r\n                    var timeSinceRenewalMs = nowMs - session[_DYN_RENEWAL_DATE /* @min:%2erenewalDate */];\r\n                    isExpired = timeSinceAcqMs < 0 || timeSinceRenewalMs < 0; // expired if the acquisition or last renewal are in the future\r\n                    isExpired = isExpired || timeSinceAcqMs > _sessionExpirationMs; // expired if the time since acquisition is more than session Expiration\r\n                    isExpired = isExpired || timeSinceRenewalMs > _sessionRenewalMs; // expired if the time since last renewal is more than renewal period\r\n                }\r\n                // renew if acquisitionSpan or renewalSpan has elapsed\r\n                if (isExpired) {\r\n                    // update automaticSession so session state has correct id\r\n                    _renew(nowMs);\r\n                }\r\n                else {\r\n                    // do not update the cookie more often than cookieUpdateInterval\r\n                    if (!_cookieUpdatedTimestamp || nowMs - _cookieUpdatedTimestamp > COOKIE_UPDATE_INTERVAL) {\r\n                        _setCookie(session, nowMs);\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             *  Record the current state of the automatic session and store it in our cookie string format\r\n             *  into the browser's local storage. This is used to restore the session data when the cookie\r\n             *  expires.\r\n             */\r\n            _self.backup = function () {\r\n                var session = _self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */];\r\n                _setStorage(session.id, session[_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */], session[_DYN_RENEWAL_DATE /* @min:%2erenewalDate */]);\r\n            };\r\n            /**\r\n             * Use config.namePrefix + ai_session cookie data or local storage data (when the cookie is unavailable) to\r\n             * initialize the automatic session.\r\n             * @returns true if values set otherwise false\r\n             */\r\n            function _initializeAutomaticSession(session, now) {\r\n                var isValid = false;\r\n                var cookieValue = _cookieManager.get(_storageNamePrefix);\r\n                if (cookieValue && isFunction(cookieValue.split)) {\r\n                    isValid = _initializeAutomaticSessionWithData(session, cookieValue);\r\n                }\r\n                else {\r\n                    // There's no cookie, but we might have session data in local storage\r\n                    // This can happen if the session expired or the user actively deleted the cookie\r\n                    // We only want to recover data if the cookie is missing from expiry. We should respect the user's wishes if the cookie was deleted actively.\r\n                    // The User class handles this for us and deletes our local storage object if the persistent user cookie was removed.\r\n                    var storageValue = utlGetLocalStorage(_logger, _storageNamePrefix);\r\n                    if (storageValue) {\r\n                        isValid = _initializeAutomaticSessionWithData(session, storageValue);\r\n                    }\r\n                }\r\n                return isValid || !!session.id;\r\n            }\r\n            /**\r\n             * Extract id, acquisitionDate, and renewalDate from an ai_session payload string and\r\n             * use this data to initialize automaticSession.\r\n             *\r\n             * @param sessionData - The string stored in an ai_session cookie or local storage backup\r\n             * @returns true if values set otherwise false\r\n             */\r\n            function _initializeAutomaticSessionWithData(session, sessionData) {\r\n                var isValid = false;\r\n                var sessionReset = \", session will be reset\";\r\n                var tokens = sessionData.split(\"|\");\r\n                if (tokens[_DYN_LENGTH /* @min:%2elength */] >= 2) {\r\n                    try {\r\n                        var acqMs = +tokens[1] || 0;\r\n                        var renewalMs = +tokens[2] || 0;\r\n                        if (isNaN(acqMs) || acqMs <= 0) {\r\n                            _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 27 /* _eInternalMessageId.SessionRenewalDateIsZero */, \"AI session acquisition date is 0\" + sessionReset);\r\n                        }\r\n                        else if (isNaN(renewalMs) || renewalMs <= 0) {\r\n                            _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 27 /* _eInternalMessageId.SessionRenewalDateIsZero */, \"AI session renewal date is 0\" + sessionReset);\r\n                        }\r\n                        else if (tokens[0]) {\r\n                            // Everything looks valid so set the values\r\n                            session.id = tokens[0];\r\n                            session[_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */] = acqMs;\r\n                            session[_DYN_RENEWAL_DATE /* @min:%2erenewalDate */] = renewalMs;\r\n                            isValid = true;\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 9 /* _eInternalMessageId.ErrorParsingAISessionCookie */, \"Error parsing ai_session value [\" + (sessionData || \"\") + \"]\" + sessionReset + \" - \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                    }\r\n                }\r\n                return isValid;\r\n            }\r\n            function _renew(nowMs) {\r\n                var getNewId = config[_DYN_GET_NEW_ID /* @min:%2egetNewId */] || newId;\r\n                _self.automaticSession.id = getNewId(config[_DYN_ID_LENGTH /* @min:%2eidLength */] || 22);\r\n                _self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */][_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */] = nowMs;\r\n                _setCookie(_self[_DYN_AUTOMATIC_SESSION /* @min:%2eautomaticSession */], nowMs);\r\n                // If this browser does not support local storage, fire an internal log to keep track of it at this point\r\n                if (!utlCanUseLocalStorage()) {\r\n                    _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 0 /* _eInternalMessageId.BrowserDoesNotSupportLocalStorage */, \"Browser does not support local storage. Session durations will be inaccurate.\");\r\n                }\r\n            }\r\n            function _setCookie(session, nowMs) {\r\n                var acq = session[_DYN_ACQUISITION_DATE /* @min:%2eacquisitionDate */];\r\n                session[_DYN_RENEWAL_DATE /* @min:%2erenewalDate */] = nowMs;\r\n                var renewalPeriodMs = _sessionRenewalMs;\r\n                // Set cookie to expire after the session expiry time passes or the session renewal deadline, whichever is sooner\r\n                // Expiring the cookie will cause the session to expire even if the user isn't on the page\r\n                var acqTimeLeftMs = (acq + _sessionExpirationMs) - nowMs;\r\n                var cookie = [session.id, acq, nowMs];\r\n                var maxAgeSec = 0;\r\n                if (acqTimeLeftMs < renewalPeriodMs) {\r\n                    maxAgeSec = acqTimeLeftMs / 1000;\r\n                }\r\n                else {\r\n                    maxAgeSec = renewalPeriodMs / 1000;\r\n                }\r\n                var cookieDomain = config.cookieDomain || null;\r\n                // if sessionExpirationMs is set to 0, it means the expiry is set to 0 for this session cookie\r\n                // A cookie with 0 expiry in the session cookie will never expire for that browser session.  If the browser is closed the cookie expires.\r\n                // Depending on the browser, another instance does not inherit this cookie, however, another tab will\r\n                _cookieManager.set(_storageNamePrefix, cookie[_DYN_JOIN /* @min:%2ejoin */](\"|\"), _sessionExpirationMs > 0 ? maxAgeSec : null, cookieDomain);\r\n                _cookieUpdatedTimestamp = nowMs;\r\n            }\r\n            function _setStorage(guid, acq, renewal) {\r\n                // Keep data in local storage to retain the last session id, allowing us to cleanly end the session when it expires\r\n                // Browsers that don't support local storage won't be able to end sessions cleanly from the client\r\n                // The server will notice this and end the sessions itself, with loss of accurate session duration\r\n                utlSetLocalStorage(_logger, _storageNamePrefix, [guid, acq, renewal][_DYN_JOIN /* @min:%2ejoin */](\"|\"));\r\n            }\r\n        });\r\n    }\r\n    _SessionManager.prototype.update = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     *  Record the current state of the automatic session and store it in our cookie string format\r\n     *  into the browser's local storage. This is used to restore the session data when the cookie\r\n     *  expires.\r\n     */\r\n    _SessionManager.prototype.backup = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return _SessionManager;\r\n}());\r\nexport { _SessionManager };\r\n//# sourceMappingURL=Session.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}