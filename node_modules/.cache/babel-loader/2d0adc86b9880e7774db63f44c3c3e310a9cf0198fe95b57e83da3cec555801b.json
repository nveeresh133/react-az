{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport { isArray, isPlainObject, objForEachKey, symbolFor, throwTypeError } from \"@nevware21/ts-utils\";\nimport { _DYN_LENGTH } from \"../__DynamicConstants\";\n// Using Symbol.for so that if the same symbol was already created it would be returned\n// To handle multiple instances using potentially different versions we are not using\n// createUniqueNamespace()\nexport var CFG_HANDLER_LINK = symbolFor(\"[[ai_dynCfg_1]]\");\n/**\r\n * @internal\r\n * @ignore\r\n * The symbol to tag objects / arrays with if they should not be converted\r\n */\nvar BLOCK_DYNAMIC = symbolFor(\"[[ai_blkDynCfg_1]]\");\n/**\r\n * @internal\r\n * @ignore\r\n * The symbol to tag objects to indicate that when included into the configuration that\r\n * they should be converted into a trackable dynamic object.\r\n */\nvar FORCE_DYNAMIC = symbolFor(\"[[ai_frcDynCfg_1]]\");\nexport function _cfgDeepCopy(source) {\n  if (source) {\n    var target_1;\n    if (isArray(source)) {\n      target_1 = [];\n      target_1[_DYN_LENGTH /* @min:%2elength */] = source[_DYN_LENGTH /* @min:%2elength */];\n    } else if (isPlainObject(source)) {\n      target_1 = {};\n    }\n    if (target_1) {\n      // Copying index values by property name as the extensionConfig can be an array or object\n      objForEachKey(source, function (key, value) {\n        // Perform a deep copy of the object\n        target_1[key] = _cfgDeepCopy(value);\n      });\n      return target_1;\n    }\n  }\n  return source;\n}\n/**\r\n * @internal\r\n * Get the dynamic config handler if the value is already dynamic\r\n * @param value\r\n * @returns\r\n */\nexport function getDynamicConfigHandler(value) {\n  if (value) {\n    var handler = value[CFG_HANDLER_LINK] || value;\n    if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {\n      return handler;\n    }\n  }\n  return null;\n}\n/**\r\n * Mark the provided value so that if it's included into the configuration it will NOT have\r\n * its properties converted into a dynamic (reactive) object. If the object is not a plain object\r\n * or an array (ie. a class) this function has not affect as only Objects and Arrays are converted\r\n * into dynamic objects in the dynamic configuration.\r\n *\r\n * When you have tagged a value as both {@link forceDynamicConversion} and blocked force will take precedence.\r\n *\r\n * You should only need to use this function, if you are creating dynamic \"classes\" from objects\r\n * which confirm to the require interface. A common case for this is during unit testing where it's\r\n * easier to create mock extensions.\r\n *\r\n * If `value` is falsy (null / undefined / 0 / empty string etc) it will not be tagged and\r\n * if there is an exception adding the property to the value (because its frozen etc) the\r\n * exception will be swallowed\r\n *\r\n * @example\r\n * ```ts\r\n * // This is a valid \"extension\", but it is technically an object\r\n * // So when included in the config.extensions it WILL be cloned and then\r\n * // converted into a dynamic object, where all of its properties will become\r\n * // get/set object properties and will be tracked. While this WILL still\r\n * // function, when attempt to use a mocking framework on top of this the\r\n * // functions are now technically get accessors which return a function\r\n * // and this can cause some mocking frameworks to fail.\r\n * let mockChannel = {\r\n *      pause: () => { },\r\n*      resume: () => { },\r\n*      teardown: () => { },\r\n*      flush: (async: any, callBack: any) => { },\r\n*      processTelemetry: (env: any) => { },\r\n*      setNextPlugin: (next: any) => { },\r\n*      initialize: (config: any, core: any, extensions: any) => { },\r\n*      identifier: \"testChannel\",\r\n*      priority: 1003\r\n* };\r\n * ```\r\n * @param value - The object that you want to block from being converted into a\r\n * trackable dynamic object\r\n * @returns The original value\r\n */\nexport function blockDynamicConversion(value) {\n  if (value && (isPlainObject(value) || isArray(value))) {\n    try {\n      value[BLOCK_DYNAMIC] = true;\n    } catch (e) {\n      // Don't throw for this case as it's an ask only\n    }\n  }\n  return value;\n}\n/**\r\n * This is the reverse case of {@link blockDynamicConversion} in that this will tag an\r\n * object to indicate that it should always be converted into a dynamic trackable object\r\n * even when not an object or array. So all properties of this object will become\r\n * get / set accessor functions.\r\n *\r\n * When you have tagged a value as both {@link forceDynamicConversion} and blocked force will take precedence.\r\n *\r\n * If `value` is falsy (null / undefined / 0 / empty string etc) it will not be tagged and\r\n * if there is an exception adding the property to the value (because its frozen etc) the\r\n * exception will be swallowed.\r\n * @param value - The object that should be tagged and converted if included into a dynamic\r\n * configuration.\r\n * @returns The original value\r\n */\nexport function forceDynamicConversion(value) {\n  if (value) {\n    try {\n      value[FORCE_DYNAMIC] = true;\n    } catch (e) {\n      // Don't throw for this case as it's an ask only\n    }\n  }\n  return value;\n}\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function to check whether an object can or should be converted into a dynamic\r\n * object.\r\n * @param value - The object to check whether it should be converted\r\n * @returns `true` if the value should be converted otherwise `false`.\r\n */\nexport function _canMakeDynamic(getFunc, state, value) {\n  var result = false;\n  // Object must exist and be truthy\n  if (value && !getFunc[state.blkVal]) {\n    // Tagged as always convert\n    result = value[FORCE_DYNAMIC];\n    // Check that it's not explicitly tagged as blocked\n    if (!result && !value[BLOCK_DYNAMIC]) {\n      // Only convert plain objects or arrays by default\n      result = isPlainObject(value) || isArray(value);\n    }\n  }\n  return result;\n}\n/**\r\n * Throws an invalid access exception\r\n * @param message - The message to include in the exception\r\n */\nexport function throwInvalidAccess(message) {\n  throwTypeError(\"InvalidAccess:\" + message);\n}","map":{"version":3,"names":["isArray","isPlainObject","objForEachKey","symbolFor","throwTypeError","_DYN_LENGTH","CFG_HANDLER_LINK","BLOCK_DYNAMIC","FORCE_DYNAMIC","_cfgDeepCopy","source","target_1","key","value","getDynamicConfigHandler","handler","cfg","blockDynamicConversion","e","forceDynamicConversion","_canMakeDynamic","getFunc","state","result","blkVal","throwInvalidAccess","message"],"sources":["/home/veeresh133/app/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/Config/DynamicSupport.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { isArray, isPlainObject, objForEachKey, symbolFor, throwTypeError } from \"@nevware21/ts-utils\";\r\nimport { _DYN_LENGTH } from \"../__DynamicConstants\";\r\n// Using Symbol.for so that if the same symbol was already created it would be returned\r\n// To handle multiple instances using potentially different versions we are not using\r\n// createUniqueNamespace()\r\nexport var CFG_HANDLER_LINK = symbolFor(\"[[ai_dynCfg_1]]\");\r\n/**\r\n * @internal\r\n * @ignore\r\n * The symbol to tag objects / arrays with if they should not be converted\r\n */\r\nvar BLOCK_DYNAMIC = symbolFor(\"[[ai_blkDynCfg_1]]\");\r\n/**\r\n * @internal\r\n * @ignore\r\n * The symbol to tag objects to indicate that when included into the configuration that\r\n * they should be converted into a trackable dynamic object.\r\n */\r\nvar FORCE_DYNAMIC = symbolFor(\"[[ai_frcDynCfg_1]]\");\r\nexport function _cfgDeepCopy(source) {\r\n    if (source) {\r\n        var target_1;\r\n        if (isArray(source)) {\r\n            target_1 = [];\r\n            target_1[_DYN_LENGTH /* @min:%2elength */] = source[_DYN_LENGTH /* @min:%2elength */];\r\n        }\r\n        else if (isPlainObject(source)) {\r\n            target_1 = {};\r\n        }\r\n        if (target_1) {\r\n            // Copying index values by property name as the extensionConfig can be an array or object\r\n            objForEachKey(source, function (key, value) {\r\n                // Perform a deep copy of the object\r\n                target_1[key] = _cfgDeepCopy(value);\r\n            });\r\n            return target_1;\r\n        }\r\n    }\r\n    return source;\r\n}\r\n/**\r\n * @internal\r\n * Get the dynamic config handler if the value is already dynamic\r\n * @param value\r\n * @returns\r\n */\r\nexport function getDynamicConfigHandler(value) {\r\n    if (value) {\r\n        var handler = value[CFG_HANDLER_LINK] || value;\r\n        if (handler.cfg && (handler.cfg === value || handler.cfg[CFG_HANDLER_LINK] === handler)) {\r\n            return handler;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Mark the provided value so that if it's included into the configuration it will NOT have\r\n * its properties converted into a dynamic (reactive) object. If the object is not a plain object\r\n * or an array (ie. a class) this function has not affect as only Objects and Arrays are converted\r\n * into dynamic objects in the dynamic configuration.\r\n *\r\n * When you have tagged a value as both {@link forceDynamicConversion} and blocked force will take precedence.\r\n *\r\n * You should only need to use this function, if you are creating dynamic \"classes\" from objects\r\n * which confirm to the require interface. A common case for this is during unit testing where it's\r\n * easier to create mock extensions.\r\n *\r\n * If `value` is falsy (null / undefined / 0 / empty string etc) it will not be tagged and\r\n * if there is an exception adding the property to the value (because its frozen etc) the\r\n * exception will be swallowed\r\n *\r\n * @example\r\n * ```ts\r\n * // This is a valid \"extension\", but it is technically an object\r\n * // So when included in the config.extensions it WILL be cloned and then\r\n * // converted into a dynamic object, where all of its properties will become\r\n * // get/set object properties and will be tracked. While this WILL still\r\n * // function, when attempt to use a mocking framework on top of this the\r\n * // functions are now technically get accessors which return a function\r\n * // and this can cause some mocking frameworks to fail.\r\n * let mockChannel = {\r\n *      pause: () => { },\r\n*      resume: () => { },\r\n*      teardown: () => { },\r\n*      flush: (async: any, callBack: any) => { },\r\n*      processTelemetry: (env: any) => { },\r\n*      setNextPlugin: (next: any) => { },\r\n*      initialize: (config: any, core: any, extensions: any) => { },\r\n*      identifier: \"testChannel\",\r\n*      priority: 1003\r\n* };\r\n * ```\r\n * @param value - The object that you want to block from being converted into a\r\n * trackable dynamic object\r\n * @returns The original value\r\n */\r\nexport function blockDynamicConversion(value) {\r\n    if (value && (isPlainObject(value) || isArray(value))) {\r\n        try {\r\n            value[BLOCK_DYNAMIC] = true;\r\n        }\r\n        catch (e) {\r\n            // Don't throw for this case as it's an ask only\r\n        }\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * This is the reverse case of {@link blockDynamicConversion} in that this will tag an\r\n * object to indicate that it should always be converted into a dynamic trackable object\r\n * even when not an object or array. So all properties of this object will become\r\n * get / set accessor functions.\r\n *\r\n * When you have tagged a value as both {@link forceDynamicConversion} and blocked force will take precedence.\r\n *\r\n * If `value` is falsy (null / undefined / 0 / empty string etc) it will not be tagged and\r\n * if there is an exception adding the property to the value (because its frozen etc) the\r\n * exception will be swallowed.\r\n * @param value - The object that should be tagged and converted if included into a dynamic\r\n * configuration.\r\n * @returns The original value\r\n */\r\nexport function forceDynamicConversion(value) {\r\n    if (value) {\r\n        try {\r\n            value[FORCE_DYNAMIC] = true;\r\n        }\r\n        catch (e) {\r\n            // Don't throw for this case as it's an ask only\r\n        }\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function to check whether an object can or should be converted into a dynamic\r\n * object.\r\n * @param value - The object to check whether it should be converted\r\n * @returns `true` if the value should be converted otherwise `false`.\r\n */\r\nexport function _canMakeDynamic(getFunc, state, value) {\r\n    var result = false;\r\n    // Object must exist and be truthy\r\n    if (value && !getFunc[state.blkVal]) {\r\n        // Tagged as always convert\r\n        result = value[FORCE_DYNAMIC];\r\n        // Check that it's not explicitly tagged as blocked\r\n        if (!result && !value[BLOCK_DYNAMIC]) {\r\n            // Only convert plain objects or arrays by default\r\n            result = isPlainObject(value) || isArray(value);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Throws an invalid access exception\r\n * @param message - The message to include in the exception\r\n */\r\nexport function throwInvalidAccess(message) {\r\n    throwTypeError(\"InvalidAccess:\" + message);\r\n}\r\n//# sourceMappingURL=DynamicSupport.js.map"],"mappings":";;;;;AAEA,SAAAA,OAAA,EAAAC,aAAA,EAAAC,aAAA,EAAAC,SAAA,EAAAC,cAAA;AACA,SAAAC,WAAA;AACA;AACA;AACA;AACA,WAAAC,gBAAA,GAAAH,SAAA;AACA;AACA;AACA;AACA;AACA;AACA,IAAAI,aAAA,GAAAJ,SAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAAK,aAAA,GAAAL,SAAA;AACA,gBAAAM,aAAAC,MAAA;EACA,IAAAA,MAAA;IACA,IAAAC,QAAA;IACA,IAAAX,OAAA,CAAAU,MAAA;MACAC,QAAA;MACAA,QAAA,CAAAN,WAAA,yBAAAK,MAAA,CAAAL,WAAA;IACA,OACA,IAAAJ,aAAA,CAAAS,MAAA;MACAC,QAAA;IACA;IACA,IAAAA,QAAA;MACA;MACAT,aAAA,CAAAQ,MAAA,YAAAE,GAAA,EAAAC,KAAA;QACA;QACAF,QAAA,CAAAC,GAAA,IAAAH,YAAA,CAAAI,KAAA;MACA;MACA,OAAAF,QAAA;IACA;EACA;EACA,OAAAD,MAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAAI,wBAAAD,KAAA;EACA,IAAAA,KAAA;IACA,IAAAE,OAAA,GAAAF,KAAA,CAAAP,gBAAA,KAAAO,KAAA;IACA,IAAAE,OAAA,CAAAC,GAAA,KAAAD,OAAA,CAAAC,GAAA,KAAAH,KAAA,IAAAE,OAAA,CAAAC,GAAA,CAAAV,gBAAA,MAAAS,OAAA;MACA,OAAAA,OAAA;IACA;EACA;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAAE,uBAAAJ,KAAA;EACA,IAAAA,KAAA,KAAAZ,aAAA,CAAAY,KAAA,KAAAb,OAAA,CAAAa,KAAA;IACA;MACAA,KAAA,CAAAN,aAAA;IACA,EACA,OAAAW,CAAA;MACA;IAAA;EAEA;EACA,OAAAL,KAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAAM,uBAAAN,KAAA;EACA,IAAAA,KAAA;IACA;MACAA,KAAA,CAAAL,aAAA;IACA,EACA,OAAAU,CAAA;MACA;IAAA;EAEA;EACA,OAAAL,KAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAAO,gBAAAC,OAAA,EAAAC,KAAA,EAAAT,KAAA;EACA,IAAAU,MAAA;EACA;EACA,IAAAV,KAAA,KAAAQ,OAAA,CAAAC,KAAA,CAAAE,MAAA;IACA;IACAD,MAAA,GAAAV,KAAA,CAAAL,aAAA;IACA;IACA,KAAAe,MAAA,KAAAV,KAAA,CAAAN,aAAA;MACA;MACAgB,MAAA,GAAAtB,aAAA,CAAAY,KAAA,KAAAb,OAAA,CAAAa,KAAA;IACA;EACA;EACA,OAAAU,MAAA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAAE,mBAAAC,OAAA;EACAtB,cAAA,oBAAAsB,OAAA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}