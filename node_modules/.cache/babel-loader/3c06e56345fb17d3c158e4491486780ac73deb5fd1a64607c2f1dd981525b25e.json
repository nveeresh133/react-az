{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport { strShimFunction, strShimPrototype } from \"@microsoft/applicationinsights-shims\";\nimport { getInst, objHasOwnProperty } from \"@nevware21/ts-utils\";\nimport { _DYN_APPLY, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SPLICE } from \"../__DynamicConstants\";\nimport { _getObjProto } from \"./HelperFuncs\";\nvar aiInstrumentHooks = \"_aiHooks\";\nvar cbNames = [\"req\", \"rsp\", \"hkErr\", \"fnErr\"];\n/** @ignore */\nfunction _arrLoop(arr, fn) {\n  if (arr) {\n    for (var lp = 0; lp < arr[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n      if (fn(arr[lp], lp)) {\n        break;\n      }\n    }\n  }\n}\n/** @ignore */\nfunction _doCallbacks(hooks, callDetails, cbArgs, hookCtx, type) {\n  if (type >= 0 /* CallbackType.Request */ && type <= 2 /* CallbackType.HookError */) {\n    _arrLoop(hooks, function (hook, idx) {\n      var cbks = hook.cbks;\n      var cb = cbks[cbNames[type]];\n      if (cb) {\n        // Set the specific hook context implementation using a lazy creation pattern\n        callDetails.ctx = function () {\n          var ctx = hookCtx[idx] = hookCtx[idx] || {};\n          return ctx;\n        };\n        try {\n          cb[_DYN_APPLY /* @min:%2eapply */](callDetails.inst, cbArgs);\n        } catch (err) {\n          var orgEx = callDetails.err;\n          try {\n            // Report Hook error via the callback\n            var hookErrorCb = cbks[cbNames[2 /* CallbackType.HookError */]];\n            if (hookErrorCb) {\n              callDetails.err = err;\n              hookErrorCb[_DYN_APPLY /* @min:%2eapply */](callDetails.inst, cbArgs);\n            }\n          } catch (e) {\n            // Not much we can do here -- swallowing the exception to avoid crashing the hosting app\n          } finally {\n            // restore the original exception (if any)\n            callDetails.err = orgEx;\n          }\n        }\n      }\n    });\n  }\n}\n/** @ignore */\nfunction _createFunctionHook(aiHook) {\n  // Define a temporary method that queues-up a the real method call\n  return function () {\n    var _a;\n    var funcThis = this;\n    // Capture the original arguments passed to the method\n    var orgArgs = arguments;\n    var hooks = aiHook.h;\n    var funcArgs = (_a = {}, _a[_DYN_NAME /* @min:name */] = aiHook.n, _a.inst = funcThis, _a.ctx = null, _a.set = _replaceArg, _a);\n    var hookCtx = [];\n    var cbArgs = _createArgs([funcArgs], orgArgs);\n    funcArgs.evt = getInst(\"event\");\n    function _createArgs(target, theArgs) {\n      _arrLoop(theArgs, function (arg) {\n        target[_DYN_PUSH /* @min:%2epush */](arg);\n      });\n      return target;\n    }\n    function _replaceArg(idx, value) {\n      orgArgs = _createArgs([], orgArgs);\n      orgArgs[idx] = value;\n      cbArgs = _createArgs([funcArgs], orgArgs);\n    }\n    // Call the pre-request hooks\n    _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 0 /* CallbackType.Request */);\n    // Call the original function was called\n    var theFunc = aiHook.f;\n    if (theFunc) {\n      try {\n        funcArgs.rslt = theFunc[_DYN_APPLY /* @min:%2eapply */](funcThis, orgArgs);\n      } catch (err) {\n        // Report the request callback\n        funcArgs.err = err;\n        _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 3 /* CallbackType.FunctionError */);\n        // rethrow the original exception so anyone listening for it can catch the exception\n        throw err;\n      }\n    }\n    // Call the post-request hooks\n    _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 1 /* CallbackType.Response */);\n    return funcArgs.rslt;\n  };\n}\n/** @ignore */\nfunction _getOwner(target, name, checkPrototype, checkParentProto) {\n  var owner = null;\n  if (target) {\n    if (objHasOwnProperty(target, name)) {\n      owner = target;\n    } else if (checkPrototype) {\n      owner = _getOwner(_getObjProto(target), name, checkParentProto, false);\n    }\n  }\n  return owner;\n}\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcName - The function name\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n */\nexport function InstrumentProto(target, funcName, callbacks) {\n  if (target) {\n    return InstrumentFunc(target[strShimPrototype], funcName, callbacks, false);\n  }\n  return null;\n}\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcNames - The function names to intercept and call\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n */\nexport function InstrumentProtos(target, funcNames, callbacks) {\n  if (target) {\n    return InstrumentFuncs(target[strShimPrototype], funcNames, callbacks, false);\n  }\n  return null;\n}\nfunction _createInstrumentHook(owner, funcName, fn, callbacks) {\n  var aiHook = fn && fn[aiInstrumentHooks];\n  if (!aiHook) {\n    // Only hook the function once\n    aiHook = {\n      i: 0,\n      n: funcName,\n      f: fn,\n      h: []\n    };\n    // Override (hook) the original function\n    var newFunc = _createFunctionHook(aiHook);\n    newFunc[aiInstrumentHooks] = aiHook; // Tag and store the function hooks\n    owner[funcName] = newFunc;\n  }\n  var theHook = {\n    // tslint:disable:object-literal-shorthand\n    id: aiHook.i,\n    cbks: callbacks,\n    rm: function () {\n      // DO NOT Use () => { shorthand for the function as the this gets replaced\n      // with the outer this and not the this for theHook instance.\n      var id = this.id;\n      _arrLoop(aiHook.h, function (hook, idx) {\n        if (hook.id === id) {\n          aiHook.h[_DYN_SPLICE /* @min:%2esplice */](idx, 1);\n          return 1;\n        }\n      });\n    }\n    // tslint:enable:object-literal-shorthand\n  };\n  aiHook.i++;\n  aiHook.h[_DYN_PUSH /* @min:%2epush */](theHook);\n  return theHook;\n}\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcName - The function name\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function\r\n * @param checkParentProto - If the function doesn't exist on the target or it's prototype should it attempt to hook the parent's prototype\r\n */\nexport function InstrumentFunc(target, funcName, callbacks, checkPrototype, checkParentProto) {\n  if (checkPrototype === void 0) {\n    checkPrototype = true;\n  }\n  if (target && funcName && callbacks) {\n    var owner = _getOwner(target, funcName, checkPrototype, checkParentProto);\n    if (owner) {\n      var fn = owner[funcName];\n      if (typeof fn === strShimFunction) {\n        return _createInstrumentHook(owner, funcName, fn, callbacks);\n      }\n    }\n  }\n  return null;\n}\n/**\r\n * Intercept the named functions for the target class / object\r\n * @param target - The target object\r\n * @param funcNames - The function names to intercept and call\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function\r\n * @param checkParentProto - If the function doesn't exist on the target or it's prototype should it attempt to hook the parent's prototype\r\n */\nexport function InstrumentFuncs(target, funcNames, callbacks, checkPrototype, checkParentProto) {\n  if (checkPrototype === void 0) {\n    checkPrototype = true;\n  }\n  var hooks = null;\n  _arrLoop(funcNames, function (funcName) {\n    var hook = InstrumentFunc(target, funcName, callbacks, checkPrototype, checkParentProto);\n    if (hook) {\n      if (!hooks) {\n        hooks = [];\n      }\n      hooks[_DYN_PUSH /* @min:%2epush */](hook);\n    }\n  });\n  return hooks;\n}\n/**\r\n * Add an instrumentation hook to the provided named \"event\" for the target class / object, this doesn't check whether the\r\n * named \"event\" is in fact a function and just assigns the instrumentation hook to the target[evtName]\r\n * @param target - The target object\r\n * @param evtName - The name of the event\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function\r\n * @param checkParentProto - If the function doesn't exist on the target or it's prototype should it attempt to hook the parent's prototype\r\n */\nexport function InstrumentEvent(target, evtName, callbacks, checkPrototype, checkParentProto) {\n  if (target && evtName && callbacks) {\n    var owner = _getOwner(target, evtName, checkPrototype, checkParentProto) || target;\n    if (owner) {\n      return _createInstrumentHook(owner, evtName, owner[evtName], callbacks);\n    }\n  }\n  return null;\n}","map":{"version":3,"names":["strShimFunction","strShimPrototype","getInst","objHasOwnProperty","_DYN_APPLY","_DYN_LENGTH","_DYN_NAME","_DYN_PUSH","_DYN_SPLICE","_getObjProto","aiInstrumentHooks","cbNames","_arrLoop","arr","fn","lp","_doCallbacks","hooks","callDetails","cbArgs","hookCtx","type","hook","idx","cbks","cb","ctx","inst","err","orgEx","hookErrorCb","e","_createFunctionHook","aiHook","_a","funcThis","orgArgs","arguments","h","funcArgs","n","set","_replaceArg","_createArgs","evt","target","theArgs","arg","value","theFunc","f","rslt","_getOwner","name","checkPrototype","checkParentProto","owner","InstrumentProto","funcName","callbacks","InstrumentFunc","InstrumentProtos","funcNames","InstrumentFuncs","_createInstrumentHook","i","newFunc","theHook","id","rm","InstrumentEvent","evtName"],"sources":["/home/veeresh133/app/test-error-react/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/InstrumentHooks.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { strShimFunction, strShimPrototype } from \"@microsoft/applicationinsights-shims\";\r\nimport { getInst, objHasOwnProperty } from \"@nevware21/ts-utils\";\r\nimport { _DYN_APPLY, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SPLICE } from \"../__DynamicConstants\";\r\nimport { _getObjProto } from \"./HelperFuncs\";\r\nvar aiInstrumentHooks = \"_aiHooks\";\r\nvar cbNames = [\r\n    \"req\", \"rsp\", \"hkErr\", \"fnErr\"\r\n];\r\n/** @ignore */\r\nfunction _arrLoop(arr, fn) {\r\n    if (arr) {\r\n        for (var lp = 0; lp < arr[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n            if (fn(arr[lp], lp)) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n/** @ignore */\r\nfunction _doCallbacks(hooks, callDetails, cbArgs, hookCtx, type) {\r\n    if (type >= 0 /* CallbackType.Request */ && type <= 2 /* CallbackType.HookError */) {\r\n        _arrLoop(hooks, function (hook, idx) {\r\n            var cbks = hook.cbks;\r\n            var cb = cbks[cbNames[type]];\r\n            if (cb) {\r\n                // Set the specific hook context implementation using a lazy creation pattern\r\n                callDetails.ctx = function () {\r\n                    var ctx = hookCtx[idx] = (hookCtx[idx] || {});\r\n                    return ctx;\r\n                };\r\n                try {\r\n                    cb[_DYN_APPLY /* @min:%2eapply */](callDetails.inst, cbArgs);\r\n                }\r\n                catch (err) {\r\n                    var orgEx = callDetails.err;\r\n                    try {\r\n                        // Report Hook error via the callback\r\n                        var hookErrorCb = cbks[cbNames[2 /* CallbackType.HookError */]];\r\n                        if (hookErrorCb) {\r\n                            callDetails.err = err;\r\n                            hookErrorCb[_DYN_APPLY /* @min:%2eapply */](callDetails.inst, cbArgs);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        // Not much we can do here -- swallowing the exception to avoid crashing the hosting app\r\n                    }\r\n                    finally {\r\n                        // restore the original exception (if any)\r\n                        callDetails.err = orgEx;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n/** @ignore */\r\nfunction _createFunctionHook(aiHook) {\r\n    // Define a temporary method that queues-up a the real method call\r\n    return function () {\r\n        var _a;\r\n        var funcThis = this;\r\n        // Capture the original arguments passed to the method\r\n        var orgArgs = arguments;\r\n        var hooks = aiHook.h;\r\n        var funcArgs = (_a = {},\r\n            _a[_DYN_NAME /* @min:name */] = aiHook.n,\r\n            _a.inst = funcThis,\r\n            _a.ctx = null,\r\n            _a.set = _replaceArg,\r\n            _a);\r\n        var hookCtx = [];\r\n        var cbArgs = _createArgs([funcArgs], orgArgs);\r\n        funcArgs.evt = getInst(\"event\");\r\n        function _createArgs(target, theArgs) {\r\n            _arrLoop(theArgs, function (arg) {\r\n                target[_DYN_PUSH /* @min:%2epush */](arg);\r\n            });\r\n            return target;\r\n        }\r\n        function _replaceArg(idx, value) {\r\n            orgArgs = _createArgs([], orgArgs);\r\n            orgArgs[idx] = value;\r\n            cbArgs = _createArgs([funcArgs], orgArgs);\r\n        }\r\n        // Call the pre-request hooks\r\n        _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 0 /* CallbackType.Request */);\r\n        // Call the original function was called\r\n        var theFunc = aiHook.f;\r\n        if (theFunc) {\r\n            try {\r\n                funcArgs.rslt = theFunc[_DYN_APPLY /* @min:%2eapply */](funcThis, orgArgs);\r\n            }\r\n            catch (err) {\r\n                // Report the request callback\r\n                funcArgs.err = err;\r\n                _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 3 /* CallbackType.FunctionError */);\r\n                // rethrow the original exception so anyone listening for it can catch the exception\r\n                throw err;\r\n            }\r\n        }\r\n        // Call the post-request hooks\r\n        _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 1 /* CallbackType.Response */);\r\n        return funcArgs.rslt;\r\n    };\r\n}\r\n/** @ignore */\r\nfunction _getOwner(target, name, checkPrototype, checkParentProto) {\r\n    var owner = null;\r\n    if (target) {\r\n        if (objHasOwnProperty(target, name)) {\r\n            owner = target;\r\n        }\r\n        else if (checkPrototype) {\r\n            owner = _getOwner(_getObjProto(target), name, checkParentProto, false);\r\n        }\r\n    }\r\n    return owner;\r\n}\r\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcName - The function name\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n */\r\nexport function InstrumentProto(target, funcName, callbacks) {\r\n    if (target) {\r\n        return InstrumentFunc(target[strShimPrototype], funcName, callbacks, false);\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcNames - The function names to intercept and call\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n */\r\nexport function InstrumentProtos(target, funcNames, callbacks) {\r\n    if (target) {\r\n        return InstrumentFuncs(target[strShimPrototype], funcNames, callbacks, false);\r\n    }\r\n    return null;\r\n}\r\nfunction _createInstrumentHook(owner, funcName, fn, callbacks) {\r\n    var aiHook = fn && fn[aiInstrumentHooks];\r\n    if (!aiHook) {\r\n        // Only hook the function once\r\n        aiHook = {\r\n            i: 0,\r\n            n: funcName,\r\n            f: fn,\r\n            h: []\r\n        };\r\n        // Override (hook) the original function\r\n        var newFunc = _createFunctionHook(aiHook);\r\n        newFunc[aiInstrumentHooks] = aiHook; // Tag and store the function hooks\r\n        owner[funcName] = newFunc;\r\n    }\r\n    var theHook = {\r\n        // tslint:disable:object-literal-shorthand\r\n        id: aiHook.i,\r\n        cbks: callbacks,\r\n        rm: function () {\r\n            // DO NOT Use () => { shorthand for the function as the this gets replaced\r\n            // with the outer this and not the this for theHook instance.\r\n            var id = this.id;\r\n            _arrLoop(aiHook.h, function (hook, idx) {\r\n                if (hook.id === id) {\r\n                    aiHook.h[_DYN_SPLICE /* @min:%2esplice */](idx, 1);\r\n                    return 1;\r\n                }\r\n            });\r\n        }\r\n        // tslint:enable:object-literal-shorthand\r\n    };\r\n    aiHook.i++;\r\n    aiHook.h[_DYN_PUSH /* @min:%2epush */](theHook);\r\n    return theHook;\r\n}\r\n/**\r\n * Intercept the named prototype functions for the target class / object\r\n * @param target - The target object\r\n * @param funcName - The function name\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function\r\n * @param checkParentProto - If the function doesn't exist on the target or it's prototype should it attempt to hook the parent's prototype\r\n */\r\nexport function InstrumentFunc(target, funcName, callbacks, checkPrototype, checkParentProto) {\r\n    if (checkPrototype === void 0) { checkPrototype = true; }\r\n    if (target && funcName && callbacks) {\r\n        var owner = _getOwner(target, funcName, checkPrototype, checkParentProto);\r\n        if (owner) {\r\n            var fn = owner[funcName];\r\n            if (typeof fn === strShimFunction) {\r\n                return _createInstrumentHook(owner, funcName, fn, callbacks);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Intercept the named functions for the target class / object\r\n * @param target - The target object\r\n * @param funcNames - The function names to intercept and call\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function\r\n * @param checkParentProto - If the function doesn't exist on the target or it's prototype should it attempt to hook the parent's prototype\r\n */\r\nexport function InstrumentFuncs(target, funcNames, callbacks, checkPrototype, checkParentProto) {\r\n    if (checkPrototype === void 0) { checkPrototype = true; }\r\n    var hooks = null;\r\n    _arrLoop(funcNames, function (funcName) {\r\n        var hook = InstrumentFunc(target, funcName, callbacks, checkPrototype, checkParentProto);\r\n        if (hook) {\r\n            if (!hooks) {\r\n                hooks = [];\r\n            }\r\n            hooks[_DYN_PUSH /* @min:%2epush */](hook);\r\n        }\r\n    });\r\n    return hooks;\r\n}\r\n/**\r\n * Add an instrumentation hook to the provided named \"event\" for the target class / object, this doesn't check whether the\r\n * named \"event\" is in fact a function and just assigns the instrumentation hook to the target[evtName]\r\n * @param target - The target object\r\n * @param evtName - The name of the event\r\n * @param callbacks - The callbacks to configure and call whenever the function is called\r\n * @param checkPrototype - If the function doesn't exist on the target should it attempt to hook the prototype function\r\n * @param checkParentProto - If the function doesn't exist on the target or it's prototype should it attempt to hook the parent's prototype\r\n */\r\nexport function InstrumentEvent(target, evtName, callbacks, checkPrototype, checkParentProto) {\r\n    if (target && evtName && callbacks) {\r\n        var owner = _getOwner(target, evtName, checkPrototype, checkParentProto) || target;\r\n        if (owner) {\r\n            return _createInstrumentHook(owner, evtName, owner[evtName], callbacks);\r\n        }\r\n    }\r\n    return null;\r\n}\r\n//# sourceMappingURL=InstrumentHooks.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}