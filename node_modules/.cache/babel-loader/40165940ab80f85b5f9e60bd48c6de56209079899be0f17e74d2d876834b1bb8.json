{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { createPromise, doAwaitResponse } from \"@nevware21/ts-async\";\nimport { arrForEach, dumpObj, getNavigator, getWindow, isFunction, objKeys } from \"@nevware21/ts-utils\";\nimport { _DYN_DATA, _DYN_HEADERS, _DYN_INITIALIZE, _DYN_LENGTH, _DYN_MESSAGE, _DYN_PROTOCOL, _DYN_REPLACE, _DYN_SEND_POST, _DYN_SET_REQUEST_HEADER, _DYN_STATUS, _DYN_TIMEOUT, _DYN_TO_LOWER_CASE, _DYN_URL_STRING, _DYN_VALUE, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\nimport { DisabledPropertyName } from \"./Constants\";\nimport { _throwInternal, _warnToConsole } from \"./DiagnosticLogger\";\nimport { getLocation, isBeaconsSupported, isFetchSupported, isXhrSupported, useXDomainRequest } from \"./EnvUtils\";\nimport { _getAllResponseHeaders, formatErrorMessageXdr, formatErrorMessageXhr, getResponseText, openXhr } from \"./HelperFuncs\";\nvar STR_EMPTY = \"\";\nvar STR_NO_RESPONSE_BODY = \"NoResponseBody\";\nvar _noResponseQs = \"&\" + STR_NO_RESPONSE_BODY + \"=true\";\nvar STR_POST_METHOD = \"POST\";\n/**\r\n * This Internal component\r\n * Manager SendPost functions\r\n * SendPostManger\r\n * @internal for internal use only\r\n */\nvar SenderPostManager = /** @class */function () {\n  function SenderPostManager() {\n    var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)\n    var _enableSendPromise;\n    var _isInitialized;\n    var _diagLog;\n    var _isOneDs;\n    var _onCompleteFuncs;\n    var _disableCredentials;\n    var _fetchCredentials;\n    var _fallbackInst;\n    var _disableXhr;\n    var _disableBeacon;\n    var _disableBeaconSync;\n    var _disableFetchKeepAlive;\n    var _addNoResponse;\n    var _timeoutWrapper;\n    dynamicProto(SenderPostManager, this, function (_self, _base) {\n      var _sendCredentials = true; // for 1ds\n      _initDefaults();\n      _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, diagLog) {\n        _diagLog = diagLog;\n        if (_isInitialized) {\n          _throwInternal(_diagLog, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender is already initialized\");\n        }\n        _self.SetConfig(config);\n        _isInitialized = true;\n      };\n      _self[\"_getDbgPlgTargets\"] = function () {\n        return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];\n      };\n      // This componet might get its config from sender, offline sender, 1ds post\n      // so set this function to mock dynamic changes\n      _self.SetConfig = function (config) {\n        try {\n          _onCompleteFuncs = config.senderOnCompleteCallBack || {};\n          _disableCredentials = !!config.disableCredentials;\n          _fetchCredentials = config.fetchCredentials;\n          _isOneDs = !!config.isOneDs;\n          _enableSendPromise = !!config.enableSendPromise;\n          _disableXhr = !!config.disableXhr;\n          _disableBeacon = !!config.disableBeacon;\n          _disableBeaconSync = !!config.disableBeaconSync;\n          _timeoutWrapper = config.timeWrapper;\n          _addNoResponse = !!config.addNoResponse;\n          _disableFetchKeepAlive = !!config.disableFetchKeepAlive;\n          _fallbackInst = {\n            sendPOST: _xhrSender\n          };\n          if (!_isOneDs) {\n            _sendCredentials = false; // for appInsights, set it to false always\n          }\n          if (_disableCredentials) {\n            var location_1 = getLocation();\n            if (location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === \"file:\") {\n              // Special case where a local html file fails with a CORS error on Chromium browsers\n              _sendCredentials = false;\n            }\n          }\n          return true;\n        } catch (e) {\n          // eslint-disable-next-line no-empty\n        }\n        return false;\n      };\n      _self.getSyncFetchPayload = function () {\n        return _syncFetchPayload;\n      };\n      _self.getSenderInst = function (transports, sync) {\n        if (transports && transports[_DYN_LENGTH /* @min:%2elength */]) {\n          return _getSenderInterface(transports, sync);\n        }\n        return null;\n      };\n      _self.getFallbackInst = function () {\n        return _fallbackInst;\n      };\n      _self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] = function (unloadCtx, unloadState) {\n        _initDefaults();\n      };\n      /**\r\n       * success handler\r\n       */\n      function _onSuccess(res, onComplete) {\n        _doOnComplete(onComplete, 200, {}, res);\n      }\n      /**\r\n       * error handler\r\n       */\n      function _onError(message, onComplete) {\n        _throwInternal(_diagLog, 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, \"Failed to send telemetry.\", {\n          message: message\n        });\n        _doOnComplete(onComplete, 400, {});\n      }\n      function _onNoPayloadUrl(onComplete) {\n        _onError(\"No endpoint url is provided for the batch\", onComplete);\n      }\n      function _getSenderInterface(transports, syncSupport) {\n        var _a;\n        var transportType = 0 /* TransportType.NotSet */;\n        var sendPostFunc = null;\n        var lp = 0;\n        while (sendPostFunc == null && lp < transports[_DYN_LENGTH /* @min:%2elength */]) {\n          transportType = transports[lp];\n          if (!_disableXhr && transportType === 1 /* TransportType.Xhr */) {\n            if (useXDomainRequest()) {\n              // IE 8 and 9\n              sendPostFunc = _xdrSender;\n            } else if (isXhrSupported()) {\n              sendPostFunc = _xhrSender;\n            }\n          } else if (transportType === 2 /* TransportType.Fetch */ && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {\n            sendPostFunc = _doFetchSender;\n          } else if (transportType === 3 /* TransportType.Beacon */ && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {\n            sendPostFunc = _beaconSender;\n          }\n          lp++;\n        }\n        if (sendPostFunc) {\n          return _a = {\n            _transport: transportType,\n            _isSync: syncSupport\n          }, _a[_DYN_SEND_POST /* @min:sendPOST */] = sendPostFunc, _a;\n        }\n        return null;\n      }\n      function _doOnComplete(oncomplete, status, headers, response) {\n        try {\n          oncomplete && oncomplete(status, headers, response);\n        } catch (e) {\n          // eslint-disable-next-line no-empty\n        }\n      }\n      function _doBeaconSend(payload, oncomplete) {\n        var nav = getNavigator();\n        var url = payload[_DYN_URL_STRING /* @min:%2eurlString */];\n        if (!url) {\n          _onNoPayloadUrl(oncomplete);\n          // return true here, because we don't want to retry it with fallback sender\n          return true;\n        }\n        url = payload[_DYN_URL_STRING /* @min:%2eurlString */] + (_addNoResponse ? _noResponseQs : STR_EMPTY);\n        var data = payload[_DYN_DATA /* @min:%2edata */];\n        // Chrome only allows CORS-safelisted values for the sendBeacon data argument\n        // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283\n        // Chrome only allows CORS-safelisted values for the sendBeacon data argument\n        // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283\n        var plainTextBatch = _isOneDs ? data : new Blob([data], {\n          type: \"text/plain;charset=UTF-8\"\n        });\n        // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\n        var queued = nav.sendBeacon(url, plainTextBatch);\n        return queued;\n      }\n      /**\r\n       * Send Beacon API request\r\n       * @param payload - {string} - The data payload to be sent.\r\n       * @param sync - {boolean} - not used\r\n       * Note: Beacon API does not support custom headers and we are not able to get\r\n       * appId from the backend for the correct correlation.\r\n       */\n      function _beaconSender(payload, oncomplete, sync) {\n        var data = payload[_DYN_DATA /* @min:%2edata */];\n        try {\n          if (data) {\n            // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\n            if (!_doBeaconSend(payload, oncomplete)) {\n              var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;\n              if (onRetry && isFunction(onRetry)) {\n                onRetry(payload, oncomplete, _doBeaconSend);\n              } else {\n                _fallbackInst && _fallbackInst[_DYN_SEND_POST /* @min:%2esendPOST */](payload, oncomplete, true);\n                _throwInternal(_diagLog, 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\n              }\n            } else {\n              // if can send\n              _onSuccess(STR_EMPTY, oncomplete);\n            }\n          }\n        } catch (e) {\n          _isOneDs && _warnToConsole(_diagLog, \"Failed to send telemetry using sendBeacon API. Ex:\" + dumpObj(e));\n          _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY);\n        }\n        return;\n      }\n      /**\r\n       * Send XMLHttpRequest\r\n       * @param payload - {string} - The data payload to be sent.\r\n       * @param sync - {boolean} - Indicates if the request should be sent synchronously\r\n       */\n      function _xhrSender(payload, oncomplete, sync) {\n        //let  internalPayload = payload as IInternalPayloadData;\n        var thePromise;\n        var resolveFunc;\n        var rejectFunc;\n        var headers = payload[_DYN_HEADERS /* @min:%2eheaders */] || {};\n        if (!sync && _enableSendPromise) {\n          thePromise = createPromise(function (resolve, reject) {\n            resolveFunc = resolve;\n            rejectFunc = reject;\n          });\n        }\n        if (_isOneDs && sync && payload.disableXhrSync) {\n          sync = false;\n        }\n        //const xhr = new XMLHttpRequest();\n        var endPointUrl = payload[_DYN_URL_STRING /* @min:%2eurlString */];\n        if (!endPointUrl) {\n          _onNoPayloadUrl(oncomplete);\n          resolveFunc && resolveFunc(false);\n          return;\n        }\n        var xhr = openXhr(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DYN_TIMEOUT /* @min:%2etimeout */]);\n        if (!_isOneDs) {\n          // application/json should NOT add to 1ds post by default\n          xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](\"Content-type\", \"application/json\");\n        }\n        arrForEach(objKeys(headers), function (headerName) {\n          xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](headerName, headers[headerName]);\n        });\n        xhr.onreadystatechange = function () {\n          if (!_isOneDs) {\n            _doOnReadyFunc(xhr);\n            if (xhr.readyState === 4) {\n              resolveFunc && resolveFunc(true);\n            }\n          }\n        };\n        xhr.onload = function () {\n          if (_isOneDs) {\n            _doOnReadyFunc(xhr);\n          }\n        };\n        function _doOnReadyFunc(xhr) {\n          var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;\n          var onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);\n          if (onReadyFuncExist) {\n            onReadyFunc(xhr, oncomplete, payload);\n          } else {\n            var response = getResponseText(xhr);\n            _doOnComplete(oncomplete, xhr[_DYN_STATUS /* @min:%2estatus */], _getAllResponseHeaders(xhr, _isOneDs), response);\n          }\n        }\n        xhr.onerror = function (event) {\n          _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS /* @min:%2estatus */] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr));\n          rejectFunc && rejectFunc(event);\n        };\n        xhr.ontimeout = function () {\n          _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS /* @min:%2estatus */] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr));\n          resolveFunc && resolveFunc(false);\n        };\n        xhr.send(payload[_DYN_DATA /* @min:%2edata */]);\n        return thePromise;\n      }\n      /**\r\n       * Send fetch API request\r\n       * @param payload - {string} - The data payload to be sent.\r\n       * @param sync - {boolean} - For fetch this identifies whether we are \"unloading\" (false) or a normal request\r\n       */\n      function _doFetchSender(payload, oncomplete, sync) {\n        var _a;\n        var endPointUrl = payload[_DYN_URL_STRING /* @min:%2eurlString */];\n        var batch = payload[_DYN_DATA /* @min:%2edata */];\n        var plainTextBatch = _isOneDs ? batch : new Blob([batch], {\n          type: \"application/json\"\n        });\n        var thePromise;\n        var resolveFunc;\n        var rejectFunc;\n        var requestHeaders = new Headers();\n        var batchLength = batch[_DYN_LENGTH /* @min:%2elength */];\n        var ignoreResponse = false;\n        var responseHandled = false;\n        var headers = payload[_DYN_HEADERS /* @min:%2eheaders */] || {};\n        //TODO: handle time out for 1ds\n        var init = (_a = {\n          method: STR_POST_METHOD,\n          body: plainTextBatch\n        }, _a[DisabledPropertyName] = true // Mark so we don't attempt to track this request\n        , _a);\n        // Only add headers if there are headers to add, due to issue with some polyfills\n        if (payload.headers && objKeys(payload.headers)[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          arrForEach(objKeys(headers), function (headerName) {\n            requestHeaders.append(headerName, headers[headerName]);\n          });\n          init[_DYN_HEADERS /* @min:%2eheaders */] = requestHeaders;\n        }\n        if (_fetchCredentials) {\n          // if user passed in this value via post channel (1ds), then use it\n          init.credentials = _fetchCredentials;\n        } else if (_sendCredentials && _isOneDs) {\n          // for 1ds, Don't send credentials when URL is file://\n          init.credentials = \"include\";\n        }\n        if (sync) {\n          init.keepalive = true;\n          _syncFetchPayload += batchLength;\n          if (_isOneDs) {\n            if (payload[\"_sendReason\"] === 2 /* SendRequestReason.Unload */) {\n              // As a sync request (during unload), it is unlikely that we will get a chance to process the response so\n              // just like beacon send assume that the events have been accepted and processed\n              ignoreResponse = true;\n              if (_addNoResponse) {\n                endPointUrl += _noResponseQs;\n              }\n            }\n          } else {\n            // for appinsights, set to true for all sync request\n            ignoreResponse = true;\n          }\n        }\n        var request = new Request(endPointUrl, init);\n        try {\n          // Also try and tag the request (just in case the value in init is not copied over)\n          request[DisabledPropertyName] = true;\n        } catch (e) {\n          // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\n          // cause the request to fail and we no telemetry would be sent\n        }\n        if (!sync && _enableSendPromise) {\n          thePromise = createPromise(function (resolve, reject) {\n            resolveFunc = resolve;\n            rejectFunc = reject;\n          });\n        }\n        if (!endPointUrl) {\n          _onNoPayloadUrl(oncomplete);\n          resolveFunc && resolveFunc(false);\n          return;\n        }\n        function _handleError(res) {\n          // In case there is an error in the request. Set the status to 0 for 1ds and 400 for appInsights\n          // so that the events can be retried later.\n          _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY : res);\n        }\n        function _onFetchComplete(response, payload, value) {\n          var status = response[_DYN_STATUS /* @min:%2estatus */];\n          var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;\n          if (onCompleteFunc && isFunction(onCompleteFunc)) {\n            onCompleteFunc(response, oncomplete, value || STR_EMPTY, payload);\n          } else {\n            _doOnComplete(oncomplete, status, {}, value || STR_EMPTY);\n          }\n        }\n        try {\n          doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function (result) {\n            if (sync) {\n              _syncFetchPayload -= batchLength;\n              batchLength = 0;\n            }\n            if (!responseHandled) {\n              responseHandled = true;\n              if (!result.rejected) {\n                var response_1 = result[_DYN_VALUE /* @min:%2evalue */];\n                try {\n                  /**\r\n                   * The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500.\r\n                   * Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure\r\n                   * or if anything prevented the request from completing.\r\n                   */\n                  if (!_isOneDs && !response_1.ok) {\n                    // this is for appInsights only\n                    _handleError(response_1.statusText);\n                    resolveFunc && resolveFunc(false);\n                  } else {\n                    if (_isOneDs && !response_1.body) {\n                      _onFetchComplete(response_1, null, STR_EMPTY);\n                      resolveFunc && resolveFunc(true);\n                    } else {\n                      doAwaitResponse(response_1.text(), function (resp) {\n                        _onFetchComplete(response_1, payload, resp[_DYN_VALUE /* @min:%2evalue */]);\n                        resolveFunc && resolveFunc(true);\n                      });\n                    }\n                  }\n                } catch (e) {\n                  _handleError(dumpObj(e));\n                  rejectFunc && rejectFunc(e);\n                }\n              } else {\n                _handleError(result.reason && result.reason[_DYN_MESSAGE /* @min:%2emessage */]);\n                rejectFunc && rejectFunc(result.reason);\n              }\n            }\n          });\n        } catch (e) {\n          if (!responseHandled) {\n            _handleError(dumpObj(e));\n            rejectFunc && rejectFunc(e);\n          }\n        }\n        if (ignoreResponse && !responseHandled) {\n          // Assume success during unload processing as we most likely won't get the response\n          responseHandled = true;\n          _doOnComplete(oncomplete, 200, {});\n          resolveFunc && resolveFunc(true);\n        }\n        if (_isOneDs && !responseHandled && payload[_DYN_TIMEOUT /* @min:%2etimeout */] > 0) {\n          // Simulate timeout\n          _timeoutWrapper && _timeoutWrapper.set(function () {\n            if (!responseHandled) {\n              // Assume a 500 response (which will cause a retry)\n              responseHandled = true;\n              _doOnComplete(oncomplete, 500, {});\n              resolveFunc && resolveFunc(true);\n            }\n          }, payload[_DYN_TIMEOUT /* @min:%2etimeout */]);\n        }\n        return thePromise;\n      }\n      /**\r\n       * Send XDomainRequest\r\n       * @param payload - {string} - The data payload to be sent.\r\n       * @param sync - {boolean} - Indicates if the request should be sent synchronously\r\n       *\r\n       * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added\r\n       * to maintain consistency with the xhrSender's contract\r\n       * Note: XDomainRequest does not support custom headers and we are not able to get\r\n       * appId from the backend for the correct correlation.\r\n       */\n      function _xdrSender(payload, oncomplete, sync) {\n        // It doesn't support custom headers, so no action is taken with current requestHeaders\n        var _window = getWindow();\n        var xdr = new XDomainRequest();\n        var data = payload[_DYN_DATA /* @min:%2edata */];\n        xdr.onload = function () {\n          var response = getResponseText(xdr);\n          var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;\n          if (onloadFunc && isFunction(onloadFunc)) {\n            onloadFunc(xdr, oncomplete, payload);\n          } else {\n            _doOnComplete(oncomplete, 200, {}, response);\n          }\n        };\n        xdr.onerror = function () {\n          _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY : formatErrorMessageXdr(xdr));\n        };\n        xdr.ontimeout = function () {\n          _doOnComplete(oncomplete, 500, {});\n        };\n        xdr.onprogress = function () {};\n        // XDomainRequest requires the same protocol as the hosting page.\n        // If the protocol doesn't match, we can't send the telemetry :(.\n        var hostingProtocol = _window && _window.location && _window.location[_DYN_PROTOCOL /* @min:%2eprotocol */] || \"\";\n        var endpoint = payload[_DYN_URL_STRING /* @min:%2eurlString */];\n        if (!endpoint) {\n          _onNoPayloadUrl(oncomplete);\n          return;\n        }\n        if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {\n          var msg = \"Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.\";\n          _throwInternal(_diagLog, 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + msg);\n          _onError(msg, oncomplete);\n          return;\n        }\n        var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE /* @min:%2ereplace */](/^(https?:)/, \"\");\n        xdr.open(STR_POST_METHOD, endpointUrl);\n        if (payload[_DYN_TIMEOUT /* @min:%2etimeout */]) {\n          xdr[_DYN_TIMEOUT /* @min:%2etimeout */] = payload[_DYN_TIMEOUT /* @min:%2etimeout */];\n        }\n        xdr.send(data);\n        if (_isOneDs && sync) {\n          _timeoutWrapper && _timeoutWrapper.set(function () {\n            xdr.send(data);\n          }, 0);\n        } else {\n          xdr.send(data);\n        }\n      }\n      function _initDefaults() {\n        _syncFetchPayload = 0;\n        _isInitialized = false;\n        _enableSendPromise = false;\n        _diagLog = null;\n        _isOneDs = null;\n        _onCompleteFuncs = null;\n        _disableCredentials = null;\n        _fetchCredentials = null;\n        _fallbackInst = null;\n        _disableXhr = false;\n        _disableBeacon = false;\n        _disableBeaconSync = false;\n        _disableFetchKeepAlive = false;\n        _addNoResponse = false;\n        _timeoutWrapper = null;\n      }\n    });\n  }\n  // Removed Stub for SenderPostManager.prototype.initialize.\n  // Removed Stub for SenderPostManager.prototype.getSyncFetchPayload.\n  // Removed Stub for SenderPostManager.prototype.SetConfig.\n  // Removed Stub for SenderPostManager.prototype.getSenderInst.\n  // Removed Stub for SenderPostManager.prototype.getFallbackInst.\n  // Removed Stub for SenderPostManager.prototype._doTeardown.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  SenderPostManager.__ieDyn = 1;\n  return SenderPostManager;\n}();\nexport { SenderPostManager };","map":{"version":3,"names":["dynamicProto","createPromise","doAwaitResponse","arrForEach","dumpObj","getNavigator","getWindow","isFunction","objKeys","_DYN_DATA","_DYN_HEADERS","_DYN_INITIALIZE","_DYN_LENGTH","_DYN_MESSAGE","_DYN_PROTOCOL","_DYN_REPLACE","_DYN_SEND_POST","_DYN_SET_REQUEST_HEADER","_DYN_STATUS","_DYN_TIMEOUT","_DYN_TO_LOWER_CASE","_DYN_URL_STRING","_DYN_VALUE","_DYN__DO_TEARDOWN","DisabledPropertyName","_throwInternal","_warnToConsole","getLocation","isBeaconsSupported","isFetchSupported","isXhrSupported","useXDomainRequest","_getAllResponseHeaders","formatErrorMessageXdr","formatErrorMessageXhr","getResponseText","openXhr","STR_EMPTY","STR_NO_RESPONSE_BODY","_noResponseQs","STR_POST_METHOD","SenderPostManager","_syncFetchPayload","_enableSendPromise","_isInitialized","_diagLog","_isOneDs","_onCompleteFuncs","_disableCredentials","_fetchCredentials","_fallbackInst","_disableXhr","_disableBeacon","_disableBeaconSync","_disableFetchKeepAlive","_addNoResponse","_timeoutWrapper","_self","_base","_sendCredentials","_initDefaults","config","diagLog","SetConfig","senderOnCompleteCallBack","disableCredentials","fetchCredentials","isOneDs","enableSendPromise","disableXhr","disableBeacon","disableBeaconSync","timeWrapper","addNoResponse","disableFetchKeepAlive","sendPOST","_xhrSender","location_1","protocol","e","getSyncFetchPayload","getSenderInst","transports","sync","_getSenderInterface","getFallbackInst","unloadCtx","unloadState","_onSuccess","res","onComplete","_doOnComplete","_onError","message","_onNoPayloadUrl","syncSupport","_a","transportType","sendPostFunc","lp","_xdrSender","_doFetchSender","_beaconSender","_transport","_isSync","oncomplete","status","headers","response","_doBeaconSend","payload","nav","url","data","plainTextBatch","Blob","type","queued","sendBeacon","onRetry","beaconOnRetry","thePromise","resolveFunc","rejectFunc","resolve","reject","disableXhrSync","endPointUrl","xhr","headerName","onreadystatechange","_doOnReadyFunc","readyState","onload","onReadyFunc","xhrOnComplete","onReadyFuncExist","onerror","event","ontimeout","send","batch","requestHeaders","Headers","batchLength","ignoreResponse","responseHandled","init","method","body","append","credentials","keepalive","request","Request","_handleError","_onFetchComplete","value","onCompleteFunc","fetchOnComplete","fetch","result","rejected","response_1","ok","statusText","text","resp","reason","set","_window","xdr","XDomainRequest","onloadFunc","xdrOnComplete","onprogress","hostingProtocol","location","endpoint","lastIndexOf","msg","endpointUrl","open"],"sources":["/home/veeresh133/app/my-app/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/SenderPostManager.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { createPromise, doAwaitResponse } from \"@nevware21/ts-async\";\r\nimport { arrForEach, dumpObj, getNavigator, getWindow, isFunction, objKeys } from \"@nevware21/ts-utils\";\r\nimport { _DYN_DATA, _DYN_HEADERS, _DYN_INITIALIZE, _DYN_LENGTH, _DYN_MESSAGE, _DYN_PROTOCOL, _DYN_REPLACE, _DYN_SEND_POST, _DYN_SET_REQUEST_HEADER, _DYN_STATUS, _DYN_TIMEOUT, _DYN_TO_LOWER_CASE, _DYN_URL_STRING, _DYN_VALUE, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\r\nimport { DisabledPropertyName } from \"./Constants\";\r\nimport { _throwInternal, _warnToConsole } from \"./DiagnosticLogger\";\r\nimport { getLocation, isBeaconsSupported, isFetchSupported, isXhrSupported, useXDomainRequest } from \"./EnvUtils\";\r\nimport { _getAllResponseHeaders, formatErrorMessageXdr, formatErrorMessageXhr, getResponseText, openXhr } from \"./HelperFuncs\";\r\nvar STR_EMPTY = \"\";\r\nvar STR_NO_RESPONSE_BODY = \"NoResponseBody\";\r\nvar _noResponseQs = \"&\" + STR_NO_RESPONSE_BODY + \"=true\";\r\nvar STR_POST_METHOD = \"POST\";\r\n/**\r\n * This Internal component\r\n * Manager SendPost functions\r\n * SendPostManger\r\n * @internal for internal use only\r\n */\r\nvar SenderPostManager = /** @class */ (function () {\r\n    function SenderPostManager() {\r\n        var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)\r\n        var _enableSendPromise;\r\n        var _isInitialized;\r\n        var _diagLog;\r\n        var _isOneDs;\r\n        var _onCompleteFuncs;\r\n        var _disableCredentials;\r\n        var _fetchCredentials;\r\n        var _fallbackInst;\r\n        var _disableXhr;\r\n        var _disableBeacon;\r\n        var _disableBeaconSync;\r\n        var _disableFetchKeepAlive;\r\n        var _addNoResponse;\r\n        var _timeoutWrapper;\r\n        dynamicProto(SenderPostManager, this, function (_self, _base) {\r\n            var _sendCredentials = true; // for 1ds\r\n            _initDefaults();\r\n            _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, diagLog) {\r\n                _diagLog = diagLog;\r\n                if (_isInitialized) {\r\n                    _throwInternal(_diagLog, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender is already initialized\");\r\n                }\r\n                _self.SetConfig(config);\r\n                _isInitialized = true;\r\n            };\r\n            _self[\"_getDbgPlgTargets\"] = function () {\r\n                return [_isInitialized, _isOneDs, _disableCredentials, _enableSendPromise];\r\n            };\r\n            // This componet might get its config from sender, offline sender, 1ds post\r\n            // so set this function to mock dynamic changes\r\n            _self.SetConfig = function (config) {\r\n                try {\r\n                    _onCompleteFuncs = config.senderOnCompleteCallBack || {};\r\n                    _disableCredentials = !!config.disableCredentials;\r\n                    _fetchCredentials = config.fetchCredentials;\r\n                    _isOneDs = !!config.isOneDs;\r\n                    _enableSendPromise = !!config.enableSendPromise;\r\n                    _disableXhr = !!config.disableXhr;\r\n                    _disableBeacon = !!config.disableBeacon;\r\n                    _disableBeaconSync = !!config.disableBeaconSync;\r\n                    _timeoutWrapper = config.timeWrapper;\r\n                    _addNoResponse = !!config.addNoResponse;\r\n                    _disableFetchKeepAlive = !!config.disableFetchKeepAlive;\r\n                    _fallbackInst = { sendPOST: _xhrSender };\r\n                    if (!_isOneDs) {\r\n                        _sendCredentials = false; // for appInsights, set it to false always\r\n                    }\r\n                    if (_disableCredentials) {\r\n                        var location_1 = getLocation();\r\n                        if (location_1 && location_1.protocol && location_1.protocol[_DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]() === \"file:\") {\r\n                            // Special case where a local html file fails with a CORS error on Chromium browsers\r\n                            _sendCredentials = false;\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n                catch (e) {\r\n                    // eslint-disable-next-line no-empty\r\n                }\r\n                return false;\r\n            };\r\n            _self.getSyncFetchPayload = function () {\r\n                return _syncFetchPayload;\r\n            };\r\n            _self.getSenderInst = function (transports, sync) {\r\n                if (transports && transports[_DYN_LENGTH /* @min:%2elength */]) {\r\n                    return _getSenderInterface(transports, sync);\r\n                }\r\n                return null;\r\n            };\r\n            _self.getFallbackInst = function () {\r\n                return _fallbackInst;\r\n            };\r\n            _self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] = function (unloadCtx, unloadState) {\r\n                _initDefaults();\r\n            };\r\n            /**\r\n             * success handler\r\n             */\r\n            function _onSuccess(res, onComplete) {\r\n                _doOnComplete(onComplete, 200, {}, res);\r\n            }\r\n            /**\r\n             * error handler\r\n             */\r\n            function _onError(message, onComplete) {\r\n                _throwInternal(_diagLog, 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, \"Failed to send telemetry.\", { message: message });\r\n                _doOnComplete(onComplete, 400, {});\r\n            }\r\n            function _onNoPayloadUrl(onComplete) {\r\n                _onError(\"No endpoint url is provided for the batch\", onComplete);\r\n            }\r\n            function _getSenderInterface(transports, syncSupport) {\r\n                var _a;\r\n                var transportType = 0 /* TransportType.NotSet */;\r\n                var sendPostFunc = null;\r\n                var lp = 0;\r\n                while (sendPostFunc == null && lp < transports[_DYN_LENGTH /* @min:%2elength */]) {\r\n                    transportType = transports[lp];\r\n                    if (!_disableXhr && transportType === 1 /* TransportType.Xhr */) {\r\n                        if (useXDomainRequest()) {\r\n                            // IE 8 and 9\r\n                            sendPostFunc = _xdrSender;\r\n                        }\r\n                        else if (isXhrSupported()) {\r\n                            sendPostFunc = _xhrSender;\r\n                        }\r\n                    }\r\n                    else if (transportType === 2 /* TransportType.Fetch */ && isFetchSupported(syncSupport) && (!syncSupport || !_disableFetchKeepAlive)) {\r\n                        sendPostFunc = _doFetchSender;\r\n                    }\r\n                    else if (transportType === 3 /* TransportType.Beacon */ && isBeaconsSupported() && (syncSupport ? !_disableBeaconSync : !_disableBeacon)) {\r\n                        sendPostFunc = _beaconSender;\r\n                    }\r\n                    lp++;\r\n                }\r\n                if (sendPostFunc) {\r\n                    return _a = {\r\n                            _transport: transportType,\r\n                            _isSync: syncSupport\r\n                        },\r\n                        _a[_DYN_SEND_POST /* @min:sendPOST */] = sendPostFunc,\r\n                        _a;\r\n                }\r\n                return null;\r\n            }\r\n            function _doOnComplete(oncomplete, status, headers, response) {\r\n                try {\r\n                    oncomplete && oncomplete(status, headers, response);\r\n                }\r\n                catch (e) {\r\n                    // eslint-disable-next-line no-empty\r\n                }\r\n            }\r\n            function _doBeaconSend(payload, oncomplete) {\r\n                var nav = getNavigator();\r\n                var url = payload[_DYN_URL_STRING /* @min:%2eurlString */];\r\n                if (!url) {\r\n                    _onNoPayloadUrl(oncomplete);\r\n                    // return true here, because we don't want to retry it with fallback sender\r\n                    return true;\r\n                }\r\n                url = payload[_DYN_URL_STRING /* @min:%2eurlString */] + (_addNoResponse ? _noResponseQs : STR_EMPTY);\r\n                var data = payload[_DYN_DATA /* @min:%2edata */];\r\n                // Chrome only allows CORS-safelisted values for the sendBeacon data argument\r\n                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283\r\n                // Chrome only allows CORS-safelisted values for the sendBeacon data argument\r\n                // see: https://bugs.chromium.org/p/chromium/issues/detail?id=720283\r\n                var plainTextBatch = _isOneDs ? data : new Blob([data], { type: \"text/plain;charset=UTF-8\" });\r\n                // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\r\n                var queued = nav.sendBeacon(url, plainTextBatch);\r\n                return queued;\r\n            }\r\n            /**\r\n             * Send Beacon API request\r\n             * @param payload - {string} - The data payload to be sent.\r\n             * @param sync - {boolean} - not used\r\n             * Note: Beacon API does not support custom headers and we are not able to get\r\n             * appId from the backend for the correct correlation.\r\n             */\r\n            function _beaconSender(payload, oncomplete, sync) {\r\n                var data = payload[_DYN_DATA /* @min:%2edata */];\r\n                try {\r\n                    if (data) {\r\n                        // The sendBeacon method returns true if the user agent is able to successfully queue the data for transfer. Otherwise it returns false.\r\n                        if (!_doBeaconSend(payload, oncomplete)) {\r\n                            var onRetry = _onCompleteFuncs && _onCompleteFuncs.beaconOnRetry;\r\n                            if (onRetry && isFunction(onRetry)) {\r\n                                onRetry(payload, oncomplete, _doBeaconSend);\r\n                            }\r\n                            else {\r\n                                _fallbackInst && _fallbackInst[_DYN_SEND_POST /* @min:%2esendPOST */](payload, oncomplete, true);\r\n                                _throwInternal(_diagLog, 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\r\n                            }\r\n                        }\r\n                        else {\r\n                            // if can send\r\n                            _onSuccess(STR_EMPTY, oncomplete);\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    _isOneDs && _warnToConsole(_diagLog, \"Failed to send telemetry using sendBeacon API. Ex:\" + dumpObj(e));\r\n                    _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, STR_EMPTY);\r\n                }\r\n                return;\r\n            }\r\n            /**\r\n             * Send XMLHttpRequest\r\n             * @param payload - {string} - The data payload to be sent.\r\n             * @param sync - {boolean} - Indicates if the request should be sent synchronously\r\n             */\r\n            function _xhrSender(payload, oncomplete, sync) {\r\n                //let  internalPayload = payload as IInternalPayloadData;\r\n                var thePromise;\r\n                var resolveFunc;\r\n                var rejectFunc;\r\n                var headers = payload[_DYN_HEADERS /* @min:%2eheaders */] || {};\r\n                if (!sync && _enableSendPromise) {\r\n                    thePromise = createPromise(function (resolve, reject) {\r\n                        resolveFunc = resolve;\r\n                        rejectFunc = reject;\r\n                    });\r\n                }\r\n                if (_isOneDs && sync && payload.disableXhrSync) {\r\n                    sync = false;\r\n                }\r\n                //const xhr = new XMLHttpRequest();\r\n                var endPointUrl = payload[_DYN_URL_STRING /* @min:%2eurlString */];\r\n                if (!endPointUrl) {\r\n                    _onNoPayloadUrl(oncomplete);\r\n                    resolveFunc && resolveFunc(false);\r\n                    return;\r\n                }\r\n                var xhr = openXhr(STR_POST_METHOD, endPointUrl, _sendCredentials, true, sync, payload[_DYN_TIMEOUT /* @min:%2etimeout */]);\r\n                if (!_isOneDs) {\r\n                    // application/json should NOT add to 1ds post by default\r\n                    xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](\"Content-type\", \"application/json\");\r\n                }\r\n                arrForEach(objKeys(headers), function (headerName) {\r\n                    xhr[_DYN_SET_REQUEST_HEADER /* @min:%2esetRequestHeader */](headerName, headers[headerName]);\r\n                });\r\n                xhr.onreadystatechange = function () {\r\n                    if (!_isOneDs) {\r\n                        _doOnReadyFunc(xhr);\r\n                        if (xhr.readyState === 4) {\r\n                            resolveFunc && resolveFunc(true);\r\n                        }\r\n                    }\r\n                };\r\n                xhr.onload = function () {\r\n                    if (_isOneDs) {\r\n                        _doOnReadyFunc(xhr);\r\n                    }\r\n                };\r\n                function _doOnReadyFunc(xhr) {\r\n                    var onReadyFunc = _onCompleteFuncs && _onCompleteFuncs.xhrOnComplete;\r\n                    var onReadyFuncExist = onReadyFunc && isFunction(onReadyFunc);\r\n                    if (onReadyFuncExist) {\r\n                        onReadyFunc(xhr, oncomplete, payload);\r\n                    }\r\n                    else {\r\n                        var response = getResponseText(xhr);\r\n                        _doOnComplete(oncomplete, xhr[_DYN_STATUS /* @min:%2estatus */], _getAllResponseHeaders(xhr, _isOneDs), response);\r\n                    }\r\n                }\r\n                xhr.onerror = function (event) {\r\n                    _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS /* @min:%2estatus */] : 400, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr));\r\n                    rejectFunc && rejectFunc(event);\r\n                };\r\n                xhr.ontimeout = function () {\r\n                    _doOnComplete(oncomplete, _isOneDs ? xhr[_DYN_STATUS /* @min:%2estatus */] : 500, _getAllResponseHeaders(xhr, _isOneDs), _isOneDs ? STR_EMPTY : formatErrorMessageXhr(xhr));\r\n                    resolveFunc && resolveFunc(false);\r\n                };\r\n                xhr.send(payload[_DYN_DATA /* @min:%2edata */]);\r\n                return thePromise;\r\n            }\r\n            /**\r\n             * Send fetch API request\r\n             * @param payload - {string} - The data payload to be sent.\r\n             * @param sync - {boolean} - For fetch this identifies whether we are \"unloading\" (false) or a normal request\r\n             */\r\n            function _doFetchSender(payload, oncomplete, sync) {\r\n                var _a;\r\n                var endPointUrl = payload[_DYN_URL_STRING /* @min:%2eurlString */];\r\n                var batch = payload[_DYN_DATA /* @min:%2edata */];\r\n                var plainTextBatch = _isOneDs ? batch : new Blob([batch], { type: \"application/json\" });\r\n                var thePromise;\r\n                var resolveFunc;\r\n                var rejectFunc;\r\n                var requestHeaders = new Headers();\r\n                var batchLength = batch[_DYN_LENGTH /* @min:%2elength */];\r\n                var ignoreResponse = false;\r\n                var responseHandled = false;\r\n                var headers = payload[_DYN_HEADERS /* @min:%2eheaders */] || {};\r\n                //TODO: handle time out for 1ds\r\n                var init = (_a = {\r\n                        method: STR_POST_METHOD,\r\n                        body: plainTextBatch\r\n                    },\r\n                    _a[DisabledPropertyName] = true // Mark so we don't attempt to track this request\r\n                ,\r\n                    _a);\r\n                // Only add headers if there are headers to add, due to issue with some polyfills\r\n                if (payload.headers && objKeys(payload.headers)[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    arrForEach(objKeys(headers), function (headerName) {\r\n                        requestHeaders.append(headerName, headers[headerName]);\r\n                    });\r\n                    init[_DYN_HEADERS /* @min:%2eheaders */] = requestHeaders;\r\n                }\r\n                if (_fetchCredentials) { // if user passed in this value via post channel (1ds), then use it\r\n                    init.credentials = _fetchCredentials;\r\n                }\r\n                else if (_sendCredentials && _isOneDs) {\r\n                    // for 1ds, Don't send credentials when URL is file://\r\n                    init.credentials = \"include\";\r\n                }\r\n                if (sync) {\r\n                    init.keepalive = true;\r\n                    _syncFetchPayload += batchLength;\r\n                    if (_isOneDs) {\r\n                        if (payload[\"_sendReason\"] === 2 /* SendRequestReason.Unload */) {\r\n                            // As a sync request (during unload), it is unlikely that we will get a chance to process the response so\r\n                            // just like beacon send assume that the events have been accepted and processed\r\n                            ignoreResponse = true;\r\n                            if (_addNoResponse) {\r\n                                endPointUrl += _noResponseQs;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // for appinsights, set to true for all sync request\r\n                        ignoreResponse = true;\r\n                    }\r\n                }\r\n                var request = new Request(endPointUrl, init);\r\n                try {\r\n                    // Also try and tag the request (just in case the value in init is not copied over)\r\n                    request[DisabledPropertyName] = true;\r\n                }\r\n                catch (e) {\r\n                    // If the environment has locked down the XMLHttpRequest (preventExtensions and/or freeze), this would\r\n                    // cause the request to fail and we no telemetry would be sent\r\n                }\r\n                if (!sync && _enableSendPromise) {\r\n                    thePromise = createPromise(function (resolve, reject) {\r\n                        resolveFunc = resolve;\r\n                        rejectFunc = reject;\r\n                    });\r\n                }\r\n                if (!endPointUrl) {\r\n                    _onNoPayloadUrl(oncomplete);\r\n                    resolveFunc && resolveFunc(false);\r\n                    return;\r\n                }\r\n                function _handleError(res) {\r\n                    // In case there is an error in the request. Set the status to 0 for 1ds and 400 for appInsights\r\n                    // so that the events can be retried later.\r\n                    _doOnComplete(oncomplete, _isOneDs ? 0 : 400, {}, _isOneDs ? STR_EMPTY : res);\r\n                }\r\n                function _onFetchComplete(response, payload, value) {\r\n                    var status = response[_DYN_STATUS /* @min:%2estatus */];\r\n                    var onCompleteFunc = _onCompleteFuncs.fetchOnComplete;\r\n                    if (onCompleteFunc && isFunction(onCompleteFunc)) {\r\n                        onCompleteFunc(response, oncomplete, value || STR_EMPTY, payload);\r\n                    }\r\n                    else {\r\n                        _doOnComplete(oncomplete, status, {}, value || STR_EMPTY);\r\n                    }\r\n                }\r\n                try {\r\n                    doAwaitResponse(fetch(_isOneDs ? endPointUrl : request, _isOneDs ? init : null), function (result) {\r\n                        if (sync) {\r\n                            _syncFetchPayload -= batchLength;\r\n                            batchLength = 0;\r\n                        }\r\n                        if (!responseHandled) {\r\n                            responseHandled = true;\r\n                            if (!result.rejected) {\r\n                                var response_1 = result[_DYN_VALUE /* @min:%2evalue */];\r\n                                try {\r\n                                    /**\r\n                                     * The Promise returned from fetch() won’t reject on HTTP error status even if the response is an HTTP 404 or 500.\r\n                                     * Instead, it will resolve normally (with ok status set to false), and it will only reject on network failure\r\n                                     * or if anything prevented the request from completing.\r\n                                     */\r\n                                    if (!_isOneDs && !response_1.ok) {\r\n                                        // this is for appInsights only\r\n                                        _handleError(response_1.statusText);\r\n                                        resolveFunc && resolveFunc(false);\r\n                                    }\r\n                                    else {\r\n                                        if (_isOneDs && !response_1.body) {\r\n                                            _onFetchComplete(response_1, null, STR_EMPTY);\r\n                                            resolveFunc && resolveFunc(true);\r\n                                        }\r\n                                        else {\r\n                                            doAwaitResponse(response_1.text(), function (resp) {\r\n                                                _onFetchComplete(response_1, payload, resp[_DYN_VALUE /* @min:%2evalue */]);\r\n                                                resolveFunc && resolveFunc(true);\r\n                                            });\r\n                                        }\r\n                                    }\r\n                                }\r\n                                catch (e) {\r\n                                    _handleError(dumpObj(e));\r\n                                    rejectFunc && rejectFunc(e);\r\n                                }\r\n                            }\r\n                            else {\r\n                                _handleError(result.reason && result.reason[_DYN_MESSAGE /* @min:%2emessage */]);\r\n                                rejectFunc && rejectFunc(result.reason);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    if (!responseHandled) {\r\n                        _handleError(dumpObj(e));\r\n                        rejectFunc && rejectFunc(e);\r\n                    }\r\n                }\r\n                if (ignoreResponse && !responseHandled) {\r\n                    // Assume success during unload processing as we most likely won't get the response\r\n                    responseHandled = true;\r\n                    _doOnComplete(oncomplete, 200, {});\r\n                    resolveFunc && resolveFunc(true);\r\n                }\r\n                if (_isOneDs && !responseHandled && payload[_DYN_TIMEOUT /* @min:%2etimeout */] > 0) {\r\n                    // Simulate timeout\r\n                    _timeoutWrapper && _timeoutWrapper.set(function () {\r\n                        if (!responseHandled) {\r\n                            // Assume a 500 response (which will cause a retry)\r\n                            responseHandled = true;\r\n                            _doOnComplete(oncomplete, 500, {});\r\n                            resolveFunc && resolveFunc(true);\r\n                        }\r\n                    }, payload[_DYN_TIMEOUT /* @min:%2etimeout */]);\r\n                }\r\n                return thePromise;\r\n            }\r\n            /**\r\n             * Send XDomainRequest\r\n             * @param payload - {string} - The data payload to be sent.\r\n             * @param sync - {boolean} - Indicates if the request should be sent synchronously\r\n             *\r\n             * Note: XDomainRequest does not support sync requests. This 'isAsync' parameter is added\r\n             * to maintain consistency with the xhrSender's contract\r\n             * Note: XDomainRequest does not support custom headers and we are not able to get\r\n             * appId from the backend for the correct correlation.\r\n             */\r\n            function _xdrSender(payload, oncomplete, sync) {\r\n                // It doesn't support custom headers, so no action is taken with current requestHeaders\r\n                var _window = getWindow();\r\n                var xdr = new XDomainRequest();\r\n                var data = payload[_DYN_DATA /* @min:%2edata */];\r\n                xdr.onload = function () {\r\n                    var response = getResponseText(xdr);\r\n                    var onloadFunc = _onCompleteFuncs && _onCompleteFuncs.xdrOnComplete;\r\n                    if (onloadFunc && isFunction(onloadFunc)) {\r\n                        onloadFunc(xdr, oncomplete, payload);\r\n                    }\r\n                    else {\r\n                        _doOnComplete(oncomplete, 200, {}, response);\r\n                    }\r\n                };\r\n                xdr.onerror = function () {\r\n                    _doOnComplete(oncomplete, 400, {}, _isOneDs ? STR_EMPTY : formatErrorMessageXdr(xdr));\r\n                };\r\n                xdr.ontimeout = function () {\r\n                    _doOnComplete(oncomplete, 500, {});\r\n                };\r\n                xdr.onprogress = function () { };\r\n                // XDomainRequest requires the same protocol as the hosting page.\r\n                // If the protocol doesn't match, we can't send the telemetry :(.\r\n                var hostingProtocol = _window && _window.location && _window.location[_DYN_PROTOCOL /* @min:%2eprotocol */] || \"\";\r\n                var endpoint = payload[_DYN_URL_STRING /* @min:%2eurlString */];\r\n                if (!endpoint) {\r\n                    _onNoPayloadUrl(oncomplete);\r\n                    return;\r\n                }\r\n                if (!_isOneDs && endpoint.lastIndexOf(hostingProtocol, 0) !== 0) {\r\n                    var msg = \"Cannot send XDomain request. The endpoint URL protocol doesn't match the hosting page protocol.\";\r\n                    _throwInternal(_diagLog, 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + msg);\r\n                    _onError(msg, oncomplete);\r\n                    return;\r\n                }\r\n                var endpointUrl = _isOneDs ? endpoint : endpoint[_DYN_REPLACE /* @min:%2ereplace */](/^(https?:)/, \"\");\r\n                xdr.open(STR_POST_METHOD, endpointUrl);\r\n                if (payload[_DYN_TIMEOUT /* @min:%2etimeout */]) {\r\n                    xdr[_DYN_TIMEOUT /* @min:%2etimeout */] = payload[_DYN_TIMEOUT /* @min:%2etimeout */];\r\n                }\r\n                xdr.send(data);\r\n                if (_isOneDs && sync) {\r\n                    _timeoutWrapper && _timeoutWrapper.set(function () {\r\n                        xdr.send(data);\r\n                    }, 0);\r\n                }\r\n                else {\r\n                    xdr.send(data);\r\n                }\r\n            }\r\n            function _initDefaults() {\r\n                _syncFetchPayload = 0;\r\n                _isInitialized = false;\r\n                _enableSendPromise = false;\r\n                _diagLog = null;\r\n                _isOneDs = null;\r\n                _onCompleteFuncs = null;\r\n                _disableCredentials = null;\r\n                _fetchCredentials = null;\r\n                _fallbackInst = null;\r\n                _disableXhr = false;\r\n                _disableBeacon = false;\r\n                _disableBeaconSync = false;\r\n                _disableFetchKeepAlive = false;\r\n                _addNoResponse = false;\r\n                _timeoutWrapper = null;\r\n            }\r\n        });\r\n    }\r\n    SenderPostManager.prototype.initialize = function (config, diagLog) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Get size of current sync fetch payload\r\n     */\r\n    SenderPostManager.prototype.getSyncFetchPayload = function () {\r\n        // @DynamicProtoStub - DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * reset Config\r\n     * @returns True if set is successfully\r\n     */\r\n    SenderPostManager.prototype.SetConfig = function (config) {\r\n        // @DynamicProtoStub - DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Get current xhr instance\r\n     */\r\n    SenderPostManager.prototype.getSenderInst = function (transports, sync) {\r\n        // @DynamicProtoStub - DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Get current fallback sender instance\r\n     */\r\n    SenderPostManager.prototype.getFallbackInst = function () {\r\n        // @DynamicProtoStub - DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    SenderPostManager.prototype._doTeardown = function (unloadCtx, unloadState) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return SenderPostManager;\r\n}());\r\nexport { SenderPostManager };\r\n//# sourceMappingURL=SenderPostManager.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}