{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport { arrForEach, arrIndexOf, dumpObj, newSymbol, scheduleTimeout } from \"@nevware21/ts-utils\";\nimport { throwAggregationError } from \"../JavaScriptSDK/AggregationError\";\nimport { _DYN_BLK_VAL, _DYN_CANCEL, _DYN_HDLR, _DYN_LENGTH, _DYN_LOGGER, _DYN_NOTIFY, _DYN_PUSH, _DYN_RD_ONLY, _DYN_SET_DF, _DYN_THROW_INTERNAL } from \"../__DynamicConstants\";\nvar symPrefix = \"[[ai_\";\nvar symPostfix = \"]]\";\nexport function _createState(cfgHandler) {\n  var _a;\n  var dynamicPropertySymbol = newSymbol(symPrefix + \"get\" + cfgHandler.uid + symPostfix);\n  var dynamicPropertyReadOnly = newSymbol(symPrefix + \"ro\" + cfgHandler.uid + symPostfix);\n  var dynamicPropertyReferenced = newSymbol(symPrefix + \"rf\" + cfgHandler.uid + symPostfix);\n  var dynamicPropertyBlockValue = newSymbol(symPrefix + \"blkVal\" + cfgHandler.uid + symPostfix);\n  var dynamicPropertyDetail = newSymbol(symPrefix + \"dtl\" + cfgHandler.uid + symPostfix);\n  var _waitingHandlers = null;\n  var _watcherTimer = null;\n  var theState;\n  function _useHandler(activeHandler, callback) {\n    var prevWatcher = theState.act;\n    try {\n      theState.act = activeHandler;\n      if (activeHandler && activeHandler[dynamicPropertyDetail]) {\n        // Clear out the previously tracked details for this handler, so that access are re-evaluated\n        arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {\n          detail.clr(activeHandler);\n        });\n        activeHandler[dynamicPropertyDetail] = [];\n      }\n      callback({\n        cfg: cfgHandler.cfg,\n        set: cfgHandler.set.bind(cfgHandler),\n        setDf: cfgHandler[_DYN_SET_DF /* @min:%2esetDf */].bind(cfgHandler),\n        ref: cfgHandler.ref.bind(cfgHandler),\n        rdOnly: cfgHandler[_DYN_RD_ONLY /* @min:%2erdOnly */].bind(cfgHandler)\n      });\n    } catch (e) {\n      var logger = cfgHandler[_DYN_LOGGER /* @min:%2elogger */];\n      if (logger) {\n        // Don't let one individual failure break everyone\n        logger[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](1 /* eLoggingSeverity.CRITICAL */, 107 /* _eInternalMessageId.ConfigWatcherException */, dumpObj(e));\n      }\n      // Re-throw the exception so that any true \"error\" is reported back to the called\n      throw e;\n    } finally {\n      theState.act = prevWatcher || null;\n    }\n  }\n  function _notifyWatchers() {\n    if (_waitingHandlers) {\n      var notifyHandlers = _waitingHandlers;\n      _waitingHandlers = null;\n      // Stop any timer as we are running them now anyway\n      _watcherTimer && _watcherTimer[_DYN_CANCEL /* @min:%2ecancel */]();\n      _watcherTimer = null;\n      var watcherFailures_1 = [];\n      // Now run the handlers\n      arrForEach(notifyHandlers, function (handler) {\n        if (handler) {\n          if (handler[dynamicPropertyDetail]) {\n            arrForEach(handler[dynamicPropertyDetail], function (detail) {\n              // Clear out this handler from  previously tracked details, so that access are re-evaluated\n              detail.clr(handler);\n            });\n            handler[dynamicPropertyDetail] = null;\n          }\n          // The handler may have self removed as part of another handler so re-check\n          if (handler.fn) {\n            try {\n              _useHandler(handler, handler.fn);\n            } catch (e) {\n              // Don't let a single failing watcher cause other watches to fail\n              watcherFailures_1[_DYN_PUSH /* @min:%2epush */](e);\n            }\n          }\n        }\n      });\n      // During notification we may have had additional updates -- so notify those updates as well\n      if (_waitingHandlers) {\n        try {\n          _notifyWatchers();\n        } catch (e) {\n          watcherFailures_1[_DYN_PUSH /* @min:%2epush */](e);\n        }\n      }\n      if (watcherFailures_1[_DYN_LENGTH /* @min:%2elength */] > 0) {\n        throwAggregationError(\"Watcher error(s): \", watcherFailures_1);\n      }\n    }\n  }\n  function _addWatcher(detail) {\n    if (detail && detail.h[_DYN_LENGTH /* @min:%2elength */] > 0) {\n      if (!_waitingHandlers) {\n        _waitingHandlers = [];\n      }\n      if (!_watcherTimer) {\n        _watcherTimer = scheduleTimeout(function () {\n          _watcherTimer = null;\n          _notifyWatchers();\n        }, 0);\n      }\n      // Add all of the handlers for this detail (if not already present) - using normal for-loop for performance\n      for (var idx = 0; idx < detail.h[_DYN_LENGTH /* @min:%2elength */]; idx++) {\n        var handler = detail.h[idx];\n        // Add this handler to the collection of handlers to re-execute\n        if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {\n          _waitingHandlers[_DYN_PUSH /* @min:%2epush */](handler);\n        }\n      }\n    }\n  }\n  function _trackHandler(handler, detail) {\n    if (handler) {\n      var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];\n      if (arrIndexOf(details, detail) === -1) {\n        // If this detail is not already listed as tracked then add it so that we re-evaluate it's usage\n        details[_DYN_PUSH /* @min:%2epush */](detail);\n      }\n    }\n  }\n  theState = (_a = {\n    prop: dynamicPropertySymbol,\n    ro: dynamicPropertyReadOnly,\n    rf: dynamicPropertyReferenced\n  }, _a[_DYN_BLK_VAL /* @min:blkVal */] = dynamicPropertyBlockValue, _a[_DYN_HDLR /* @min:hdlr */] = cfgHandler, _a.add = _addWatcher, _a[_DYN_NOTIFY /* @min:notify */] = _notifyWatchers, _a.use = _useHandler, _a.trk = _trackHandler, _a);\n  return theState;\n}","map":{"version":3,"names":["arrForEach","arrIndexOf","dumpObj","newSymbol","scheduleTimeout","throwAggregationError","_DYN_BLK_VAL","_DYN_CANCEL","_DYN_HDLR","_DYN_LENGTH","_DYN_LOGGER","_DYN_NOTIFY","_DYN_PUSH","_DYN_RD_ONLY","_DYN_SET_DF","_DYN_THROW_INTERNAL","symPrefix","symPostfix","_createState","cfgHandler","_a","dynamicPropertySymbol","uid","dynamicPropertyReadOnly","dynamicPropertyReferenced","dynamicPropertyBlockValue","dynamicPropertyDetail","_waitingHandlers","_watcherTimer","theState","_useHandler","activeHandler","callback","prevWatcher","act","detail","clr","cfg","set","bind","setDf","ref","rdOnly","e","logger","_notifyWatchers","notifyHandlers","watcherFailures_1","handler","fn","_addWatcher","h","idx","_trackHandler","details","prop","ro","rf","add","use","trk"],"sources":["/home/veeresh133/app/api-call/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/Config/DynamicState.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { arrForEach, arrIndexOf, dumpObj, newSymbol, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { throwAggregationError } from \"../JavaScriptSDK/AggregationError\";\r\nimport { _DYN_BLK_VAL, _DYN_CANCEL, _DYN_HDLR, _DYN_LENGTH, _DYN_LOGGER, _DYN_NOTIFY, _DYN_PUSH, _DYN_RD_ONLY, _DYN_SET_DF, _DYN_THROW_INTERNAL } from \"../__DynamicConstants\";\r\nvar symPrefix = \"[[ai_\";\r\nvar symPostfix = \"]]\";\r\nexport function _createState(cfgHandler) {\r\n    var _a;\r\n    var dynamicPropertySymbol = newSymbol(symPrefix + \"get\" + cfgHandler.uid + symPostfix);\r\n    var dynamicPropertyReadOnly = newSymbol(symPrefix + \"ro\" + cfgHandler.uid + symPostfix);\r\n    var dynamicPropertyReferenced = newSymbol(symPrefix + \"rf\" + cfgHandler.uid + symPostfix);\r\n    var dynamicPropertyBlockValue = newSymbol(symPrefix + \"blkVal\" + cfgHandler.uid + symPostfix);\r\n    var dynamicPropertyDetail = newSymbol(symPrefix + \"dtl\" + cfgHandler.uid + symPostfix);\r\n    var _waitingHandlers = null;\r\n    var _watcherTimer = null;\r\n    var theState;\r\n    function _useHandler(activeHandler, callback) {\r\n        var prevWatcher = theState.act;\r\n        try {\r\n            theState.act = activeHandler;\r\n            if (activeHandler && activeHandler[dynamicPropertyDetail]) {\r\n                // Clear out the previously tracked details for this handler, so that access are re-evaluated\r\n                arrForEach(activeHandler[dynamicPropertyDetail], function (detail) {\r\n                    detail.clr(activeHandler);\r\n                });\r\n                activeHandler[dynamicPropertyDetail] = [];\r\n            }\r\n            callback({\r\n                cfg: cfgHandler.cfg,\r\n                set: cfgHandler.set.bind(cfgHandler),\r\n                setDf: cfgHandler[_DYN_SET_DF /* @min:%2esetDf */].bind(cfgHandler),\r\n                ref: cfgHandler.ref.bind(cfgHandler),\r\n                rdOnly: cfgHandler[_DYN_RD_ONLY /* @min:%2erdOnly */].bind(cfgHandler)\r\n            });\r\n        }\r\n        catch (e) {\r\n            var logger = cfgHandler[_DYN_LOGGER /* @min:%2elogger */];\r\n            if (logger) {\r\n                // Don't let one individual failure break everyone\r\n                logger[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](1 /* eLoggingSeverity.CRITICAL */, 107 /* _eInternalMessageId.ConfigWatcherException */, dumpObj(e));\r\n            }\r\n            // Re-throw the exception so that any true \"error\" is reported back to the called\r\n            throw e;\r\n        }\r\n        finally {\r\n            theState.act = prevWatcher || null;\r\n        }\r\n    }\r\n    function _notifyWatchers() {\r\n        if (_waitingHandlers) {\r\n            var notifyHandlers = _waitingHandlers;\r\n            _waitingHandlers = null;\r\n            // Stop any timer as we are running them now anyway\r\n            _watcherTimer && _watcherTimer[_DYN_CANCEL /* @min:%2ecancel */]();\r\n            _watcherTimer = null;\r\n            var watcherFailures_1 = [];\r\n            // Now run the handlers\r\n            arrForEach(notifyHandlers, function (handler) {\r\n                if (handler) {\r\n                    if (handler[dynamicPropertyDetail]) {\r\n                        arrForEach(handler[dynamicPropertyDetail], function (detail) {\r\n                            // Clear out this handler from  previously tracked details, so that access are re-evaluated\r\n                            detail.clr(handler);\r\n                        });\r\n                        handler[dynamicPropertyDetail] = null;\r\n                    }\r\n                    // The handler may have self removed as part of another handler so re-check\r\n                    if (handler.fn) {\r\n                        try {\r\n                            _useHandler(handler, handler.fn);\r\n                        }\r\n                        catch (e) {\r\n                            // Don't let a single failing watcher cause other watches to fail\r\n                            watcherFailures_1[_DYN_PUSH /* @min:%2epush */](e);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            // During notification we may have had additional updates -- so notify those updates as well\r\n            if (_waitingHandlers) {\r\n                try {\r\n                    _notifyWatchers();\r\n                }\r\n                catch (e) {\r\n                    watcherFailures_1[_DYN_PUSH /* @min:%2epush */](e);\r\n                }\r\n            }\r\n            if (watcherFailures_1[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                throwAggregationError(\"Watcher error(s): \", watcherFailures_1);\r\n            }\r\n        }\r\n    }\r\n    function _addWatcher(detail) {\r\n        if (detail && detail.h[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n            if (!_waitingHandlers) {\r\n                _waitingHandlers = [];\r\n            }\r\n            if (!_watcherTimer) {\r\n                _watcherTimer = scheduleTimeout(function () {\r\n                    _watcherTimer = null;\r\n                    _notifyWatchers();\r\n                }, 0);\r\n            }\r\n            // Add all of the handlers for this detail (if not already present) - using normal for-loop for performance\r\n            for (var idx = 0; idx < detail.h[_DYN_LENGTH /* @min:%2elength */]; idx++) {\r\n                var handler = detail.h[idx];\r\n                // Add this handler to the collection of handlers to re-execute\r\n                if (handler && arrIndexOf(_waitingHandlers, handler) === -1) {\r\n                    _waitingHandlers[_DYN_PUSH /* @min:%2epush */](handler);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function _trackHandler(handler, detail) {\r\n        if (handler) {\r\n            var details = handler[dynamicPropertyDetail] = handler[dynamicPropertyDetail] || [];\r\n            if (arrIndexOf(details, detail) === -1) {\r\n                // If this detail is not already listed as tracked then add it so that we re-evaluate it's usage\r\n                details[_DYN_PUSH /* @min:%2epush */](detail);\r\n            }\r\n        }\r\n    }\r\n    theState = (_a = {\r\n            prop: dynamicPropertySymbol,\r\n            ro: dynamicPropertyReadOnly,\r\n            rf: dynamicPropertyReferenced\r\n        },\r\n        _a[_DYN_BLK_VAL /* @min:blkVal */] = dynamicPropertyBlockValue,\r\n        _a[_DYN_HDLR /* @min:hdlr */] = cfgHandler,\r\n        _a.add = _addWatcher,\r\n        _a[_DYN_NOTIFY /* @min:notify */] = _notifyWatchers,\r\n        _a.use = _useHandler,\r\n        _a.trk = _trackHandler,\r\n        _a);\r\n    return theState;\r\n}\r\n//# sourceMappingURL=DynamicState.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}