{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Channel, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nvar _a, _b;\nimport { __assignFn as __assign, __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { BreezeChannelIdentifier, DEFAULT_BREEZE_ENDPOINT, DEFAULT_BREEZE_PATH, Event, Exception, Metric, PageView, PageViewPerformance, ProcessLegacy, RemoteDependencyData, RequestHeaders, SampleRate, Trace, createOfflineListener, isInternalApplicationInsightsEndpoint, utlCanUseSessionStorage, utlSetStoragePrefix } from \"@microsoft/applicationinsights-common\";\nimport { ActiveStatus, BaseTelemetryPlugin, SenderPostManager, _throwInternal, _warnToConsole, arrForEach, cfgDfBoolean, cfgDfValidate, createProcessTelemetryContext, createUniqueNamespace, dateNow, dumpObj, formatErrorMessageXdr, formatErrorMessageXhr, getExceptionName, getIEVersion, isArray, isBeaconsSupported, isFetchSupported, isNullOrUndefined, mergeEvtNamespace, objExtend, onConfigChange, parseResponse, prependTransports, runTargetUnload } from \"@microsoft/applicationinsights-core-js\";\nimport { isNumber, isString, isTruthy, objDeepFreeze, objDefine, scheduleTimeout } from \"@nevware21/ts-utils\";\nimport { DependencyEnvelopeCreator, EventEnvelopeCreator, ExceptionEnvelopeCreator, MetricEnvelopeCreator, PageViewEnvelopeCreator, PageViewPerformanceEnvelopeCreator, TraceEnvelopeCreator } from \"./EnvelopeCreator\";\nimport { ArraySendBuffer, SessionStorageSendBuffer } from \"./SendBuffer\";\nimport { Serializer } from \"./Serializer\";\nimport { Sample } from \"./TelemetryProcessors/Sample\";\nimport { _DYN_ALWAYS_USE_XHR_OVERR4, _DYN_BASE_TYPE, _DYN_BUFFER_OVERRIDE, _DYN_CLEAR, _DYN_CLEAR_SENT, _DYN_CONVERT_UNDEFINED, _DYN_COUNT, _DYN_CREATE_NEW, _DYN_CUSTOM_HEADERS, _DYN_DATA, _DYN_DIAG_LOG, _DYN_DISABLE_SEND_BEACON_7, _DYN_DISABLE_XHR, _DYN_EMIT_LINE_DELIMITED_0, _DYN_ENABLE_SEND_PROMISE, _DYN_ENABLE_SESSION_STORA5, _DYN_ENQUEUE, _DYN_EVENTS_LIMIT_IN_MEM, _DYN_EVENTS_SEND_REQUEST, _DYN_GET_SENDER_INST, _DYN_INITIALIZE, _DYN_INSTRUMENTATION_KEY, _DYN_IS_BEACON_API_DISABL3, _DYN_ITEM, _DYN_ITEMS_ACCEPTED, _DYN_ITEMS_RECEIVED, _DYN_LENGTH, _DYN_MARK_AS_SENT, _DYN_MAX_BATCH_INTERVAL, _DYN_MAX_BATCH_SIZE_IN_BY1, _DYN_ONUNLOAD_DISABLE_BEA2, _DYN_ONUNLOAD_DISABLE_FET6, _DYN_ORI_PAYLOAD, _DYN_PUSH, _DYN_SAMPLE_RATE, _DYN_SERIALIZE, _DYN_TAGS, _DYN_TRIGGER_SEND, _DYN_UNLOAD_TRANSPORTS, _DYN__BUFFER, _DYN__ON_ERROR, _DYN__ON_PARTIAL_SUCCESS, _DYN__ON_SUCCESS, _DYN__SENDER } from \"./__DynamicConstants\";\nvar UNDEFINED_VALUE = undefined;\nvar EMPTY_STR = \"\";\nvar FetchSyncRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)\nfunction _getResponseText(xhr) {\n  try {\n    return xhr.responseText;\n  } catch (e) {\n    // Best effort, as XHR may throw while XDR wont so just ignore\n  }\n  return null;\n}\nfunction isOverrideFn(httpXHROverride) {\n  return httpXHROverride && httpXHROverride.sendPOST;\n}\nvar defaultAppInsightsChannelConfig = objDeepFreeze((_a = {\n  // Use the default value (handles empty string in the configuration)\n  endpointUrl: cfgDfValidate(isTruthy, DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH)\n}, _a[_DYN_EMIT_LINE_DELIMITED_0 /* @min:emitLineDelimitedJson */] = cfgDfBoolean(), _a[_DYN_MAX_BATCH_INTERVAL /* @min:maxBatchInterval */] = 15000, _a[_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:maxBatchSizeInBytes */] = 102400, _a.disableTelemetry = cfgDfBoolean(), _a[_DYN_ENABLE_SESSION_STORA5 /* @min:enableSessionStorageBuffer */] = cfgDfBoolean(true), _a.isRetryDisabled = cfgDfBoolean(), _a[_DYN_IS_BEACON_API_DISABL3 /* @min:isBeaconApiDisabled */] = cfgDfBoolean(true), _a[_DYN_DISABLE_SEND_BEACON_7 /* @min:disableSendBeaconSplit */] = cfgDfBoolean(true), _a[_DYN_DISABLE_XHR /* @min:disableXhr */] = cfgDfBoolean(), _a[_DYN_ONUNLOAD_DISABLE_FET6 /* @min:onunloadDisableFetch */] = cfgDfBoolean(), _a[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:onunloadDisableBeacon */] = cfgDfBoolean(), _a[_DYN_INSTRUMENTATION_KEY /* @min:instrumentationKey */] = UNDEFINED_VALUE, _a.namePrefix = UNDEFINED_VALUE, _a.samplingPercentage = cfgDfValidate(_chkSampling, 100), _a[_DYN_CUSTOM_HEADERS /* @min:customHeaders */] = UNDEFINED_VALUE, _a[_DYN_CONVERT_UNDEFINED /* @min:convertUndefined */] = UNDEFINED_VALUE, _a[_DYN_EVENTS_LIMIT_IN_MEM /* @min:eventsLimitInMem */] = 10000, _a[_DYN_BUFFER_OVERRIDE /* @min:bufferOverride */] = false, _a.httpXHROverride = {\n  isVal: isOverrideFn,\n  v: UNDEFINED_VALUE\n}, _a[_DYN_ALWAYS_USE_XHR_OVERR4 /* @min:alwaysUseXhrOverride */] = cfgDfBoolean(), _a.transports = UNDEFINED_VALUE, _a.retryCodes = UNDEFINED_VALUE, _a.maxRetryCnt = {\n  isVal: isNumber,\n  v: 10\n}, _a));\nfunction _chkSampling(value) {\n  return !isNaN(value) && value > 0 && value <= 100;\n}\nvar EnvelopeTypeCreator = (_b = {}, _b[Event.dataType] = EventEnvelopeCreator, _b[Trace.dataType] = TraceEnvelopeCreator, _b[PageView.dataType] = PageViewEnvelopeCreator, _b[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator, _b[Exception.dataType] = ExceptionEnvelopeCreator, _b[Metric.dataType] = MetricEnvelopeCreator, _b[RemoteDependencyData.dataType] = DependencyEnvelopeCreator, _b);\nvar Sender = /** @class */function (_super) {\n  __extends(Sender, _super);\n  function Sender() {\n    var _this = _super.call(this) || this;\n    _this.priority = 1001;\n    _this.identifier = BreezeChannelIdentifier;\n    // Don't set the defaults here, set them in the _initDefaults() as this is also called during unload\n    var _consecutiveErrors; // How many times in a row a retryable error condition has occurred.\n    var _retryAt; // The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).\n    var _lastSend; // The time of the last send operation.\n    var _paused; // Flag indicating that the sending should be paused\n    var _timeoutHandle; // Handle to the timer for delayed sending of batches of data.\n    var _serializer;\n    var _stamp_specific_redirects;\n    var _headers;\n    var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)\n    var _syncUnloadSender; // The identified sender to use for the synchronous unload stage\n    var _offlineListener;\n    var _evtNamespace;\n    var _endpointUrl;\n    var _orgEndpointUrl;\n    var _maxBatchSizeInBytes;\n    var _beaconSupported;\n    var _beaconOnUnloadSupported;\n    var _beaconNormalSupported;\n    var _customHeaders;\n    var _disableTelemetry;\n    var _instrumentationKey;\n    var _convertUndefined;\n    var _isRetryDisabled;\n    var _maxBatchInterval;\n    var _sessionStorageUsed;\n    var _bufferOverrideUsed;\n    var _namePrefix;\n    var _enableSendPromise;\n    var _alwaysUseCustomSend;\n    var _disableXhr;\n    var _fetchKeepAlive;\n    var _xhrSend;\n    var _fallbackSend;\n    var _disableBeaconSplit;\n    var _sendPostMgr;\n    var _retryCodes;\n    dynamicProto(Sender, _this, function (_self, _base) {\n      _initDefaults();\n      _self.pause = function () {\n        _clearScheduledTimer();\n        _paused = true;\n      };\n      _self.resume = function () {\n        if (_paused) {\n          _paused = false;\n          _retryAt = null;\n          // flush if we have exceeded the max-size already\n          _checkMaxSize();\n          _setupTimer();\n        }\n      };\n      _self.flush = function (isAsync, callBack, sendReason) {\n        if (isAsync === void 0) {\n          isAsync = true;\n        }\n        if (!_paused) {\n          // Clear the normal schedule timer as we are going to try and flush ASAP\n          _clearScheduledTimer();\n          try {\n            return _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](isAsync, null, sendReason || 1 /* SendRequestReason.ManualFlush */);\n          } catch (e) {\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 22 /* _eInternalMessageId.FlushFailed */, \"flush failed, telemetry will not be collected: \" + getExceptionName(e), {\n              exception: dumpObj(e)\n            });\n          }\n        }\n      };\n      _self.onunloadFlush = function () {\n        if (!_paused) {\n          if (_beaconSupported || _alwaysUseCustomSend) {\n            try {\n              return _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, _doUnloadSend, 2 /* SendRequestReason.Unload */);\n            } catch (e) {\n              _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, \"failed to flush with beacon sender on page unload, telemetry will not be collected: \" + getExceptionName(e), {\n                exception: dumpObj(e)\n              });\n            }\n          } else {\n            _self.flush(false);\n          }\n        }\n      };\n      _self.addHeader = function (name, value) {\n        _headers[name] = value;\n      };\n      _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {\n        if (_self.isInitialized()) {\n          _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender is already initialized\");\n        }\n        _base[_DYN_INITIALIZE /* @min:%2einitialize */](config, core, extensions, pluginChain);\n        var identifier = _self.identifier;\n        _serializer = new Serializer(core.logger);\n        _consecutiveErrors = 0;\n        _retryAt = null;\n        _lastSend = 0;\n        _self[_DYN__SENDER /* @min:%2e_sender */] = null;\n        _stamp_specific_redirects = 0;\n        var diagLog = _self[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\n        _evtNamespace = mergeEvtNamespace(createUniqueNamespace(\"Sender\"), core.evtNamespace && core.evtNamespace());\n        _offlineListener = createOfflineListener(_evtNamespace);\n        // This function will be re-called whenever any referenced configuration is changed\n        _self._addHook(onConfigChange(config, function (details) {\n          var config = details.cfg;\n          if (config.storagePrefix) {\n            utlSetStoragePrefix(config.storagePrefix);\n          }\n          var ctx = createProcessTelemetryContext(null, config, core);\n          var senderConfig = ctx.getExtCfg(identifier, defaultAppInsightsChannelConfig);\n          objDefine(_self, \"_senderConfig\", {\n            g: function () {\n              return senderConfig;\n            }\n          });\n          // or is not string\n          if (core.activeStatus() === ActiveStatus.PENDING) {\n            // waiting for core promises to be resolved\n            // NOTE: if active status is set to pending, stop sending, clear timer here\n            _self.pause();\n          } else if (core.activeStatus() === ActiveStatus.ACTIVE) {\n            // core status changed from pending to other status\n            _self.resume();\n          }\n          // Only update the endpoint if the original config !== the current config\n          // This is so any redirect endpointUrl is not overwritten\n          if (_orgEndpointUrl !== senderConfig.endpointUrl) {\n            if (_orgEndpointUrl) {\n              // TODO: add doc to remind users to flush before changing endpoint, otherwise all unsent payload will be sent to new endpoint\n            }\n            _endpointUrl = _orgEndpointUrl = senderConfig.endpointUrl;\n          }\n          if (_customHeaders && _customHeaders !== senderConfig[_DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */]) {\n            // Removing any previously defined custom headers as they have changed\n            arrForEach(_customHeaders, function (customHeader) {\n              delete _headers[customHeader.header];\n            });\n          }\n          _maxBatchSizeInBytes = senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:%2emaxBatchSizeInBytes */];\n          _beaconSupported = (senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */] === false || senderConfig[_DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */] === false) && isBeaconsSupported();\n          _beaconOnUnloadSupported = senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */] === false && isBeaconsSupported();\n          _beaconNormalSupported = senderConfig[_DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */] === false && isBeaconsSupported();\n          _alwaysUseCustomSend = senderConfig[_DYN_ALWAYS_USE_XHR_OVERR4 /* @min:%2ealwaysUseXhrOverride */];\n          _disableXhr = !!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */];\n          _retryCodes = senderConfig.retryCodes;\n          var bufferOverride = senderConfig[_DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */];\n          var canUseSessionStorage = !!senderConfig[_DYN_ENABLE_SESSION_STORA5 /* @min:%2eenableSessionStorageBuffer */] && (!!bufferOverride || utlCanUseSessionStorage());\n          var namePrefix = senderConfig.namePrefix;\n          //Note: emitLineDelimitedJson and eventsLimitInMem is directly accessed via config in senderBuffer\n          //Therefore, if canUseSessionStorage is not changed, we do not need to re initialize a new one\n          var shouldUpdate = canUseSessionStorage !== _sessionStorageUsed || canUseSessionStorage && _namePrefix !== namePrefix // prefixName is only used in session storage\n          || canUseSessionStorage && _bufferOverrideUsed !== bufferOverride;\n          if (_self[_DYN__BUFFER /* @min:%2e_buffer */]) {\n            // case1 (Pre and Now enableSessionStorageBuffer settings are same)\n            // if namePrefix changes, transfer current buffer to new buffer\n            // else no action needed\n            //case2 (Pre and Now enableSessionStorageBuffer settings are changed)\n            // transfer current buffer to new buffer\n            if (shouldUpdate) {\n              try {\n                _self._buffer = _self._buffer[_DYN_CREATE_NEW /* @min:%2ecreateNew */](diagLog, senderConfig, canUseSessionStorage);\n              } catch (e) {\n                _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, \"failed to transfer telemetry to different buffer storage, telemetry will be lost: \" + getExceptionName(e), {\n                  exception: dumpObj(e)\n                });\n              }\n            }\n            _checkMaxSize();\n          } else {\n            _self[_DYN__BUFFER /* @min:%2e_buffer */] = canUseSessionStorage ? new SessionStorageSendBuffer(diagLog, senderConfig) : new ArraySendBuffer(diagLog, senderConfig);\n          }\n          _namePrefix = namePrefix;\n          _sessionStorageUsed = canUseSessionStorage;\n          _bufferOverrideUsed = bufferOverride;\n          _fetchKeepAlive = !senderConfig[_DYN_ONUNLOAD_DISABLE_FET6 /* @min:%2eonunloadDisableFetch */] && isFetchSupported(true);\n          _disableBeaconSplit = !!senderConfig[_DYN_DISABLE_SEND_BEACON_7 /* @min:%2edisableSendBeaconSplit */];\n          _self._sample = new Sample(senderConfig.samplingPercentage, diagLog);\n          _instrumentationKey = senderConfig[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];\n          if (!_validateInstrumentationKey(_instrumentationKey, config)) {\n            _throwInternal(diagLog, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, \"Invalid Instrumentation key \" + _instrumentationKey);\n          }\n          _customHeaders = senderConfig[_DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */];\n          if (isString(_endpointUrl) && !isInternalApplicationInsightsEndpoint(_endpointUrl) && _customHeaders && _customHeaders[_DYN_LENGTH /* @min:%2elength */] > 0) {\n            arrForEach(_customHeaders, function (customHeader) {\n              _this.addHeader(customHeader.header, customHeader.value);\n            });\n          } else {\n            _customHeaders = null;\n          }\n          _enableSendPromise = senderConfig[_DYN_ENABLE_SEND_PROMISE /* @min:%2eenableSendPromise */];\n          var sendPostConfig = _getSendPostMgrConfig();\n          // only init it once\n          if (!_sendPostMgr) {\n            _sendPostMgr = new SenderPostManager();\n            _sendPostMgr[_DYN_INITIALIZE /* @min:%2einitialize */](sendPostConfig, diagLog);\n          } else {\n            _sendPostMgr.SetConfig(sendPostConfig);\n          }\n          var customInterface = senderConfig.httpXHROverride;\n          var httpInterface = null;\n          var syncInterface = null;\n          // User requested transport(s) values > Beacon > Fetch > XHR\n          // Beacon would be filtered out if user has set disableBeaconApi to true at _getSenderInterface\n          var theTransports = prependTransports([3 /* TransportType.Beacon */, 1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */], senderConfig.transports);\n          httpInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST /* @min:%2egetSenderInst */](theTransports, false);\n          var xhrInterface = _sendPostMgr && _sendPostMgr.getFallbackInst();\n          _xhrSend = function (payload, isAsync) {\n            return _doSend(xhrInterface, payload, isAsync);\n          };\n          _fallbackSend = function (payload, isAsync) {\n            return _doSend(xhrInterface, payload, isAsync, false);\n          };\n          httpInterface = _alwaysUseCustomSend ? customInterface : httpInterface || customInterface || xhrInterface;\n          _self[_DYN__SENDER /* @min:%2e_sender */] = function (payload, isAsync) {\n            return _doSend(httpInterface, payload, isAsync);\n          };\n          if (_fetchKeepAlive) {\n            // Try and use the fetch with keepalive\n            _syncUnloadSender = _fetchKeepAliveSender;\n          }\n          var syncTransports = prependTransports([3 /* TransportType.Beacon */, 1 /* TransportType.Xhr */], senderConfig[_DYN_UNLOAD_TRANSPORTS /* @min:%2eunloadTransports */]);\n          if (!_fetchKeepAlive) {\n            // remove fetch from theTransports\n            syncTransports = syncTransports.filter(function (transport) {\n              return transport !== 2 /* TransportType.Fetch */;\n            });\n          }\n          syncInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST /* @min:%2egetSenderInst */](syncTransports, true);\n          syncInterface = _alwaysUseCustomSend ? customInterface : syncInterface || customInterface;\n          if ((_alwaysUseCustomSend || senderConfig[_DYN_UNLOAD_TRANSPORTS /* @min:%2eunloadTransports */] || !_syncUnloadSender) && syncInterface) {\n            _syncUnloadSender = function (payload, isAsync) {\n              return _doSend(syncInterface, payload, isAsync);\n            };\n          }\n          if (!_syncUnloadSender) {\n            _syncUnloadSender = _xhrSend;\n          }\n          _disableTelemetry = senderConfig.disableTelemetry;\n          _convertUndefined = senderConfig[_DYN_CONVERT_UNDEFINED /* @min:%2econvertUndefined */] || UNDEFINED_VALUE;\n          _isRetryDisabled = senderConfig.isRetryDisabled;\n          _maxBatchInterval = senderConfig[_DYN_MAX_BATCH_INTERVAL /* @min:%2emaxBatchInterval */];\n        }));\n      };\n      _self.processTelemetry = function (telemetryItem, itemCtx) {\n        var _a;\n        itemCtx = _self._getTelCtx(itemCtx);\n        var diagLogger = itemCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\n        try {\n          var isValidate = _validate(telemetryItem, diagLogger);\n          if (!isValidate) {\n            return;\n          }\n          var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);\n          if (!aiEnvelope) {\n            return;\n          }\n          // check if the incoming payload is too large, truncate if necessary\n          var payload = _serializer[_DYN_SERIALIZE /* @min:%2eserialize */](aiEnvelope);\n          // flush if we would exceed the max-size limit by adding this item\n          var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\n          _checkMaxSize(payload);\n          var payloadItem = (_a = {}, _a[_DYN_ITEM /* @min:item */] = payload, _a.cnt = 0 // inital cnt will always be 0\n          , _a);\n          // enqueue the payload\n          buffer[_DYN_ENQUEUE /* @min:%2eenqueue */](payloadItem);\n          // ensure an invocation timeout is set\n          _setupTimer();\n        } catch (e) {\n          _throwInternal(diagLogger, 2 /* eLoggingSeverity.WARNING */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, \"Failed adding telemetry to the sender's buffer, some telemetry will be lost: \" + getExceptionName(e), {\n            exception: dumpObj(e)\n          });\n        }\n        // hand off the telemetry item to the next plugin\n        _self.processNext(telemetryItem, itemCtx);\n      };\n      _self.isCompletelyIdle = function () {\n        return !_paused && _syncFetchPayload === 0 && _self._buffer[_DYN_COUNT /* @min:%2ecount */]() === 0;\n      };\n      /**\r\n       * xhr state changes\r\n       */\n      _self._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {\n        // since version 3.2.0, this function is no-op\n        if (_isStringArr(payload)) {\n          return;\n        }\n        return _xhrReadyStateChange(xhr, payload, countOfItemsInPayload);\n      };\n      /**\r\n       * Immediately send buffered data\r\n       * @param async - {boolean} - Indicates if the events should be sent asynchronously\r\n       * @param forcedSender - {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n       */\n      _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */] = function (async, forcedSender, sendReason) {\n        if (async === void 0) {\n          async = true;\n        }\n        var result;\n        if (!_paused) {\n          try {\n            var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\n            // Send data only if disableTelemetry is false\n            if (!_disableTelemetry) {\n              if (buffer[_DYN_COUNT /* @min:%2ecount */]() > 0) {\n                var payload = buffer.getItems();\n                _notifySendRequest(sendReason || 0 /* SendRequestReason.Undefined */, async);\n                // invoke send\n                if (forcedSender) {\n                  result = forcedSender.call(_self, payload, async);\n                } else {\n                  result = _self[_DYN__SENDER /* @min:%2e_sender */](payload, async);\n                }\n              }\n              // update lastSend time to enable throttling\n              _lastSend = +new Date();\n            } else {\n              buffer[_DYN_CLEAR /* @min:%2eclear */]();\n            }\n            _clearScheduledTimer();\n          } catch (e) {\n            /* Ignore this error for IE under v10 */\n            var ieVer = getIEVersion();\n            if (!ieVer || ieVer > 9) {\n              _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 40 /* _eInternalMessageId.TransmissionFailed */, \"Telemetry transmission failed, some telemetry will be lost: \" + getExceptionName(e), {\n                exception: dumpObj(e)\n              });\n            }\n          }\n        }\n        return result;\n      };\n      _self.getOfflineSupport = function () {\n        var _a;\n        return _a = {\n          getUrl: function () {\n            return _endpointUrl;\n          },\n          createPayload: _createPayload\n        }, _a[_DYN_SERIALIZE /* @min:serialize */] = _serialize, _a.batch = _batch, _a.shouldProcess = function (evt) {\n          return !!_validate(evt);\n        }, _a;\n      };\n      _self._doTeardown = function (unloadCtx, unloadState) {\n        _self.onunloadFlush();\n        runTargetUnload(_offlineListener, false);\n        _initDefaults();\n      };\n      /**\r\n       * error handler\r\n       */\n      _self[_DYN__ON_ERROR /* @min:%2e_onError */] = function (payload, message, event) {\n        // since version 3.1.3, string[] is no-op\n        if (_isStringArr(payload)) {\n          return;\n        }\n        return _onError(payload, message, event);\n      };\n      /**\r\n       * partial success handler\r\n       */\n      _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */] = function (payload, results) {\n        // since version 3.1.3, string[] is no-op\n        if (_isStringArr(payload)) {\n          return;\n        }\n        return _onPartialSuccess(payload, results);\n      };\n      /**\r\n       * success handler\r\n       */\n      _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */] = function (payload, countOfItemsInPayload) {\n        // since version 3.1.3, string[] is no-op\n        if (_isStringArr(payload)) {\n          return;\n        }\n        return _onSuccess(payload, countOfItemsInPayload);\n        //_self._buffer && _self._buffer.clearSent(payload);\n      };\n      /**\r\n       * xdr state changes\r\n       */\n      _self._xdrOnLoad = function (xdr, payload) {\n        // since version 3.1.3, string[] is no-op\n        if (_isStringArr(payload)) {\n          return;\n        }\n        return _xdrOnLoad(xdr, payload);\n      };\n      function _xdrOnLoad(xdr, payload) {\n        var responseText = _getResponseText(xdr);\n        if (xdr && (responseText + \"\" === \"200\" || responseText === \"\")) {\n          _consecutiveErrors = 0;\n          _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, 0);\n        } else {\n          var results = parseResponse(responseText);\n          if (results && results[_DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] && results[_DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] > results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */] && !_isRetryDisabled) {\n            _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, results);\n          } else {\n            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, formatErrorMessageXdr(xdr));\n          }\n        }\n      }\n      function _getSendPostMgrConfig() {\n        var _a;\n        try {\n          var onCompleteFuncs = {\n            xdrOnComplete: function (xdr, oncomplete, payload) {\n              var data = _getPayloadArr(payload);\n              if (!data) {\n                return;\n              }\n              return _xdrOnLoad(xdr, data);\n            },\n            fetchOnComplete: function (response, onComplete, resValue, payload) {\n              var data = _getPayloadArr(payload);\n              if (!data) {\n                return;\n              }\n              return _checkResponsStatus(response.status, data, response.url, data[_DYN_LENGTH /* @min:%2elength */], response.statusText, resValue || \"\");\n            },\n            xhrOnComplete: function (request, oncomplete, payload) {\n              var data = _getPayloadArr(payload);\n              if (!data) {\n                return;\n              }\n              return _xhrReadyStateChange(request, data, data[_DYN_LENGTH /* @min:%2elength */]);\n            },\n            beaconOnRetry: function (data, onComplete, canSend) {\n              return _onBeaconRetry(data, onComplete, canSend);\n            }\n          };\n          var config = (_a = {}, _a[_DYN_ENABLE_SEND_PROMISE /* @min:enableSendPromise */] = _enableSendPromise, _a.isOneDs = false, _a.disableCredentials = false, _a[_DYN_DISABLE_XHR /* @min:disableXhr */] = _disableXhr, _a.disableBeacon = !_beaconNormalSupported, _a.disableBeaconSync = !_beaconOnUnloadSupported, _a.senderOnCompleteCallBack = onCompleteFuncs, _a);\n          return config;\n        } catch (e) {\n          // eslint-disable-next-line no-empty\n        }\n        return null;\n      }\n      /**\r\n       * xhr state changes\r\n       */\n      function _xhrReadyStateChange(xhr, payload, countOfItemsInPayload) {\n        if (xhr.readyState === 4) {\n          _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);\n        }\n      }\n      /**\r\n       * error handler\r\n       */\n      function _onError(payload, message, event) {\n        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, \"Failed to send telemetry.\", {\n          message: message\n        });\n        _self._buffer && _self._buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\n      }\n      /**\r\n       * partial success handler\r\n       */\n      function _onPartialSuccess(payload, results) {\n        var failed = [];\n        var retry = [];\n        // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.\n        var errors = results.errors.reverse();\n        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n          var error = errors_1[_i];\n          var extracted = payload.splice(error.index, 1)[0];\n          if (_isRetriable(error.statusCode)) {\n            retry[_DYN_PUSH /* @min:%2epush */](extracted);\n          } else {\n            // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).\n            failed[_DYN_PUSH /* @min:%2epush */](extracted);\n          }\n        }\n        if (payload[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]);\n        }\n        if (failed[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          _self[_DYN__ON_ERROR /* @min:%2e_onError */](failed, formatErrorMessageXhr(null, [\"partial success\", results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */], \"of\", results.itemsReceived].join(\" \")));\n        }\n        if (retry[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          _resendPayload(retry);\n          _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \"Partial success. \" + \"Delivered: \" + payload[_DYN_LENGTH /* @min:%2elength */] + \", Failed: \" + failed[_DYN_LENGTH /* @min:%2elength */] + \". Will retry to send \" + retry[_DYN_LENGTH /* @min:%2elength */] + \" our of \" + results[_DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] + \" items\");\n        }\n      }\n      /**\r\n       * success handler\r\n       */\n      function _onSuccess(payload, countOfItemsInPayload) {\n        _self._buffer && _self._buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\n      }\n      function _getPayloadArr(payload) {\n        try {\n          if (payload) {\n            var internalPayload = payload;\n            var arr = internalPayload[_DYN_ORI_PAYLOAD /* @min:%2eoriPayload */];\n            if (arr && arr[_DYN_LENGTH /* @min:%2elength */]) {\n              return arr;\n            }\n            return null;\n          }\n        } catch (e) {\n          // eslint-disable-next-line no-empty\n        }\n        return null;\n      }\n      function _validate(telemetryItem, diagLogger) {\n        if (_disableTelemetry) {\n          // Do not send/save data\n          return false;\n        }\n        // validate input\n        if (!telemetryItem) {\n          diagLogger && _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 7 /* _eInternalMessageId.CannotSendEmptyTelemetry */, \"Cannot send empty telemetry\");\n          return false;\n        }\n        // validate event\n        if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */]) {\n          diagLogger && _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 70 /* _eInternalMessageId.InvalidEvent */, \"Cannot send telemetry without baseData and baseType\");\n          return false;\n        }\n        if (!telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */]) {\n          // Default\n          telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */] = \"EventData\";\n        }\n        // ensure a sender was constructed\n        if (!_self[_DYN__SENDER /* @min:%2e_sender */]) {\n          diagLogger && _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender was not initialized\");\n          return false;\n        }\n        // check if this item should be sampled in, else add sampleRate tag\n        if (!_isSampledIn(telemetryItem)) {\n          // Item is sampled out, do not send it\n          diagLogger && _throwInternal(diagLogger, 2 /* eLoggingSeverity.WARNING */, 33 /* _eInternalMessageId.TelemetrySampledAndNotSent */, \"Telemetry item was sampled out and not sent\", {\n            SampleRate: _self._sample[_DYN_SAMPLE_RATE /* @min:%2esampleRate */]\n          });\n          return false;\n        } else {\n          telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE /* @min:%2esampleRate */];\n        }\n        return true;\n      }\n      function _getEnvelope(telemetryItem, diagLogger) {\n        // construct an envelope that Application Insights endpoint can understand\n        // if ikey of telemetry is provided and not empty, envelope will use this iKey instead of senderConfig iKey\n        var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey;\n        var aiEnvelope = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);\n        if (!aiEnvelope) {\n          _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 47 /* _eInternalMessageId.CreateEnvelopeError */, \"Unable to create an AppInsights envelope\");\n          return;\n        }\n        var doNotSendItem = false;\n        // this is for running in legacy mode, where customer may already have a custom initializer present\n        if (telemetryItem[_DYN_TAGS /* @min:%2etags */] && telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy]) {\n          arrForEach(telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy], function (callBack) {\n            try {\n              if (callBack && callBack(aiEnvelope) === false) {\n                doNotSendItem = true;\n                _warnToConsole(diagLogger, \"Telemetry processor check returns false\");\n              }\n            } catch (e) {\n              // log error but dont stop executing rest of the telemetry initializers\n              // doNotSendItem = true;\n              _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, \"One of telemetry initializers failed, telemetry item will not be sent: \" + getExceptionName(e), {\n                exception: dumpObj(e)\n              }, true);\n            }\n          });\n          delete telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy];\n        }\n        if (doNotSendItem) {\n          return; // do not send, no need to execute next plugin\n        }\n        return aiEnvelope;\n      }\n      function _serialize(item) {\n        var rlt = EMPTY_STR;\n        var diagLogger = _self[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\n        try {\n          var valid = _validate(item, diagLogger);\n          var envelope = null;\n          if (valid) {\n            envelope = _getEnvelope(item, diagLogger);\n          }\n          if (envelope) {\n            rlt = _serializer[_DYN_SERIALIZE /* @min:%2eserialize */](envelope);\n          }\n        } catch (e) {\n          // eslint-disable-next-line no-empty\n        }\n        return rlt;\n      }\n      function _batch(arr) {\n        var rlt = EMPTY_STR;\n        if (arr && arr[_DYN_LENGTH /* @min:%2elength */]) {\n          rlt = \"[\" + arr.join(\",\") + \"]\";\n        }\n        return rlt;\n      }\n      function _createPayload(data) {\n        var _a;\n        var headers = _getHeaders();\n        return _a = {\n          urlString: _endpointUrl\n        }, _a[_DYN_DATA /* @min:data */] = data, _a.headers = headers, _a;\n      }\n      function _isSampledIn(envelope) {\n        return _self._sample.isSampledIn(envelope);\n      }\n      function _getOnComplete(payload, status, headers, response) {\n        // ***********************************************************************************************\n        //TODO: handle other status codes\n        if (status === 200 && payload) {\n          _self._onSuccess(payload, payload[_DYN_LENGTH /* @min:%2elength */]);\n        } else {\n          response && _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, response);\n        }\n      }\n      function _doSend(sendInterface, payload, isAsync, markAsSent) {\n        if (markAsSent === void 0) {\n          markAsSent = true;\n        }\n        var onComplete = function (status, headers, response) {\n          return _getOnComplete(payload, status, headers, response);\n        };\n        var payloadData = _getPayload(payload);\n        var sendPostFunc = sendInterface && sendInterface.sendPOST;\n        if (sendPostFunc && payloadData) {\n          // ***********************************************************************************************\n          // mark payload as sent at the beginning of calling each send function\n          if (markAsSent) {\n            _self._buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\n          }\n          return sendPostFunc(payloadData, onComplete, !isAsync);\n        }\n        return null;\n      }\n      function _getPayload(payload) {\n        var _a;\n        if (isArray(payload) && payload[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          var batch = _self[_DYN__BUFFER /* @min:%2e_buffer */].batchPayloads(payload);\n          var headers = _getHeaders();\n          var payloadData = (_a = {}, _a[_DYN_DATA /* @min:data */] = batch, _a.urlString = _endpointUrl, _a.headers = headers, _a.disableXhrSync = _disableXhr, _a.disableFetchKeepAlive = !_fetchKeepAlive, _a[_DYN_ORI_PAYLOAD /* @min:oriPayload */] = payload, _a);\n          return payloadData;\n        }\n        return null;\n      }\n      function _getHeaders() {\n        try {\n          var headers = _headers || {};\n          if (isInternalApplicationInsightsEndpoint(_endpointUrl)) {\n            headers[RequestHeaders[6 /* eRequestHeaders.sdkContextHeader */]] = RequestHeaders[7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */];\n          }\n          return headers;\n        } catch (e) {\n          // eslint-disable-next-line no-empty\n        }\n        return null;\n      }\n      function _checkMaxSize(incomingPayload) {\n        var incomingSize = incomingPayload ? incomingPayload[_DYN_LENGTH /* @min:%2elength */] : 0;\n        if (_self[_DYN__BUFFER /* @min:%2e_buffer */].size() + incomingSize > _maxBatchSizeInBytes) {\n          if (!_offlineListener || _offlineListener.isOnline()) {\n            // only trigger send when currently online\n            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 10 /* SendRequestReason.MaxBatchSize */);\n          }\n          return true;\n        }\n        return false;\n      }\n      function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {\n        var response = null;\n        if (!_self._appId) {\n          response = parseResponse(res);\n          if (response && response.appId) {\n            _self._appId = response.appId;\n          }\n        }\n        if ((status < 200 || status >= 300) && status !== 0) {\n          // Update End Point url if permanent redirect or moved permanently\n          // Updates the end point url before retry\n          if (status === 301 || status === 307 || status === 308) {\n            if (!_checkAndUpdateEndPointUrl(responseUrl)) {\n              _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\n              return;\n            }\n          }\n          if (_offlineListener && !_offlineListener.isOnline()) {\n            // offline\n            // Note: Don't check for status == 0, since adblock gives this code\n            if (!_isRetryDisabled) {\n              var offlineBackOffMultiplier = 10; // arbritrary number\n              _resendPayload(payload, offlineBackOffMultiplier);\n              _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". Offline - Response Code: \".concat(status, \". Offline status: \").concat(!_offlineListener.isOnline(), \". Will retry to send \").concat(payload.length, \" items.\"));\n            }\n            return;\n          }\n          if (!_isRetryDisabled && _isRetriable(status)) {\n            _resendPayload(payload);\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Response code \" + status + \". Will retry to send \" + payload[_DYN_LENGTH /* @min:%2elength */] + \" items.\");\n          } else {\n            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\n          }\n        } else {\n          // check if the xhr's responseURL or fetch's response.url is same as endpoint url\n          // TODO after 10 redirects force send telemetry with 'redirect=false' as query parameter.\n          _checkAndUpdateEndPointUrl(responseUrl);\n          if (status === 206) {\n            if (!response) {\n              response = parseResponse(res);\n            }\n            if (response && !_isRetryDisabled) {\n              _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, response);\n            } else {\n              _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\n            }\n          } else {\n            _consecutiveErrors = 0;\n            _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, countOfItemsInPayload);\n          }\n        }\n      }\n      function _checkAndUpdateEndPointUrl(responseUrl) {\n        // Maximum stamp specific redirects allowed(uncomment this when breeze is ready with not allowing redirects feature)\n        if (_stamp_specific_redirects >= 10) {\n          //  _self._senderConfig.endpointUrl = () => Sender._getDefaultAppInsightsChannelConfig().endpointUrl()+\"/?redirect=false\";\n          //  _stamp_specific_redirects = 0;\n          return false;\n        }\n        if (!isNullOrUndefined(responseUrl) && responseUrl !== \"\") {\n          if (responseUrl !== _endpointUrl) {\n            _endpointUrl = responseUrl;\n            ++_stamp_specific_redirects;\n            return true;\n          }\n        }\n        return false;\n      }\n      function _doUnloadSend(payload, isAsync) {\n        if (_syncUnloadSender) {\n          // We are unloading so always call the sender with sync set to false\n          _syncUnloadSender(payload, false);\n        } else {\n          // Fallback to the previous beacon Sender (which causes a CORB warning on chrome now)\n          var beaconInst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST /* @min:%2egetSenderInst */]([3 /* TransportType.Beacon */], true);\n          return _doSend(beaconInst, payload, isAsync);\n        }\n      }\n      function _onBeaconRetry(payload, onComplete, canSend) {\n        var internalPayload = payload;\n        var data = internalPayload && internalPayload[_DYN_ORI_PAYLOAD /* @min:%2eoriPayload */];\n        if (!_disableBeaconSplit) {\n          // Failed to send entire payload so try and split data and try to send as much events as possible\n          var droppedPayload = [];\n          for (var lp = 0; lp < data[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n            var thePayload = data[lp];\n            var arr = [thePayload];\n            var item = _getPayload(arr);\n            if (!canSend(item, onComplete)) {\n              // Can't send anymore, so split the batch and drop the rest\n              droppedPayload[_DYN_PUSH /* @min:%2epush */](thePayload);\n            } else {\n              _self._onSuccess(arr, arr[_DYN_LENGTH /* @min:%2elength */]);\n            }\n          }\n          if (droppedPayload[_DYN_LENGTH /* @min:%2elength */] > 0) {\n            _fallbackSend && _fallbackSend(droppedPayload, true);\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\n          }\n        } else {\n          _fallbackSend && _fallbackSend(data, true);\n          _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\n        }\n      }\n      function _isStringArr(arr) {\n        try {\n          if (arr && arr[_DYN_LENGTH /* @min:%2elength */]) {\n            return isString(arr[0]);\n          }\n        } catch (e) {\n          //TODO: log, sender use IInternalStorageItem instead of string since 3.1.3\n        }\n        return null;\n      }\n      function _fetchKeepAliveSender(payload, isAsync) {\n        var transport = null;\n        if (isArray(payload)) {\n          var payloadSize = payload[_DYN_LENGTH /* @min:%2elength */];\n          for (var lp = 0; lp < payload[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n            payloadSize += payload[lp].item[_DYN_LENGTH /* @min:%2elength */];\n          }\n          var syncFetchPayload = _sendPostMgr.getSyncFetchPayload();\n          if (syncFetchPayload + payloadSize <= FetchSyncRequestSizeLimitBytes) {\n            transport = 2 /* TransportType.Fetch */;\n          } else if (isBeaconsSupported()) {\n            // Fallback to beacon sender as we at least get told which events can't be scheduled\n            transport = 3 /* TransportType.Beacon */;\n          } else {\n            // Payload is going to be too big so just try and send via XHR\n            transport = 1 /* TransportType.Xhr */;\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with xhrSender.\");\n          }\n          var inst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST /* @min:%2egetSenderInst */]([transport], true);\n          return _doSend(inst, payload, isAsync);\n        }\n        return null;\n      }\n      /**\r\n       * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).\r\n       * @param payload\r\n       */\n      function _resendPayload(payload, linearFactor) {\n        if (linearFactor === void 0) {\n          linearFactor = 1;\n        }\n        if (!payload || payload[_DYN_LENGTH /* @min:%2elength */] === 0) {\n          return;\n        }\n        var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\n        buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\n        _consecutiveErrors++;\n        for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {\n          var item = payload_1[_i];\n          item.cnt = item.cnt || 0; // to make sure we have cnt for each payload\n          item.cnt++; // when resend, increase cnt\n          buffer[_DYN_ENQUEUE /* @min:%2eenqueue */](item);\n        }\n        // setup timer\n        _setRetryTime(linearFactor);\n        _setupTimer();\n      }\n      /**\r\n       * Calculates the time to wait before retrying in case of an error based on\r\n       * http://en.wikipedia.org/wiki/Exponential_backoff\r\n       */\n      function _setRetryTime(linearFactor) {\n        var SlotDelayInSeconds = 10;\n        var delayInSeconds;\n        if (_consecutiveErrors <= 1) {\n          delayInSeconds = SlotDelayInSeconds;\n        } else {\n          var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;\n          // tslint:disable-next-line:insecure-random\n          var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;\n          backOffDelay = linearFactor * backOffDelay;\n          delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);\n        }\n        // TODO: Log the backoff time like the C# version does.\n        var retryAfterTimeSpan = dateNow() + delayInSeconds * 1000;\n        // TODO: Log the retry at time like the C# version does.\n        _retryAt = retryAfterTimeSpan;\n      }\n      /**\r\n       * Sets up the timer which triggers actually sending the data.\r\n       */\n      function _setupTimer() {\n        if (!_timeoutHandle && !_paused) {\n          var retryInterval = _retryAt ? Math.max(0, _retryAt - dateNow()) : 0;\n          var timerValue = Math.max(_maxBatchInterval, retryInterval);\n          _timeoutHandle = scheduleTimeout(function () {\n            _timeoutHandle = null;\n            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 1 /* SendRequestReason.NormalSchedule */);\n          }, timerValue);\n        }\n      }\n      function _clearScheduledTimer() {\n        _timeoutHandle && _timeoutHandle.cancel();\n        _timeoutHandle = null;\n        _retryAt = null;\n      }\n      /**\r\n       * Checks if the SDK should resend the payload after receiving this status code from the backend.\r\n       * @param statusCode\r\n       */\n      function _isRetriable(statusCode) {\n        // retryCodes = [] means should not retry\n        if (!isNullOrUndefined(_retryCodes)) {\n          return _retryCodes[_DYN_LENGTH /* @min:%2elength */] && _retryCodes.indexOf(statusCode) > -1;\n        }\n        return statusCode === 401 // Unauthorized\n        // Removing as private links can return a 403 which causes excessive retries and session storage usage\n        // || statusCode === 403 // Forbidden\n        || statusCode === 408 // Timeout\n        || statusCode === 429 // Too many requests.\n        || statusCode === 500 // Internal server error.\n        || statusCode === 502 // Bad Gateway.\n        || statusCode === 503 // Service unavailable.\n        || statusCode === 504; // Gateway timeout.\n      }\n      // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6\n      function _getNotifyMgr() {\n        var func = \"getNotifyMgr\";\n        if (_self.core[func]) {\n          return _self.core[func]();\n        }\n        // using _self.core['_notificationManager'] for backward compatibility\n        return _self.core[\"_notificationManager\"];\n      }\n      function _notifySendRequest(sendRequest, isAsync) {\n        var manager = _getNotifyMgr();\n        if (manager && manager[_DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */]) {\n          try {\n            manager[_DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendRequest, isAsync);\n          } catch (e) {\n            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, \"send request notification failed: \" + getExceptionName(e), {\n              exception: dumpObj(e)\n            });\n          }\n        }\n      }\n      /**\r\n       * Validate UUID Format\r\n       * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo\r\n       */\n      function _validateInstrumentationKey(instrumentationKey, config) {\n        var disableValidation = config.disableInstrumentationKeyValidation;\n        var disableIKeyValidationFlag = isNullOrUndefined(disableValidation) ? false : disableValidation;\n        if (disableIKeyValidationFlag) {\n          return true;\n        }\n        var UUID_Regex = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\";\n        var regexp = new RegExp(UUID_Regex);\n        return regexp.test(instrumentationKey);\n      }\n      function _initDefaults() {\n        _self[_DYN__SENDER /* @min:%2e_sender */] = null;\n        _self[_DYN__BUFFER /* @min:%2e_buffer */] = null;\n        _self._appId = null;\n        _self._sample = null;\n        _headers = {};\n        _offlineListener = null;\n        _consecutiveErrors = 0;\n        _retryAt = null;\n        _lastSend = null;\n        _paused = false;\n        _timeoutHandle = null;\n        _serializer = null;\n        _stamp_specific_redirects = 0;\n        _syncFetchPayload = 0;\n        _syncUnloadSender = null;\n        _evtNamespace = null;\n        _endpointUrl = null;\n        _orgEndpointUrl = null;\n        _maxBatchSizeInBytes = 0;\n        _beaconSupported = false;\n        _customHeaders = null;\n        _disableTelemetry = false;\n        _instrumentationKey = null;\n        _convertUndefined = UNDEFINED_VALUE;\n        _isRetryDisabled = false;\n        _sessionStorageUsed = null;\n        _namePrefix = UNDEFINED_VALUE;\n        _disableXhr = false;\n        _fetchKeepAlive = false;\n        _disableBeaconSplit = false;\n        _xhrSend = null;\n        _fallbackSend = null;\n        _sendPostMgr = null;\n        objDefine(_self, \"_senderConfig\", {\n          g: function () {\n            return objExtend({}, defaultAppInsightsChannelConfig);\n          }\n        });\n      }\n    });\n    return _this;\n  }\n  Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {\n    var envelope;\n    if (iKey !== orig.iKey && !isNullOrUndefined(iKey)) {\n      envelope = __assign(__assign({}, orig), {\n        iKey: iKey\n      });\n    } else {\n      envelope = orig;\n    }\n    var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;\n    return creator(logger, envelope, convertUndefined);\n  };\n  // Removed Stub for Sender.prototype.pause.\n  // Removed Stub for Sender.prototype.resume.\n  // Removed Stub for Sender.prototype.flush.\n  // Removed Stub for Sender.prototype.onunloadFlush.\n  // Removed Stub for Sender.prototype.initialize.\n  // Removed Stub for Sender.prototype.processTelemetry.\n  // Removed Stub for Sender.prototype._xhrReadyStateChange.\n  // Removed Stub for Sender.prototype.triggerSend.\n  // Removed Stub for Sender.prototype._onError.\n  // Removed Stub for Sender.prototype._onPartialSuccess.\n  // Removed Stub for Sender.prototype._onSuccess.\n  // Removed Stub for Sender.prototype._xdrOnLoad.\n  // Removed Stub for Sender.prototype.addHeader.\n  // Removed Stub for Sender.prototype.isCompletelyIdle.\n  // Removed Stub for Sender.prototype.getOfflineSupport.\n  return Sender;\n}(BaseTelemetryPlugin);\nexport { Sender };","map":{"version":3,"names":["_a","_b","__assignFn","__assign","__extendsFn","__extends","dynamicProto","BreezeChannelIdentifier","DEFAULT_BREEZE_ENDPOINT","DEFAULT_BREEZE_PATH","Event","Exception","Metric","PageView","PageViewPerformance","ProcessLegacy","RemoteDependencyData","RequestHeaders","SampleRate","Trace","createOfflineListener","isInternalApplicationInsightsEndpoint","utlCanUseSessionStorage","utlSetStoragePrefix","ActiveStatus","BaseTelemetryPlugin","SenderPostManager","_throwInternal","_warnToConsole","arrForEach","cfgDfBoolean","cfgDfValidate","createProcessTelemetryContext","createUniqueNamespace","dateNow","dumpObj","formatErrorMessageXdr","formatErrorMessageXhr","getExceptionName","getIEVersion","isArray","isBeaconsSupported","isFetchSupported","isNullOrUndefined","mergeEvtNamespace","objExtend","onConfigChange","parseResponse","prependTransports","runTargetUnload","isNumber","isString","isTruthy","objDeepFreeze","objDefine","scheduleTimeout","DependencyEnvelopeCreator","EventEnvelopeCreator","ExceptionEnvelopeCreator","MetricEnvelopeCreator","PageViewEnvelopeCreator","PageViewPerformanceEnvelopeCreator","TraceEnvelopeCreator","ArraySendBuffer","SessionStorageSendBuffer","Serializer","Sample","_DYN_ALWAYS_USE_XHR_OVERR4","_DYN_BASE_TYPE","_DYN_BUFFER_OVERRIDE","_DYN_CLEAR","_DYN_CLEAR_SENT","_DYN_CONVERT_UNDEFINED","_DYN_COUNT","_DYN_CREATE_NEW","_DYN_CUSTOM_HEADERS","_DYN_DATA","_DYN_DIAG_LOG","_DYN_DISABLE_SEND_BEACON_7","_DYN_DISABLE_XHR","_DYN_EMIT_LINE_DELIMITED_0","_DYN_ENABLE_SEND_PROMISE","_DYN_ENABLE_SESSION_STORA5","_DYN_ENQUEUE","_DYN_EVENTS_LIMIT_IN_MEM","_DYN_EVENTS_SEND_REQUEST","_DYN_GET_SENDER_INST","_DYN_INITIALIZE","_DYN_INSTRUMENTATION_KEY","_DYN_IS_BEACON_API_DISABL3","_DYN_ITEM","_DYN_ITEMS_ACCEPTED","_DYN_ITEMS_RECEIVED","_DYN_LENGTH","_DYN_MARK_AS_SENT","_DYN_MAX_BATCH_INTERVAL","_DYN_MAX_BATCH_SIZE_IN_BY1","_DYN_ONUNLOAD_DISABLE_BEA2","_DYN_ONUNLOAD_DISABLE_FET6","_DYN_ORI_PAYLOAD","_DYN_PUSH","_DYN_SAMPLE_RATE","_DYN_SERIALIZE","_DYN_TAGS","_DYN_TRIGGER_SEND","_DYN_UNLOAD_TRANSPORTS","_DYN__BUFFER","_DYN__ON_ERROR","_DYN__ON_PARTIAL_SUCCESS","_DYN__ON_SUCCESS","_DYN__SENDER","UNDEFINED_VALUE","undefined","EMPTY_STR","FetchSyncRequestSizeLimitBytes","_getResponseText","xhr","responseText","e","isOverrideFn","httpXHROverride","sendPOST","defaultAppInsightsChannelConfig","endpointUrl","disableTelemetry","isRetryDisabled","namePrefix","samplingPercentage","_chkSampling","isVal","v","transports","retryCodes","maxRetryCnt","value","isNaN","EnvelopeTypeCreator","dataType","Sender","_super","_this","call","priority","identifier","_consecutiveErrors","_retryAt","_lastSend","_paused","_timeoutHandle","_serializer","_stamp_specific_redirects","_headers","_syncFetchPayload","_syncUnloadSender","_offlineListener","_evtNamespace","_endpointUrl","_orgEndpointUrl","_maxBatchSizeInBytes","_beaconSupported","_beaconOnUnloadSupported","_beaconNormalSupported","_customHeaders","_disableTelemetry","_instrumentationKey","_convertUndefined","_isRetryDisabled","_maxBatchInterval","_sessionStorageUsed","_bufferOverrideUsed","_namePrefix","_enableSendPromise","_alwaysUseCustomSend","_disableXhr","_fetchKeepAlive","_xhrSend","_fallbackSend","_disableBeaconSplit","_sendPostMgr","_retryCodes","_self","_base","_initDefaults","pause","_clearScheduledTimer","resume","_checkMaxSize","_setupTimer","flush","isAsync","callBack","sendReason","exception","onunloadFlush","_doUnloadSend","addHeader","name","config","core","extensions","pluginChain","isInitialized","logger","diagLog","evtNamespace","_addHook","details","cfg","storagePrefix","ctx","senderConfig","getExtCfg","g","activeStatus","PENDING","ACTIVE","customHeader","header","bufferOverride","canUseSessionStorage","shouldUpdate","_buffer","_sample","_validateInstrumentationKey","sendPostConfig","_getSendPostMgrConfig","SetConfig","customInterface","httpInterface","syncInterface","theTransports","xhrInterface","getFallbackInst","payload","_doSend","_fetchKeepAliveSender","syncTransports","filter","transport","processTelemetry","telemetryItem","itemCtx","_getTelCtx","diagLogger","isValidate","_validate","aiEnvelope","_getEnvelope","buffer","payloadItem","cnt","processNext","isCompletelyIdle","_xhrReadyStateChange","countOfItemsInPayload","_isStringArr","async","forcedSender","result","getItems","_notifySendRequest","Date","ieVer","getOfflineSupport","getUrl","createPayload","_createPayload","_serialize","batch","_batch","shouldProcess","evt","_doTeardown","unloadCtx","unloadState","message","event","_onError","results","_onPartialSuccess","_onSuccess","_xdrOnLoad","xdr","onCompleteFuncs","xdrOnComplete","oncomplete","data","_getPayloadArr","fetchOnComplete","response","onComplete","resValue","_checkResponsStatus","status","url","statusText","xhrOnComplete","request","beaconOnRetry","canSend","_onBeaconRetry","isOneDs","disableCredentials","disableBeacon","disableBeaconSync","senderOnCompleteCallBack","readyState","responseURL","failed","retry","errors","reverse","_i","errors_1","length","error","extracted","splice","index","_isRetriable","statusCode","itemsReceived","join","_resendPayload","internalPayload","arr","baseData","_isSampledIn","defaultEnvelopeIkey","iKey","constructEnvelope","doNotSendItem","item","rlt","valid","envelope","headers","_getHeaders","urlString","isSampledIn","_getOnComplete","sendInterface","markAsSent","payloadData","_getPayload","sendPostFunc","batchPayloads","disableXhrSync","disableFetchKeepAlive","incomingPayload","incomingSize","size","isOnline","responseUrl","errorMessage","res","_appId","appId","_checkAndUpdateEndPointUrl","offlineBackOffMultiplier","concat","beaconInst","droppedPayload","lp","thePayload","payloadSize","syncFetchPayload","getSyncFetchPayload","inst","linearFactor","payload_1","_setRetryTime","SlotDelayInSeconds","delayInSeconds","backOffSlot","Math","pow","backOffDelay","floor","random","max","min","retryAfterTimeSpan","retryInterval","timerValue","cancel","indexOf","_getNotifyMgr","func","sendRequest","manager","instrumentationKey","disableValidation","disableInstrumentationKeyValidation","disableIKeyValidationFlag","UUID_Regex","regexp","RegExp","test","orig","convertUndefined","creator","baseType"],"sources":["/home/veeresh133/app/json-holder-api/react-az/node_modules/@microsoft/applicationinsights-channel-js/dist-es5/Sender.js"],"sourcesContent":["var _a, _b;\r\nimport { __assign, __extends } from \"tslib\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { BreezeChannelIdentifier, DEFAULT_BREEZE_ENDPOINT, DEFAULT_BREEZE_PATH, Event, Exception, Metric, PageView, PageViewPerformance, ProcessLegacy, RemoteDependencyData, RequestHeaders, SampleRate, Trace, createOfflineListener, isInternalApplicationInsightsEndpoint, utlCanUseSessionStorage, utlSetStoragePrefix } from \"@microsoft/applicationinsights-common\";\r\nimport { ActiveStatus, BaseTelemetryPlugin, SenderPostManager, _throwInternal, _warnToConsole, arrForEach, cfgDfBoolean, cfgDfValidate, createProcessTelemetryContext, createUniqueNamespace, dateNow, dumpObj, formatErrorMessageXdr, formatErrorMessageXhr, getExceptionName, getIEVersion, isArray, isBeaconsSupported, isFetchSupported, isNullOrUndefined, mergeEvtNamespace, objExtend, onConfigChange, parseResponse, prependTransports, runTargetUnload } from \"@microsoft/applicationinsights-core-js\";\r\nimport { isNumber, isString, isTruthy, objDeepFreeze, objDefine, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { DependencyEnvelopeCreator, EventEnvelopeCreator, ExceptionEnvelopeCreator, MetricEnvelopeCreator, PageViewEnvelopeCreator, PageViewPerformanceEnvelopeCreator, TraceEnvelopeCreator } from \"./EnvelopeCreator\";\r\nimport { ArraySendBuffer, SessionStorageSendBuffer } from \"./SendBuffer\";\r\nimport { Serializer } from \"./Serializer\";\r\nimport { Sample } from \"./TelemetryProcessors/Sample\";\r\nimport { _DYN_ALWAYS_USE_XHR_OVERR4, _DYN_BASE_TYPE, _DYN_BUFFER_OVERRIDE, _DYN_CLEAR, _DYN_CLEAR_SENT, _DYN_CONVERT_UNDEFINED, _DYN_COUNT, _DYN_CREATE_NEW, _DYN_CUSTOM_HEADERS, _DYN_DATA, _DYN_DIAG_LOG, _DYN_DISABLE_SEND_BEACON_7, _DYN_DISABLE_XHR, _DYN_EMIT_LINE_DELIMITED_0, _DYN_ENABLE_SEND_PROMISE, _DYN_ENABLE_SESSION_STORA5, _DYN_ENQUEUE, _DYN_EVENTS_LIMIT_IN_MEM, _DYN_EVENTS_SEND_REQUEST, _DYN_GET_SENDER_INST, _DYN_INITIALIZE, _DYN_INSTRUMENTATION_KEY, _DYN_IS_BEACON_API_DISABL3, _DYN_ITEM, _DYN_ITEMS_ACCEPTED, _DYN_ITEMS_RECEIVED, _DYN_LENGTH, _DYN_MARK_AS_SENT, _DYN_MAX_BATCH_INTERVAL, _DYN_MAX_BATCH_SIZE_IN_BY1, _DYN_ONUNLOAD_DISABLE_BEA2, _DYN_ONUNLOAD_DISABLE_FET6, _DYN_ORI_PAYLOAD, _DYN_PUSH, _DYN_SAMPLE_RATE, _DYN_SERIALIZE, _DYN_TAGS, _DYN_TRIGGER_SEND, _DYN_UNLOAD_TRANSPORTS, _DYN__BUFFER, _DYN__ON_ERROR, _DYN__ON_PARTIAL_SUCCESS, _DYN__ON_SUCCESS, _DYN__SENDER } from \"./__DynamicConstants\";\r\nvar UNDEFINED_VALUE = undefined;\r\nvar EMPTY_STR = \"\";\r\nvar FetchSyncRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)\r\nfunction _getResponseText(xhr) {\r\n    try {\r\n        return xhr.responseText;\r\n    }\r\n    catch (e) {\r\n        // Best effort, as XHR may throw while XDR wont so just ignore\r\n    }\r\n    return null;\r\n}\r\nfunction isOverrideFn(httpXHROverride) {\r\n    return httpXHROverride && httpXHROverride.sendPOST;\r\n}\r\nvar defaultAppInsightsChannelConfig = objDeepFreeze((_a = {\r\n        // Use the default value (handles empty string in the configuration)\r\n        endpointUrl: cfgDfValidate(isTruthy, DEFAULT_BREEZE_ENDPOINT + DEFAULT_BREEZE_PATH)\r\n    },\r\n    _a[_DYN_EMIT_LINE_DELIMITED_0 /* @min:emitLineDelimitedJson */] = cfgDfBoolean(),\r\n    _a[_DYN_MAX_BATCH_INTERVAL /* @min:maxBatchInterval */] = 15000,\r\n    _a[_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:maxBatchSizeInBytes */] = 102400,\r\n    _a.disableTelemetry = cfgDfBoolean(),\r\n    _a[_DYN_ENABLE_SESSION_STORA5 /* @min:enableSessionStorageBuffer */] = cfgDfBoolean(true),\r\n    _a.isRetryDisabled = cfgDfBoolean(),\r\n    _a[_DYN_IS_BEACON_API_DISABL3 /* @min:isBeaconApiDisabled */] = cfgDfBoolean(true),\r\n    _a[_DYN_DISABLE_SEND_BEACON_7 /* @min:disableSendBeaconSplit */] = cfgDfBoolean(true),\r\n    _a[_DYN_DISABLE_XHR /* @min:disableXhr */] = cfgDfBoolean(),\r\n    _a[_DYN_ONUNLOAD_DISABLE_FET6 /* @min:onunloadDisableFetch */] = cfgDfBoolean(),\r\n    _a[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:onunloadDisableBeacon */] = cfgDfBoolean(),\r\n    _a[_DYN_INSTRUMENTATION_KEY /* @min:instrumentationKey */] = UNDEFINED_VALUE,\r\n    _a.namePrefix = UNDEFINED_VALUE,\r\n    _a.samplingPercentage = cfgDfValidate(_chkSampling, 100),\r\n    _a[_DYN_CUSTOM_HEADERS /* @min:customHeaders */] = UNDEFINED_VALUE,\r\n    _a[_DYN_CONVERT_UNDEFINED /* @min:convertUndefined */] = UNDEFINED_VALUE,\r\n    _a[_DYN_EVENTS_LIMIT_IN_MEM /* @min:eventsLimitInMem */] = 10000,\r\n    _a[_DYN_BUFFER_OVERRIDE /* @min:bufferOverride */] = false,\r\n    _a.httpXHROverride = { isVal: isOverrideFn, v: UNDEFINED_VALUE },\r\n    _a[_DYN_ALWAYS_USE_XHR_OVERR4 /* @min:alwaysUseXhrOverride */] = cfgDfBoolean(),\r\n    _a.transports = UNDEFINED_VALUE,\r\n    _a.retryCodes = UNDEFINED_VALUE,\r\n    _a.maxRetryCnt = { isVal: isNumber, v: 10 },\r\n    _a));\r\nfunction _chkSampling(value) {\r\n    return !isNaN(value) && value > 0 && value <= 100;\r\n}\r\nvar EnvelopeTypeCreator = (_b = {},\r\n    _b[Event.dataType] = EventEnvelopeCreator,\r\n    _b[Trace.dataType] = TraceEnvelopeCreator,\r\n    _b[PageView.dataType] = PageViewEnvelopeCreator,\r\n    _b[PageViewPerformance.dataType] = PageViewPerformanceEnvelopeCreator,\r\n    _b[Exception.dataType] = ExceptionEnvelopeCreator,\r\n    _b[Metric.dataType] = MetricEnvelopeCreator,\r\n    _b[RemoteDependencyData.dataType] = DependencyEnvelopeCreator,\r\n    _b);\r\nvar Sender = /** @class */ (function (_super) {\r\n    __extends(Sender, _super);\r\n    function Sender() {\r\n        var _this = _super.call(this) || this;\r\n        _this.priority = 1001;\r\n        _this.identifier = BreezeChannelIdentifier;\r\n        // Don't set the defaults here, set them in the _initDefaults() as this is also called during unload\r\n        var _consecutiveErrors; // How many times in a row a retryable error condition has occurred.\r\n        var _retryAt; // The time to retry at in milliseconds from 1970/01/01 (this makes the timer calculation easy).\r\n        var _lastSend; // The time of the last send operation.\r\n        var _paused; // Flag indicating that the sending should be paused\r\n        var _timeoutHandle; // Handle to the timer for delayed sending of batches of data.\r\n        var _serializer;\r\n        var _stamp_specific_redirects;\r\n        var _headers;\r\n        var _syncFetchPayload = 0; // Keep track of the outstanding sync fetch payload total (as sync fetch has limits)\r\n        var _syncUnloadSender; // The identified sender to use for the synchronous unload stage\r\n        var _offlineListener;\r\n        var _evtNamespace;\r\n        var _endpointUrl;\r\n        var _orgEndpointUrl;\r\n        var _maxBatchSizeInBytes;\r\n        var _beaconSupported;\r\n        var _beaconOnUnloadSupported;\r\n        var _beaconNormalSupported;\r\n        var _customHeaders;\r\n        var _disableTelemetry;\r\n        var _instrumentationKey;\r\n        var _convertUndefined;\r\n        var _isRetryDisabled;\r\n        var _maxBatchInterval;\r\n        var _sessionStorageUsed;\r\n        var _bufferOverrideUsed;\r\n        var _namePrefix;\r\n        var _enableSendPromise;\r\n        var _alwaysUseCustomSend;\r\n        var _disableXhr;\r\n        var _fetchKeepAlive;\r\n        var _xhrSend;\r\n        var _fallbackSend;\r\n        var _disableBeaconSplit;\r\n        var _sendPostMgr;\r\n        var _retryCodes;\r\n        dynamicProto(Sender, _this, function (_self, _base) {\r\n            _initDefaults();\r\n            _self.pause = function () {\r\n                _clearScheduledTimer();\r\n                _paused = true;\r\n            };\r\n            _self.resume = function () {\r\n                if (_paused) {\r\n                    _paused = false;\r\n                    _retryAt = null;\r\n                    // flush if we have exceeded the max-size already\r\n                    _checkMaxSize();\r\n                    _setupTimer();\r\n                }\r\n            };\r\n            _self.flush = function (isAsync, callBack, sendReason) {\r\n                if (isAsync === void 0) { isAsync = true; }\r\n                if (!_paused) {\r\n                    // Clear the normal schedule timer as we are going to try and flush ASAP\r\n                    _clearScheduledTimer();\r\n                    try {\r\n                        return _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](isAsync, null, sendReason || 1 /* SendRequestReason.ManualFlush */);\r\n                    }\r\n                    catch (e) {\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 22 /* _eInternalMessageId.FlushFailed */, \"flush failed, telemetry will not be collected: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                    }\r\n                }\r\n            };\r\n            _self.onunloadFlush = function () {\r\n                if (!_paused) {\r\n                    if (_beaconSupported || _alwaysUseCustomSend) {\r\n                        try {\r\n                            return _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, _doUnloadSend, 2 /* SendRequestReason.Unload */);\r\n                        }\r\n                        catch (e) {\r\n                            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, \"failed to flush with beacon sender on page unload, telemetry will not be collected: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                        }\r\n                    }\r\n                    else {\r\n                        _self.flush(false);\r\n                    }\r\n                }\r\n            };\r\n            _self.addHeader = function (name, value) {\r\n                _headers[name] = value;\r\n            };\r\n            _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {\r\n                if (_self.isInitialized()) {\r\n                    _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender is already initialized\");\r\n                }\r\n                _base[_DYN_INITIALIZE /* @min:%2einitialize */](config, core, extensions, pluginChain);\r\n                var identifier = _self.identifier;\r\n                _serializer = new Serializer(core.logger);\r\n                _consecutiveErrors = 0;\r\n                _retryAt = null;\r\n                _lastSend = 0;\r\n                _self[_DYN__SENDER /* @min:%2e_sender */] = null;\r\n                _stamp_specific_redirects = 0;\r\n                var diagLog = _self[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\r\n                _evtNamespace = mergeEvtNamespace(createUniqueNamespace(\"Sender\"), core.evtNamespace && core.evtNamespace());\r\n                _offlineListener = createOfflineListener(_evtNamespace);\r\n                // This function will be re-called whenever any referenced configuration is changed\r\n                _self._addHook(onConfigChange(config, function (details) {\r\n                    var config = details.cfg;\r\n                    if (config.storagePrefix) {\r\n                        utlSetStoragePrefix(config.storagePrefix);\r\n                    }\r\n                    var ctx = createProcessTelemetryContext(null, config, core);\r\n                    var senderConfig = ctx.getExtCfg(identifier, defaultAppInsightsChannelConfig);\r\n                    objDefine(_self, \"_senderConfig\", {\r\n                        g: function () {\r\n                            return senderConfig;\r\n                        }\r\n                    });\r\n                    // or is not string\r\n                    if (core.activeStatus() === ActiveStatus.PENDING) {\r\n                        // waiting for core promises to be resolved\r\n                        // NOTE: if active status is set to pending, stop sending, clear timer here\r\n                        _self.pause();\r\n                    }\r\n                    else if (core.activeStatus() === ActiveStatus.ACTIVE) {\r\n                        // core status changed from pending to other status\r\n                        _self.resume();\r\n                    }\r\n                    // Only update the endpoint if the original config !== the current config\r\n                    // This is so any redirect endpointUrl is not overwritten\r\n                    if (_orgEndpointUrl !== senderConfig.endpointUrl) {\r\n                        if (_orgEndpointUrl) {\r\n                            // TODO: add doc to remind users to flush before changing endpoint, otherwise all unsent payload will be sent to new endpoint\r\n                        }\r\n                        _endpointUrl = _orgEndpointUrl = senderConfig.endpointUrl;\r\n                    }\r\n                    if (_customHeaders && _customHeaders !== senderConfig[_DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */]) {\r\n                        // Removing any previously defined custom headers as they have changed\r\n                        arrForEach(_customHeaders, function (customHeader) {\r\n                            delete _headers[customHeader.header];\r\n                        });\r\n                    }\r\n                    _maxBatchSizeInBytes = senderConfig[_DYN_MAX_BATCH_SIZE_IN_BY1 /* @min:%2emaxBatchSizeInBytes */];\r\n                    _beaconSupported = (senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */] === false || senderConfig[_DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */] === false) && isBeaconsSupported();\r\n                    _beaconOnUnloadSupported = senderConfig[_DYN_ONUNLOAD_DISABLE_BEA2 /* @min:%2eonunloadDisableBeacon */] === false && isBeaconsSupported();\r\n                    _beaconNormalSupported = senderConfig[_DYN_IS_BEACON_API_DISABL3 /* @min:%2eisBeaconApiDisabled */] === false && isBeaconsSupported();\r\n                    _alwaysUseCustomSend = senderConfig[_DYN_ALWAYS_USE_XHR_OVERR4 /* @min:%2ealwaysUseXhrOverride */];\r\n                    _disableXhr = !!senderConfig[_DYN_DISABLE_XHR /* @min:%2edisableXhr */];\r\n                    _retryCodes = senderConfig.retryCodes;\r\n                    var bufferOverride = senderConfig[_DYN_BUFFER_OVERRIDE /* @min:%2ebufferOverride */];\r\n                    var canUseSessionStorage = !!senderConfig[_DYN_ENABLE_SESSION_STORA5 /* @min:%2eenableSessionStorageBuffer */] &&\r\n                        (!!bufferOverride || utlCanUseSessionStorage());\r\n                    var namePrefix = senderConfig.namePrefix;\r\n                    //Note: emitLineDelimitedJson and eventsLimitInMem is directly accessed via config in senderBuffer\r\n                    //Therefore, if canUseSessionStorage is not changed, we do not need to re initialize a new one\r\n                    var shouldUpdate = (canUseSessionStorage !== _sessionStorageUsed)\r\n                        || (canUseSessionStorage && (_namePrefix !== namePrefix)) // prefixName is only used in session storage\r\n                        || (canUseSessionStorage && (_bufferOverrideUsed !== bufferOverride));\r\n                    if (_self[_DYN__BUFFER /* @min:%2e_buffer */]) {\r\n                        // case1 (Pre and Now enableSessionStorageBuffer settings are same)\r\n                        // if namePrefix changes, transfer current buffer to new buffer\r\n                        // else no action needed\r\n                        //case2 (Pre and Now enableSessionStorageBuffer settings are changed)\r\n                        // transfer current buffer to new buffer\r\n                        if (shouldUpdate) {\r\n                            try {\r\n                                _self._buffer = _self._buffer[_DYN_CREATE_NEW /* @min:%2ecreateNew */](diagLog, senderConfig, canUseSessionStorage);\r\n                            }\r\n                            catch (e) {\r\n                                _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, \"failed to transfer telemetry to different buffer storage, telemetry will be lost: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                            }\r\n                        }\r\n                        _checkMaxSize();\r\n                    }\r\n                    else {\r\n                        _self[_DYN__BUFFER /* @min:%2e_buffer */] = canUseSessionStorage\r\n                            ? new SessionStorageSendBuffer(diagLog, senderConfig) : new ArraySendBuffer(diagLog, senderConfig);\r\n                    }\r\n                    _namePrefix = namePrefix;\r\n                    _sessionStorageUsed = canUseSessionStorage;\r\n                    _bufferOverrideUsed = bufferOverride;\r\n                    _fetchKeepAlive = !senderConfig[_DYN_ONUNLOAD_DISABLE_FET6 /* @min:%2eonunloadDisableFetch */] && isFetchSupported(true);\r\n                    _disableBeaconSplit = !!senderConfig[_DYN_DISABLE_SEND_BEACON_7 /* @min:%2edisableSendBeaconSplit */];\r\n                    _self._sample = new Sample(senderConfig.samplingPercentage, diagLog);\r\n                    _instrumentationKey = senderConfig[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];\r\n                    if (!_validateInstrumentationKey(_instrumentationKey, config)) {\r\n                        _throwInternal(diagLog, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, \"Invalid Instrumentation key \" + _instrumentationKey);\r\n                    }\r\n                    _customHeaders = senderConfig[_DYN_CUSTOM_HEADERS /* @min:%2ecustomHeaders */];\r\n                    if (isString(_endpointUrl) && !isInternalApplicationInsightsEndpoint(_endpointUrl) && _customHeaders && _customHeaders[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                        arrForEach(_customHeaders, function (customHeader) {\r\n                            _this.addHeader(customHeader.header, customHeader.value);\r\n                        });\r\n                    }\r\n                    else {\r\n                        _customHeaders = null;\r\n                    }\r\n                    _enableSendPromise = senderConfig[_DYN_ENABLE_SEND_PROMISE /* @min:%2eenableSendPromise */];\r\n                    var sendPostConfig = _getSendPostMgrConfig();\r\n                    // only init it once\r\n                    if (!_sendPostMgr) {\r\n                        _sendPostMgr = new SenderPostManager();\r\n                        _sendPostMgr[_DYN_INITIALIZE /* @min:%2einitialize */](sendPostConfig, diagLog);\r\n                    }\r\n                    else {\r\n                        _sendPostMgr.SetConfig(sendPostConfig);\r\n                    }\r\n                    var customInterface = senderConfig.httpXHROverride;\r\n                    var httpInterface = null;\r\n                    var syncInterface = null;\r\n                    // User requested transport(s) values > Beacon > Fetch > XHR\r\n                    // Beacon would be filtered out if user has set disableBeaconApi to true at _getSenderInterface\r\n                    var theTransports = prependTransports([3 /* TransportType.Beacon */, 1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */], senderConfig.transports);\r\n                    httpInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST /* @min:%2egetSenderInst */](theTransports, false);\r\n                    var xhrInterface = _sendPostMgr && _sendPostMgr.getFallbackInst();\r\n                    _xhrSend = function (payload, isAsync) {\r\n                        return _doSend(xhrInterface, payload, isAsync);\r\n                    };\r\n                    _fallbackSend = function (payload, isAsync) {\r\n                        return _doSend(xhrInterface, payload, isAsync, false);\r\n                    };\r\n                    httpInterface = _alwaysUseCustomSend ? customInterface : (httpInterface || customInterface || xhrInterface);\r\n                    _self[_DYN__SENDER /* @min:%2e_sender */] = function (payload, isAsync) {\r\n                        return _doSend(httpInterface, payload, isAsync);\r\n                    };\r\n                    if (_fetchKeepAlive) {\r\n                        // Try and use the fetch with keepalive\r\n                        _syncUnloadSender = _fetchKeepAliveSender;\r\n                    }\r\n                    var syncTransports = prependTransports([3 /* TransportType.Beacon */, 1 /* TransportType.Xhr */], senderConfig[_DYN_UNLOAD_TRANSPORTS /* @min:%2eunloadTransports */]);\r\n                    if (!_fetchKeepAlive) {\r\n                        // remove fetch from theTransports\r\n                        syncTransports = syncTransports.filter(function (transport) { return transport !== 2 /* TransportType.Fetch */; });\r\n                    }\r\n                    syncInterface = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST /* @min:%2egetSenderInst */](syncTransports, true);\r\n                    syncInterface = _alwaysUseCustomSend ? customInterface : (syncInterface || customInterface);\r\n                    if ((_alwaysUseCustomSend || senderConfig[_DYN_UNLOAD_TRANSPORTS /* @min:%2eunloadTransports */] || !_syncUnloadSender) && syncInterface) {\r\n                        _syncUnloadSender = function (payload, isAsync) {\r\n                            return _doSend(syncInterface, payload, isAsync);\r\n                        };\r\n                    }\r\n                    if (!_syncUnloadSender) {\r\n                        _syncUnloadSender = _xhrSend;\r\n                    }\r\n                    _disableTelemetry = senderConfig.disableTelemetry;\r\n                    _convertUndefined = senderConfig[_DYN_CONVERT_UNDEFINED /* @min:%2econvertUndefined */] || UNDEFINED_VALUE;\r\n                    _isRetryDisabled = senderConfig.isRetryDisabled;\r\n                    _maxBatchInterval = senderConfig[_DYN_MAX_BATCH_INTERVAL /* @min:%2emaxBatchInterval */];\r\n                }));\r\n            };\r\n            _self.processTelemetry = function (telemetryItem, itemCtx) {\r\n                var _a;\r\n                itemCtx = _self._getTelCtx(itemCtx);\r\n                var diagLogger = itemCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\r\n                try {\r\n                    var isValidate = _validate(telemetryItem, diagLogger);\r\n                    if (!isValidate) {\r\n                        return;\r\n                    }\r\n                    var aiEnvelope = _getEnvelope(telemetryItem, diagLogger);\r\n                    if (!aiEnvelope) {\r\n                        return;\r\n                    }\r\n                    // check if the incoming payload is too large, truncate if necessary\r\n                    var payload = _serializer[_DYN_SERIALIZE /* @min:%2eserialize */](aiEnvelope);\r\n                    // flush if we would exceed the max-size limit by adding this item\r\n                    var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\r\n                    _checkMaxSize(payload);\r\n                    var payloadItem = (_a = {},\r\n                        _a[_DYN_ITEM /* @min:item */] = payload,\r\n                        _a.cnt = 0 // inital cnt will always be 0\r\n                    ,\r\n                        _a);\r\n                    // enqueue the payload\r\n                    buffer[_DYN_ENQUEUE /* @min:%2eenqueue */](payloadItem);\r\n                    // ensure an invocation timeout is set\r\n                    _setupTimer();\r\n                }\r\n                catch (e) {\r\n                    _throwInternal(diagLogger, 2 /* eLoggingSeverity.WARNING */, 12 /* _eInternalMessageId.FailedAddingTelemetryToBuffer */, \"Failed adding telemetry to the sender's buffer, some telemetry will be lost: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                }\r\n                // hand off the telemetry item to the next plugin\r\n                _self.processNext(telemetryItem, itemCtx);\r\n            };\r\n            _self.isCompletelyIdle = function () {\r\n                return !_paused && _syncFetchPayload === 0 && _self._buffer[_DYN_COUNT /* @min:%2ecount */]() === 0;\r\n            };\r\n            /**\r\n             * xhr state changes\r\n             */\r\n            _self._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {\r\n                // since version 3.2.0, this function is no-op\r\n                if (_isStringArr(payload)) {\r\n                    return;\r\n                }\r\n                return _xhrReadyStateChange(xhr, payload, countOfItemsInPayload);\r\n            };\r\n            /**\r\n             * Immediately send buffered data\r\n             * @param async - {boolean} - Indicates if the events should be sent asynchronously\r\n             * @param forcedSender - {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n             */\r\n            _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */] = function (async, forcedSender, sendReason) {\r\n                if (async === void 0) { async = true; }\r\n                var result;\r\n                if (!_paused) {\r\n                    try {\r\n                        var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\r\n                        // Send data only if disableTelemetry is false\r\n                        if (!_disableTelemetry) {\r\n                            if (buffer[_DYN_COUNT /* @min:%2ecount */]() > 0) {\r\n                                var payload = buffer.getItems();\r\n                                _notifySendRequest(sendReason || 0 /* SendRequestReason.Undefined */, async);\r\n                                // invoke send\r\n                                if (forcedSender) {\r\n                                    result = forcedSender.call(_self, payload, async);\r\n                                }\r\n                                else {\r\n                                    result = _self[_DYN__SENDER /* @min:%2e_sender */](payload, async);\r\n                                }\r\n                            }\r\n                            // update lastSend time to enable throttling\r\n                            _lastSend = +new Date;\r\n                        }\r\n                        else {\r\n                            buffer[_DYN_CLEAR /* @min:%2eclear */]();\r\n                        }\r\n                        _clearScheduledTimer();\r\n                    }\r\n                    catch (e) {\r\n                        /* Ignore this error for IE under v10 */\r\n                        var ieVer = getIEVersion();\r\n                        if (!ieVer || ieVer > 9) {\r\n                            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 40 /* _eInternalMessageId.TransmissionFailed */, \"Telemetry transmission failed, some telemetry will be lost: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                        }\r\n                    }\r\n                }\r\n                return result;\r\n            };\r\n            _self.getOfflineSupport = function () {\r\n                var _a;\r\n                return _a = {\r\n                        getUrl: function () {\r\n                            return _endpointUrl;\r\n                        },\r\n                        createPayload: _createPayload\r\n                    },\r\n                    _a[_DYN_SERIALIZE /* @min:serialize */] = _serialize,\r\n                    _a.batch = _batch,\r\n                    _a.shouldProcess = function (evt) {\r\n                        return !!_validate(evt);\r\n                    },\r\n                    _a;\r\n            };\r\n            _self._doTeardown = function (unloadCtx, unloadState) {\r\n                _self.onunloadFlush();\r\n                runTargetUnload(_offlineListener, false);\r\n                _initDefaults();\r\n            };\r\n            /**\r\n             * error handler\r\n             */\r\n            _self[_DYN__ON_ERROR /* @min:%2e_onError */] = function (payload, message, event) {\r\n                // since version 3.1.3, string[] is no-op\r\n                if (_isStringArr(payload)) {\r\n                    return;\r\n                }\r\n                return _onError(payload, message, event);\r\n            };\r\n            /**\r\n             * partial success handler\r\n             */\r\n            _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */] = function (payload, results) {\r\n                // since version 3.1.3, string[] is no-op\r\n                if (_isStringArr(payload)) {\r\n                    return;\r\n                }\r\n                return _onPartialSuccess(payload, results);\r\n            };\r\n            /**\r\n             * success handler\r\n             */\r\n            _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */] = function (payload, countOfItemsInPayload) {\r\n                // since version 3.1.3, string[] is no-op\r\n                if (_isStringArr(payload)) {\r\n                    return;\r\n                }\r\n                return _onSuccess(payload, countOfItemsInPayload);\r\n                //_self._buffer && _self._buffer.clearSent(payload);\r\n            };\r\n            /**\r\n             * xdr state changes\r\n             */\r\n            _self._xdrOnLoad = function (xdr, payload) {\r\n                // since version 3.1.3, string[] is no-op\r\n                if (_isStringArr(payload)) {\r\n                    return;\r\n                }\r\n                return _xdrOnLoad(xdr, payload);\r\n            };\r\n            function _xdrOnLoad(xdr, payload) {\r\n                var responseText = _getResponseText(xdr);\r\n                if (xdr && (responseText + \"\" === \"200\" || responseText === \"\")) {\r\n                    _consecutiveErrors = 0;\r\n                    _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, 0);\r\n                }\r\n                else {\r\n                    var results = parseResponse(responseText);\r\n                    if (results && results[_DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] && results[_DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] > results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]\r\n                        && !_isRetryDisabled) {\r\n                        _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, results);\r\n                    }\r\n                    else {\r\n                        _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, formatErrorMessageXdr(xdr));\r\n                    }\r\n                }\r\n            }\r\n            function _getSendPostMgrConfig() {\r\n                var _a;\r\n                try {\r\n                    var onCompleteFuncs = {\r\n                        xdrOnComplete: function (xdr, oncomplete, payload) {\r\n                            var data = _getPayloadArr(payload);\r\n                            if (!data) {\r\n                                return;\r\n                            }\r\n                            return _xdrOnLoad(xdr, data);\r\n                        },\r\n                        fetchOnComplete: function (response, onComplete, resValue, payload) {\r\n                            var data = _getPayloadArr(payload);\r\n                            if (!data) {\r\n                                return;\r\n                            }\r\n                            return _checkResponsStatus(response.status, data, response.url, data[_DYN_LENGTH /* @min:%2elength */], response.statusText, resValue || \"\");\r\n                        },\r\n                        xhrOnComplete: function (request, oncomplete, payload) {\r\n                            var data = _getPayloadArr(payload);\r\n                            if (!data) {\r\n                                return;\r\n                            }\r\n                            return _xhrReadyStateChange(request, data, data[_DYN_LENGTH /* @min:%2elength */]);\r\n                        },\r\n                        beaconOnRetry: function (data, onComplete, canSend) {\r\n                            return _onBeaconRetry(data, onComplete, canSend);\r\n                        }\r\n                    };\r\n                    var config = (_a = {},\r\n                        _a[_DYN_ENABLE_SEND_PROMISE /* @min:enableSendPromise */] = _enableSendPromise,\r\n                        _a.isOneDs = false,\r\n                        _a.disableCredentials = false,\r\n                        _a[_DYN_DISABLE_XHR /* @min:disableXhr */] = _disableXhr,\r\n                        _a.disableBeacon = !_beaconNormalSupported,\r\n                        _a.disableBeaconSync = !_beaconOnUnloadSupported,\r\n                        _a.senderOnCompleteCallBack = onCompleteFuncs,\r\n                        _a);\r\n                    return config;\r\n                }\r\n                catch (e) {\r\n                    // eslint-disable-next-line no-empty\r\n                }\r\n                return null;\r\n            }\r\n            /**\r\n             * xhr state changes\r\n             */\r\n            function _xhrReadyStateChange(xhr, payload, countOfItemsInPayload) {\r\n                if (xhr.readyState === 4) {\r\n                    _checkResponsStatus(xhr.status, payload, xhr.responseURL, countOfItemsInPayload, formatErrorMessageXhr(xhr), _getResponseText(xhr) || xhr.response);\r\n                }\r\n            }\r\n            /**\r\n             * error handler\r\n             */\r\n            function _onError(payload, message, event) {\r\n                _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 26 /* _eInternalMessageId.OnError */, \"Failed to send telemetry.\", { message: message });\r\n                _self._buffer && _self._buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\r\n            }\r\n            /**\r\n             * partial success handler\r\n             */\r\n            function _onPartialSuccess(payload, results) {\r\n                var failed = [];\r\n                var retry = [];\r\n                // Iterate through the reversed array of errors so that splicing doesn't have invalid indexes after the first item.\r\n                var errors = results.errors.reverse();\r\n                for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\r\n                    var error = errors_1[_i];\r\n                    var extracted = payload.splice(error.index, 1)[0];\r\n                    if (_isRetriable(error.statusCode)) {\r\n                        retry[_DYN_PUSH /* @min:%2epush */](extracted);\r\n                    }\r\n                    else {\r\n                        // All other errors, including: 402 (Monthly quota exceeded) and 439 (Too many requests and refresh cache).\r\n                        failed[_DYN_PUSH /* @min:%2epush */](extracted);\r\n                    }\r\n                }\r\n                if (payload[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */]);\r\n                }\r\n                if (failed[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    _self[_DYN__ON_ERROR /* @min:%2e_onError */](failed, formatErrorMessageXhr(null, [\"partial success\", results[_DYN_ITEMS_ACCEPTED /* @min:%2eitemsAccepted */], \"of\", results.itemsReceived].join(\" \")));\r\n                }\r\n                if (retry[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    _resendPayload(retry);\r\n                    _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \"Partial success. \" +\r\n                        \"Delivered: \" + payload[_DYN_LENGTH /* @min:%2elength */] + \", Failed: \" + failed[_DYN_LENGTH /* @min:%2elength */] +\r\n                        \". Will retry to send \" + retry[_DYN_LENGTH /* @min:%2elength */] + \" our of \" + results[_DYN_ITEMS_RECEIVED /* @min:%2eitemsReceived */] + \" items\");\r\n                }\r\n            }\r\n            /**\r\n             * success handler\r\n             */\r\n            function _onSuccess(payload, countOfItemsInPayload) {\r\n                _self._buffer && _self._buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\r\n            }\r\n            function _getPayloadArr(payload) {\r\n                try {\r\n                    if (payload) {\r\n                        var internalPayload = payload;\r\n                        var arr = internalPayload[_DYN_ORI_PAYLOAD /* @min:%2eoriPayload */];\r\n                        if (arr && arr[_DYN_LENGTH /* @min:%2elength */]) {\r\n                            return arr;\r\n                        }\r\n                        return null;\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // eslint-disable-next-line no-empty\r\n                }\r\n                return null;\r\n            }\r\n            function _validate(telemetryItem, diagLogger) {\r\n                if (_disableTelemetry) {\r\n                    // Do not send/save data\r\n                    return false;\r\n                }\r\n                // validate input\r\n                if (!telemetryItem) {\r\n                    diagLogger && _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 7 /* _eInternalMessageId.CannotSendEmptyTelemetry */, \"Cannot send empty telemetry\");\r\n                    return false;\r\n                }\r\n                // validate event\r\n                if (telemetryItem.baseData && !telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */]) {\r\n                    diagLogger && _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 70 /* _eInternalMessageId.InvalidEvent */, \"Cannot send telemetry without baseData and baseType\");\r\n                    return false;\r\n                }\r\n                if (!telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */]) {\r\n                    // Default\r\n                    telemetryItem[_DYN_BASE_TYPE /* @min:%2ebaseType */] = \"EventData\";\r\n                }\r\n                // ensure a sender was constructed\r\n                if (!_self[_DYN__SENDER /* @min:%2e_sender */]) {\r\n                    diagLogger && _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"Sender was not initialized\");\r\n                    return false;\r\n                }\r\n                // check if this item should be sampled in, else add sampleRate tag\r\n                if (!_isSampledIn(telemetryItem)) {\r\n                    // Item is sampled out, do not send it\r\n                    diagLogger && _throwInternal(diagLogger, 2 /* eLoggingSeverity.WARNING */, 33 /* _eInternalMessageId.TelemetrySampledAndNotSent */, \"Telemetry item was sampled out and not sent\", { SampleRate: _self._sample[_DYN_SAMPLE_RATE /* @min:%2esampleRate */] });\r\n                    return false;\r\n                }\r\n                else {\r\n                    telemetryItem[SampleRate] = _self._sample[_DYN_SAMPLE_RATE /* @min:%2esampleRate */];\r\n                }\r\n                return true;\r\n            }\r\n            function _getEnvelope(telemetryItem, diagLogger) {\r\n                // construct an envelope that Application Insights endpoint can understand\r\n                // if ikey of telemetry is provided and not empty, envelope will use this iKey instead of senderConfig iKey\r\n                var defaultEnvelopeIkey = telemetryItem.iKey || _instrumentationKey;\r\n                var aiEnvelope = Sender.constructEnvelope(telemetryItem, defaultEnvelopeIkey, diagLogger, _convertUndefined);\r\n                if (!aiEnvelope) {\r\n                    _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 47 /* _eInternalMessageId.CreateEnvelopeError */, \"Unable to create an AppInsights envelope\");\r\n                    return;\r\n                }\r\n                var doNotSendItem = false;\r\n                // this is for running in legacy mode, where customer may already have a custom initializer present\r\n                if (telemetryItem[_DYN_TAGS /* @min:%2etags */] && telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy]) {\r\n                    arrForEach(telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy], function (callBack) {\r\n                        try {\r\n                            if (callBack && callBack(aiEnvelope) === false) {\r\n                                doNotSendItem = true;\r\n                                _warnToConsole(diagLogger, \"Telemetry processor check returns false\");\r\n                            }\r\n                        }\r\n                        catch (e) {\r\n                            // log error but dont stop executing rest of the telemetry initializers\r\n                            // doNotSendItem = true;\r\n                            _throwInternal(diagLogger, 1 /* eLoggingSeverity.CRITICAL */, 64 /* _eInternalMessageId.TelemetryInitializerFailed */, \"One of telemetry initializers failed, telemetry item will not be sent: \" + getExceptionName(e), { exception: dumpObj(e) }, true);\r\n                        }\r\n                    });\r\n                    delete telemetryItem[_DYN_TAGS /* @min:%2etags */][ProcessLegacy];\r\n                }\r\n                if (doNotSendItem) {\r\n                    return; // do not send, no need to execute next plugin\r\n                }\r\n                return aiEnvelope;\r\n            }\r\n            function _serialize(item) {\r\n                var rlt = EMPTY_STR;\r\n                var diagLogger = _self[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\r\n                try {\r\n                    var valid = _validate(item, diagLogger);\r\n                    var envelope = null;\r\n                    if (valid) {\r\n                        envelope = _getEnvelope(item, diagLogger);\r\n                    }\r\n                    if (envelope) {\r\n                        rlt = _serializer[_DYN_SERIALIZE /* @min:%2eserialize */](envelope);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // eslint-disable-next-line no-empty\r\n                }\r\n                return rlt;\r\n            }\r\n            function _batch(arr) {\r\n                var rlt = EMPTY_STR;\r\n                if (arr && arr[_DYN_LENGTH /* @min:%2elength */]) {\r\n                    rlt = \"[\" + arr.join(\",\") + \"]\";\r\n                }\r\n                return rlt;\r\n            }\r\n            function _createPayload(data) {\r\n                var _a;\r\n                var headers = _getHeaders();\r\n                return _a = {\r\n                        urlString: _endpointUrl\r\n                    },\r\n                    _a[_DYN_DATA /* @min:data */] = data,\r\n                    _a.headers = headers,\r\n                    _a;\r\n            }\r\n            function _isSampledIn(envelope) {\r\n                return _self._sample.isSampledIn(envelope);\r\n            }\r\n            function _getOnComplete(payload, status, headers, response) {\r\n                // ***********************************************************************************************\r\n                //TODO: handle other status codes\r\n                if (status === 200 && payload) {\r\n                    _self._onSuccess(payload, payload[_DYN_LENGTH /* @min:%2elength */]);\r\n                }\r\n                else {\r\n                    response && _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, response);\r\n                }\r\n            }\r\n            function _doSend(sendInterface, payload, isAsync, markAsSent) {\r\n                if (markAsSent === void 0) { markAsSent = true; }\r\n                var onComplete = function (status, headers, response) {\r\n                    return _getOnComplete(payload, status, headers, response);\r\n                };\r\n                var payloadData = _getPayload(payload);\r\n                var sendPostFunc = sendInterface && sendInterface.sendPOST;\r\n                if (sendPostFunc && payloadData) {\r\n                    // ***********************************************************************************************\r\n                    // mark payload as sent at the beginning of calling each send function\r\n                    if (markAsSent) {\r\n                        _self._buffer[_DYN_MARK_AS_SENT /* @min:%2emarkAsSent */](payload);\r\n                    }\r\n                    return sendPostFunc(payloadData, onComplete, !isAsync);\r\n                }\r\n                return null;\r\n            }\r\n            function _getPayload(payload) {\r\n                var _a;\r\n                if (isArray(payload) && payload[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    var batch = _self[_DYN__BUFFER /* @min:%2e_buffer */].batchPayloads(payload);\r\n                    var headers = _getHeaders();\r\n                    var payloadData = (_a = {},\r\n                        _a[_DYN_DATA /* @min:data */] = batch,\r\n                        _a.urlString = _endpointUrl,\r\n                        _a.headers = headers,\r\n                        _a.disableXhrSync = _disableXhr,\r\n                        _a.disableFetchKeepAlive = !_fetchKeepAlive,\r\n                        _a[_DYN_ORI_PAYLOAD /* @min:oriPayload */] = payload,\r\n                        _a);\r\n                    return payloadData;\r\n                }\r\n                return null;\r\n            }\r\n            function _getHeaders() {\r\n                try {\r\n                    var headers = _headers || {};\r\n                    if (isInternalApplicationInsightsEndpoint(_endpointUrl)) {\r\n                        headers[RequestHeaders[6 /* eRequestHeaders.sdkContextHeader */]] = RequestHeaders[7 /* eRequestHeaders.sdkContextHeaderAppIdRequest */];\r\n                    }\r\n                    return headers;\r\n                }\r\n                catch (e) {\r\n                    // eslint-disable-next-line no-empty\r\n                }\r\n                return null;\r\n            }\r\n            function _checkMaxSize(incomingPayload) {\r\n                var incomingSize = incomingPayload ? incomingPayload[_DYN_LENGTH /* @min:%2elength */] : 0;\r\n                if ((_self[_DYN__BUFFER /* @min:%2e_buffer */].size() + incomingSize) > _maxBatchSizeInBytes) {\r\n                    if (!_offlineListener || _offlineListener.isOnline()) { // only trigger send when currently online\r\n                        _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 10 /* SendRequestReason.MaxBatchSize */);\r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            function _checkResponsStatus(status, payload, responseUrl, countOfItemsInPayload, errorMessage, res) {\r\n                var response = null;\r\n                if (!_self._appId) {\r\n                    response = parseResponse(res);\r\n                    if (response && response.appId) {\r\n                        _self._appId = response.appId;\r\n                    }\r\n                }\r\n                if ((status < 200 || status >= 300) && status !== 0) {\r\n                    // Update End Point url if permanent redirect or moved permanently\r\n                    // Updates the end point url before retry\r\n                    if (status === 301 || status === 307 || status === 308) {\r\n                        if (!_checkAndUpdateEndPointUrl(responseUrl)) {\r\n                            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (_offlineListener && !_offlineListener.isOnline()) { // offline\r\n                        // Note: Don't check for status == 0, since adblock gives this code\r\n                        if (!_isRetryDisabled) {\r\n                            var offlineBackOffMultiplier = 10; // arbritrary number\r\n                            _resendPayload(payload, offlineBackOffMultiplier);\r\n                            _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". Offline - Response Code: \".concat(status, \". Offline status: \").concat(!_offlineListener.isOnline(), \". Will retry to send \").concat(payload.length, \" items.\"));\r\n                        }\r\n                        return;\r\n                    }\r\n                    if (!_isRetryDisabled && _isRetriable(status)) {\r\n                        _resendPayload(payload);\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" +\r\n                            \"Response code \" + status + \". Will retry to send \" + payload[_DYN_LENGTH /* @min:%2elength */] + \" items.\");\r\n                    }\r\n                    else {\r\n                        _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\r\n                    }\r\n                }\r\n                else {\r\n                    // check if the xhr's responseURL or fetch's response.url is same as endpoint url\r\n                    // TODO after 10 redirects force send telemetry with 'redirect=false' as query parameter.\r\n                    _checkAndUpdateEndPointUrl(responseUrl);\r\n                    if (status === 206) {\r\n                        if (!response) {\r\n                            response = parseResponse(res);\r\n                        }\r\n                        if (response && !_isRetryDisabled) {\r\n                            _self[_DYN__ON_PARTIAL_SUCCESS /* @min:%2e_onPartialSuccess */](payload, response);\r\n                        }\r\n                        else {\r\n                            _self[_DYN__ON_ERROR /* @min:%2e_onError */](payload, errorMessage);\r\n                        }\r\n                    }\r\n                    else {\r\n                        _consecutiveErrors = 0;\r\n                        _self[_DYN__ON_SUCCESS /* @min:%2e_onSuccess */](payload, countOfItemsInPayload);\r\n                    }\r\n                }\r\n            }\r\n            function _checkAndUpdateEndPointUrl(responseUrl) {\r\n                // Maximum stamp specific redirects allowed(uncomment this when breeze is ready with not allowing redirects feature)\r\n                if (_stamp_specific_redirects >= 10) {\r\n                    //  _self._senderConfig.endpointUrl = () => Sender._getDefaultAppInsightsChannelConfig().endpointUrl()+\"/?redirect=false\";\r\n                    //  _stamp_specific_redirects = 0;\r\n                    return false;\r\n                }\r\n                if (!isNullOrUndefined(responseUrl) && responseUrl !== \"\") {\r\n                    if (responseUrl !== _endpointUrl) {\r\n                        _endpointUrl = responseUrl;\r\n                        ++_stamp_specific_redirects;\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n            function _doUnloadSend(payload, isAsync) {\r\n                if (_syncUnloadSender) {\r\n                    // We are unloading so always call the sender with sync set to false\r\n                    _syncUnloadSender(payload, false);\r\n                }\r\n                else {\r\n                    // Fallback to the previous beacon Sender (which causes a CORB warning on chrome now)\r\n                    var beaconInst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST /* @min:%2egetSenderInst */]([3 /* TransportType.Beacon */], true);\r\n                    return _doSend(beaconInst, payload, isAsync);\r\n                }\r\n            }\r\n            function _onBeaconRetry(payload, onComplete, canSend) {\r\n                var internalPayload = payload;\r\n                var data = internalPayload && internalPayload[_DYN_ORI_PAYLOAD /* @min:%2eoriPayload */];\r\n                if (!_disableBeaconSplit) {\r\n                    // Failed to send entire payload so try and split data and try to send as much events as possible\r\n                    var droppedPayload = [];\r\n                    for (var lp = 0; lp < data[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n                        var thePayload = data[lp];\r\n                        var arr = [thePayload];\r\n                        var item = _getPayload(arr);\r\n                        if (!canSend(item, onComplete)) {\r\n                            // Can't send anymore, so split the batch and drop the rest\r\n                            droppedPayload[_DYN_PUSH /* @min:%2epush */](thePayload);\r\n                        }\r\n                        else {\r\n                            _self._onSuccess(arr, arr[_DYN_LENGTH /* @min:%2elength */]);\r\n                        }\r\n                    }\r\n                    if (droppedPayload[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                        _fallbackSend && _fallbackSend(droppedPayload, true);\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\r\n                    }\r\n                }\r\n                else {\r\n                    _fallbackSend && _fallbackSend(data, true);\r\n                    _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with normal sender.\");\r\n                }\r\n            }\r\n            function _isStringArr(arr) {\r\n                try {\r\n                    if (arr && arr[_DYN_LENGTH /* @min:%2elength */]) {\r\n                        return (isString(arr[0]));\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    //TODO: log, sender use IInternalStorageItem instead of string since 3.1.3\r\n                }\r\n                return null;\r\n            }\r\n            function _fetchKeepAliveSender(payload, isAsync) {\r\n                var transport = null;\r\n                if (isArray(payload)) {\r\n                    var payloadSize = payload[_DYN_LENGTH /* @min:%2elength */];\r\n                    for (var lp = 0; lp < payload[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n                        payloadSize += payload[lp].item[_DYN_LENGTH /* @min:%2elength */];\r\n                    }\r\n                    var syncFetchPayload = _sendPostMgr.getSyncFetchPayload();\r\n                    if ((syncFetchPayload + payloadSize) <= FetchSyncRequestSizeLimitBytes) {\r\n                        transport = 2 /* TransportType.Fetch */;\r\n                    }\r\n                    else if (isBeaconsSupported()) {\r\n                        // Fallback to beacon sender as we at least get told which events can't be scheduled\r\n                        transport = 3 /* TransportType.Beacon */;\r\n                    }\r\n                    else {\r\n                        // Payload is going to be too big so just try and send via XHR\r\n                        transport = 1 /* TransportType.Xhr */;\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 2 /* eLoggingSeverity.WARNING */, 40 /* _eInternalMessageId.TransmissionFailed */, \". \" + \"Failed to send telemetry with Beacon API, retried with xhrSender.\");\r\n                    }\r\n                    var inst = _sendPostMgr && _sendPostMgr[_DYN_GET_SENDER_INST /* @min:%2egetSenderInst */]([transport], true);\r\n                    return _doSend(inst, payload, isAsync);\r\n                }\r\n                return null;\r\n            }\r\n            /**\r\n             * Resend payload. Adds payload back to the send buffer and setup a send timer (with exponential backoff).\r\n             * @param payload\r\n             */\r\n            function _resendPayload(payload, linearFactor) {\r\n                if (linearFactor === void 0) { linearFactor = 1; }\r\n                if (!payload || payload[_DYN_LENGTH /* @min:%2elength */] === 0) {\r\n                    return;\r\n                }\r\n                var buffer = _self[_DYN__BUFFER /* @min:%2e_buffer */];\r\n                buffer[_DYN_CLEAR_SENT /* @min:%2eclearSent */](payload);\r\n                _consecutiveErrors++;\r\n                for (var _i = 0, payload_1 = payload; _i < payload_1.length; _i++) {\r\n                    var item = payload_1[_i];\r\n                    item.cnt = item.cnt || 0; // to make sure we have cnt for each payload\r\n                    item.cnt++; // when resend, increase cnt\r\n                    buffer[_DYN_ENQUEUE /* @min:%2eenqueue */](item);\r\n                }\r\n                // setup timer\r\n                _setRetryTime(linearFactor);\r\n                _setupTimer();\r\n            }\r\n            /**\r\n             * Calculates the time to wait before retrying in case of an error based on\r\n             * http://en.wikipedia.org/wiki/Exponential_backoff\r\n             */\r\n            function _setRetryTime(linearFactor) {\r\n                var SlotDelayInSeconds = 10;\r\n                var delayInSeconds;\r\n                if (_consecutiveErrors <= 1) {\r\n                    delayInSeconds = SlotDelayInSeconds;\r\n                }\r\n                else {\r\n                    var backOffSlot = (Math.pow(2, _consecutiveErrors) - 1) / 2;\r\n                    // tslint:disable-next-line:insecure-random\r\n                    var backOffDelay = Math.floor(Math.random() * backOffSlot * SlotDelayInSeconds) + 1;\r\n                    backOffDelay = linearFactor * backOffDelay;\r\n                    delayInSeconds = Math.max(Math.min(backOffDelay, 3600), SlotDelayInSeconds);\r\n                }\r\n                // TODO: Log the backoff time like the C# version does.\r\n                var retryAfterTimeSpan = dateNow() + (delayInSeconds * 1000);\r\n                // TODO: Log the retry at time like the C# version does.\r\n                _retryAt = retryAfterTimeSpan;\r\n            }\r\n            /**\r\n             * Sets up the timer which triggers actually sending the data.\r\n             */\r\n            function _setupTimer() {\r\n                if (!_timeoutHandle && !_paused) {\r\n                    var retryInterval = _retryAt ? Math.max(0, _retryAt - dateNow()) : 0;\r\n                    var timerValue = Math.max(_maxBatchInterval, retryInterval);\r\n                    _timeoutHandle = scheduleTimeout(function () {\r\n                        _timeoutHandle = null;\r\n                        _self[_DYN_TRIGGER_SEND /* @min:%2etriggerSend */](true, null, 1 /* SendRequestReason.NormalSchedule */);\r\n                    }, timerValue);\r\n                }\r\n            }\r\n            function _clearScheduledTimer() {\r\n                _timeoutHandle && _timeoutHandle.cancel();\r\n                _timeoutHandle = null;\r\n                _retryAt = null;\r\n            }\r\n            /**\r\n             * Checks if the SDK should resend the payload after receiving this status code from the backend.\r\n             * @param statusCode\r\n             */\r\n            function _isRetriable(statusCode) {\r\n                // retryCodes = [] means should not retry\r\n                if (!isNullOrUndefined(_retryCodes)) {\r\n                    return _retryCodes[_DYN_LENGTH /* @min:%2elength */] && _retryCodes.indexOf(statusCode) > -1;\r\n                }\r\n                return statusCode === 401 // Unauthorized\r\n                    // Removing as private links can return a 403 which causes excessive retries and session storage usage\r\n                    // || statusCode === 403 // Forbidden\r\n                    || statusCode === 408 // Timeout\r\n                    || statusCode === 429 // Too many requests.\r\n                    || statusCode === 500 // Internal server error.\r\n                    || statusCode === 502 // Bad Gateway.\r\n                    || statusCode === 503 // Service unavailable.\r\n                    || statusCode === 504; // Gateway timeout.\r\n            }\r\n            // Using function lookups for backward compatibility as the getNotifyMgr() did not exist until after v2.5.6\r\n            function _getNotifyMgr() {\r\n                var func = \"getNotifyMgr\";\r\n                if (_self.core[func]) {\r\n                    return _self.core[func]();\r\n                }\r\n                // using _self.core['_notificationManager'] for backward compatibility\r\n                return _self.core[\"_notificationManager\"];\r\n            }\r\n            function _notifySendRequest(sendRequest, isAsync) {\r\n                var manager = _getNotifyMgr();\r\n                if (manager && manager[_DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */]) {\r\n                    try {\r\n                        manager[_DYN_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendRequest, isAsync);\r\n                    }\r\n                    catch (e) {\r\n                        _throwInternal(_self[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, \"send request notification failed: \" + getExceptionName(e), { exception: dumpObj(e) });\r\n                    }\r\n                }\r\n            }\r\n            /**\r\n             * Validate UUID Format\r\n             * Specs taken from https://tools.ietf.org/html/rfc4122 and breeze repo\r\n             */\r\n            function _validateInstrumentationKey(instrumentationKey, config) {\r\n                var disableValidation = config.disableInstrumentationKeyValidation;\r\n                var disableIKeyValidationFlag = isNullOrUndefined(disableValidation) ? false : disableValidation;\r\n                if (disableIKeyValidationFlag) {\r\n                    return true;\r\n                }\r\n                var UUID_Regex = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\";\r\n                var regexp = new RegExp(UUID_Regex);\r\n                return regexp.test(instrumentationKey);\r\n            }\r\n            function _initDefaults() {\r\n                _self[_DYN__SENDER /* @min:%2e_sender */] = null;\r\n                _self[_DYN__BUFFER /* @min:%2e_buffer */] = null;\r\n                _self._appId = null;\r\n                _self._sample = null;\r\n                _headers = {};\r\n                _offlineListener = null;\r\n                _consecutiveErrors = 0;\r\n                _retryAt = null;\r\n                _lastSend = null;\r\n                _paused = false;\r\n                _timeoutHandle = null;\r\n                _serializer = null;\r\n                _stamp_specific_redirects = 0;\r\n                _syncFetchPayload = 0;\r\n                _syncUnloadSender = null;\r\n                _evtNamespace = null;\r\n                _endpointUrl = null;\r\n                _orgEndpointUrl = null;\r\n                _maxBatchSizeInBytes = 0;\r\n                _beaconSupported = false;\r\n                _customHeaders = null;\r\n                _disableTelemetry = false;\r\n                _instrumentationKey = null;\r\n                _convertUndefined = UNDEFINED_VALUE;\r\n                _isRetryDisabled = false;\r\n                _sessionStorageUsed = null;\r\n                _namePrefix = UNDEFINED_VALUE;\r\n                _disableXhr = false;\r\n                _fetchKeepAlive = false;\r\n                _disableBeaconSplit = false;\r\n                _xhrSend = null;\r\n                _fallbackSend = null;\r\n                _sendPostMgr = null;\r\n                objDefine(_self, \"_senderConfig\", {\r\n                    g: function () {\r\n                        return objExtend({}, defaultAppInsightsChannelConfig);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    Sender.constructEnvelope = function (orig, iKey, logger, convertUndefined) {\r\n        var envelope;\r\n        if (iKey !== orig.iKey && !isNullOrUndefined(iKey)) {\r\n            envelope = __assign(__assign({}, orig), { iKey: iKey });\r\n        }\r\n        else {\r\n            envelope = orig;\r\n        }\r\n        var creator = EnvelopeTypeCreator[envelope.baseType] || EventEnvelopeCreator;\r\n        return creator(logger, envelope, convertUndefined);\r\n    };\r\n    /**\r\n     * Pause the sending (transmission) of events, this will cause all events to be batched only until the maximum limits are\r\n     * hit at which point new events are dropped. Will also cause events to NOT be sent during page unload, so if Session storage\r\n     * is disabled events will be lost.\r\n     * SessionStorage Limit is 2000 events, In-Memory (Array) Storage is 10,000 events (can be configured via the eventsLimitInMem).\r\n     */\r\n    Sender.prototype.pause = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Resume the sending (transmission) of events, this will restart the timer and any batched events will be sent using the normal\r\n     * send interval.\r\n     */\r\n    Sender.prototype.resume = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Flush to send data immediately; channel should default to sending data asynchronously. If executing asynchronously (the default) and\r\n     * you DO NOT pass a callback function then a [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * will be returned which will resolve once the flush is complete. The actual implementation of the `IPromise`\r\n     * will be a native Promise (if supported) or the default as supplied by [ts-async library](https://github.com/nevware21/ts-async)\r\n     * @param async - send data asynchronously when true\r\n     * @param callBack - if specified, notify caller when send is complete, the channel should return true to indicate to the caller that it will be called.\r\n     * If the caller doesn't return true the caller should assume that it may never be called.\r\n     * @param sendReason - specify the reason that you are calling \"flush\" defaults to ManualFlush (1) if not specified\r\n     * @returns - If a callback is provided `true` to indicate that callback will be called after the flush is complete otherwise the caller\r\n     * should assume that any provided callback will never be called, Nothing or if occurring asynchronously a\r\n     * [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html) which will be resolved once the unload is complete,\r\n     * the [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html) will only be returned when no callback is provided\r\n     * and async is true.\r\n     */\r\n    Sender.prototype.flush = function (async, callBack) {\r\n        if (async === void 0) { async = true; }\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Flush the batched events synchronously (if possible -- based on configuration).\r\n     * Will not flush if the Send has been paused.\r\n     */\r\n    Sender.prototype.onunloadFlush = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.initialize = function (config, core, extensions, pluginChain) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    Sender.prototype.processTelemetry = function (telemetryItem, itemCtx) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * xhr state changes\r\n     * @deprecated\r\n     * since version 3.2.0, if the payload is string[], this function is no-op (string[] is only used for backwards Compatibility)\r\n     */\r\n    Sender.prototype._xhrReadyStateChange = function (xhr, payload, countOfItemsInPayload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        // TODO: no-op\r\n        // add note to users, this will be removed\r\n    };\r\n    /**\r\n     * Trigger the immediate send of buffered data; If executing asynchronously (the default) this may (not required) return\r\n     * an [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html) that will resolve once the\r\n     * send is complete. The actual implementation of the `IPromise` will be a native Promise (if supported) or the default\r\n     * as supplied by [ts-async library](https://github.com/nevware21/ts-async)\r\n     * @param async - Indicates if the events should be sent asynchronously\r\n     * @param forcedSender - {SenderFunction} - Indicates the forcedSender, undefined if not passed\r\n     * @returns - Nothing or optionally, if occurring asynchronously a [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * which will be resolved (or reject) once the send is complete, the [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * should only be returned when async is true.\r\n     */\r\n    Sender.prototype.triggerSend = function (async, forcedSender, sendReason) {\r\n        if (async === void 0) { async = true; }\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * error handler\r\n     * @Internal\r\n     * since version 3.2.0, if the payload is string[], this function is no-op (string[] is only used for backwards Compatibility)\r\n     */\r\n    Sender.prototype._onError = function (payload, message, event) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * partial success handler\r\n     * @Internal\r\n     * since version 3.2.0, if the payload is string[], this function is no-op (string[] is only used for backwards Compatibility)\r\n     */\r\n    Sender.prototype._onPartialSuccess = function (payload, results) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * success handler\r\n     * @Internal\r\n     * since version 3.2.0, if the payload is string[], this function is no-op (string[] is only used for backwards Compatibility)\r\n     */\r\n    Sender.prototype._onSuccess = function (payload, countOfItemsInPayload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * xdr state changes\r\n     * @deprecated\r\n     * since version 3.2.0, if the payload is string[], this function is no-op (string[] is only used for backwards Compatibility)\r\n     */\r\n    Sender.prototype._xdrOnLoad = function (xdr, payload) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add header to request\r\n     * @param name - Header name.\r\n     * @param value - Header value.\r\n     */\r\n    Sender.prototype.addHeader = function (name, value) {\r\n        // @DynamicProtoStub - DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Check if there are no active requests being sent.\r\n     * @returns True if idle, false otherwise.\r\n     */\r\n    Sender.prototype.isCompletelyIdle = function () {\r\n        // @DynamicProtoStub - DO NOT add any code as this will be removed during packaging\r\n        return false;\r\n    };\r\n    /**\r\n     * Get Offline Serializer support\r\n     * @returns internal Offline Serializer object\r\n     */\r\n    Sender.prototype.getOfflineSupport = function () {\r\n        // @DynamicProtoStub - DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    return Sender;\r\n}(BaseTelemetryPlugin));\r\nexport { Sender };\r\n//# sourceMappingURL=Sender.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}