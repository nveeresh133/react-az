{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { createAllPromise, createPromise, doAwaitResponse } from \"@nevware21/ts-async\";\nimport { arrForEach, arrIndexOf, objDefine, safe, scheduleTimeout } from \"@nevware21/ts-utils\";\nimport { createDynamicConfig } from \"../Config/DynamicConfig\";\nimport { _DYN_ADD_NOTIFICATION_LIS1, _DYN_CANCEL, _DYN_DATA, _DYN_IS_ASYNC, _DYN_IS_CHILD_EVT, _DYN_LENGTH, _DYN_PUSH, _DYN_REMOVE_NOTIFICATION_0, _DYN_SPLICE, _DYN_UNLOAD, _DYN_WATCH } from \"../__DynamicConstants\";\nimport { STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_EVENTS_SENT, STR_OFFLINE_DROP, STR_OFFLINE_SENT, STR_OFFLINE_STORE, STR_PERF_EVENT } from \"./InternalConstants\";\nvar defaultValues = {\n  perfEvtsSendAll: false\n};\nfunction _runScheduledListeners(asyncNotifications) {\n  asyncNotifications.h = null;\n  var callbacks = asyncNotifications.cb;\n  asyncNotifications.cb = [];\n  arrForEach(callbacks, function (cb) {\n    // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running\n    safe(cb.fn, [cb.arg]);\n  });\n}\n// This function is used to combine the logic of running the listeners and handling the async notifications so that they don't\n// create multiple timers if there are multiple async listeners.\nfunction _runListeners(listeners, name, asyncNotifications, callback) {\n  arrForEach(listeners, function (listener) {\n    if (listener && listener[name]) {\n      if (asyncNotifications) {\n        // Schedule the callback to be called after the current call stack has cleared.\n        asyncNotifications.cb[_DYN_PUSH /* @min:%2epush */]({\n          fn: callback,\n          arg: listener\n        });\n        asyncNotifications.h = asyncNotifications.h || scheduleTimeout(_runScheduledListeners, 0, asyncNotifications);\n      } else {\n        // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running\n        safe(callback, [listener]);\n      }\n    }\n  });\n}\n/**\r\n * Class to manage sending notifications to all the listeners.\r\n */\nvar NotificationManager = /** @class */function () {\n  function NotificationManager(config) {\n    this.listeners = [];\n    var perfEvtsSendAll;\n    var unloadHandler;\n    var _listeners = [];\n    var _asyncNotifications = {\n      h: null,\n      cb: []\n    };\n    var cfgHandler = createDynamicConfig(config, defaultValues);\n    unloadHandler = cfgHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\n      perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;\n    });\n    dynamicProto(NotificationManager, this, function (_self) {\n      objDefine(_self, \"listeners\", {\n        g: function () {\n          return _listeners;\n        }\n      });\n      _self[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {\n        _listeners[_DYN_PUSH /* @min:%2epush */](listener);\n      };\n      /**\r\n       * Removes all instances of the listener.\r\n       * @param listener - AWTNotificationListener to remove.\r\n       */\n      _self[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {\n        var index = arrIndexOf(_listeners, listener);\n        while (index > -1) {\n          _listeners[_DYN_SPLICE /* @min:%2esplice */](index, 1);\n          index = arrIndexOf(_listeners, listener);\n        }\n      };\n      /**\r\n       * Notification for events sent.\r\n       * @param events - The array of events that have been sent.\r\n       */\n      _self[STR_EVENTS_SENT /* @min:%2eeventsSent */] = function (events) {\n        _runListeners(_listeners, STR_EVENTS_SENT, _asyncNotifications, function (listener) {\n          listener[STR_EVENTS_SENT /* @min:%2eeventsSent */](events);\n        });\n      };\n      /**\r\n       * Notification for events being discarded.\r\n       * @param events - The array of events that have been discarded by the SDK.\r\n       * @param reason - The reason for which the SDK discarded the events. The EventsDiscardedReason\r\n       * constant should be used to check the different values.\r\n       */\n      _self[STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */] = function (events, reason) {\n        _runListeners(_listeners, STR_EVENTS_DISCARDED, _asyncNotifications, function (listener) {\n          listener[STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */](events, reason);\n        });\n      };\n      /**\r\n       * [Optional] A function called when the events have been requested to be sent to the sever.\r\n       * @param sendReason - The reason why the event batch is being sent.\r\n       * @param isAsync - A flag which identifies whether the requests are being sent in an async or sync manner.\r\n       */\n      _self[STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */] = function (sendReason, isAsync) {\n        _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function (listener) {\n          listener[STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendReason, isAsync);\n        });\n      };\n      _self[STR_PERF_EVENT /* @min:%2eperfEvent */] = function (perfEvent) {\n        if (perfEvent) {\n          // Send all events or only parent events\n          if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */]()) {\n            _runListeners(_listeners, STR_PERF_EVENT, null, function (listener) {\n              if (perfEvent[_DYN_IS_ASYNC /* @min:%2eisAsync */]) {\n                scheduleTimeout(function () {\n                  return listener[STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);\n                }, 0);\n              } else {\n                listener[STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);\n              }\n            });\n          }\n        }\n      };\n      _self[STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */] = function (events) {\n        if (events && events[_DYN_LENGTH /* @min:%2elength */]) {\n          _runListeners(_listeners, STR_OFFLINE_STORE, _asyncNotifications, function (listener) {\n            listener[STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */](events);\n          });\n        }\n      };\n      _self[STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */] = function (batch) {\n        if (batch && batch[_DYN_DATA /* @min:%2edata */]) {\n          _runListeners(_listeners, STR_OFFLINE_SENT, _asyncNotifications, function (listener) {\n            listener[STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */](batch);\n          });\n        }\n      };\n      _self[STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */] = function (cnt, reason) {\n        if (cnt > 0) {\n          var rn_1 = reason || 0; // default is unknown\n          _runListeners(_listeners, STR_OFFLINE_DROP, _asyncNotifications, function (listener) {\n            listener[STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */](cnt, rn_1);\n          });\n        }\n      };\n      _self[_DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {\n        var _finishUnload = function () {\n          unloadHandler && unloadHandler.rm();\n          unloadHandler = null;\n          _listeners = [];\n          // Clear any async listener\n          _asyncNotifications.h && _asyncNotifications.h[_DYN_CANCEL /* @min:%2ecancel */]();\n          _asyncNotifications.h = null;\n          _asyncNotifications.cb = [];\n        };\n        var waiting;\n        _runListeners(_listeners, \"unload\", null, function (listener) {\n          var asyncUnload = listener[_DYN_UNLOAD /* @min:%2eunload */](isAsync);\n          if (asyncUnload) {\n            if (!waiting) {\n              waiting = [];\n            }\n            waiting[_DYN_PUSH /* @min:%2epush */](asyncUnload);\n          }\n        });\n        if (waiting) {\n          return createPromise(function (resolve) {\n            return doAwaitResponse(createAllPromise(waiting), function () {\n              _finishUnload();\n              resolve();\n            });\n          });\n        } else {\n          _finishUnload();\n        }\n      };\n    });\n  }\n  // Removed Stub for NotificationManager.prototype.addNotificationListener.\n  // Removed Stub for NotificationManager.prototype.removeNotificationListener.\n  // Removed Stub for NotificationManager.prototype.eventsSent.\n  // Removed Stub for NotificationManager.prototype.eventsDiscarded.\n  // Removed Stub for NotificationManager.prototype.eventsSendRequest.\n  // Removed Stub for NotificationManager.prototype.perfEvent.\n  // Removed Stub for NotificationManager.prototype.unload.\n  // Removed Stub for NotificationManager.prototype.offlineEventsStored.\n  // Removed Stub for NotificationManager.prototype.offlineBatchSent.\n  // Removed Stub for NotificationManager.prototype.offlineBatchDrop.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  NotificationManager.__ieDyn = 1;\n  return NotificationManager;\n}();\nexport { NotificationManager };","map":{"version":3,"names":["dynamicProto","createAllPromise","createPromise","doAwaitResponse","arrForEach","arrIndexOf","objDefine","safe","scheduleTimeout","createDynamicConfig","_DYN_ADD_NOTIFICATION_LIS1","_DYN_CANCEL","_DYN_DATA","_DYN_IS_ASYNC","_DYN_IS_CHILD_EVT","_DYN_LENGTH","_DYN_PUSH","_DYN_REMOVE_NOTIFICATION_0","_DYN_SPLICE","_DYN_UNLOAD","_DYN_WATCH","STR_EVENTS_DISCARDED","STR_EVENTS_SEND_REQUEST","STR_EVENTS_SENT","STR_OFFLINE_DROP","STR_OFFLINE_SENT","STR_OFFLINE_STORE","STR_PERF_EVENT","defaultValues","perfEvtsSendAll","_runScheduledListeners","asyncNotifications","h","callbacks","cb","fn","arg","_runListeners","listeners","name","callback","listener","NotificationManager","config","unloadHandler","_listeners","_asyncNotifications","cfgHandler","details","cfg","_self","g","index","events","reason","sendReason","isAsync","perfEvent","batch","cnt","rn_1","_finishUnload","rm","waiting","asyncUnload","resolve"],"sources":["/home/veeresh133/app/json-holder-api/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/NotificationManager.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { createAllPromise, createPromise, doAwaitResponse } from \"@nevware21/ts-async\";\r\nimport { arrForEach, arrIndexOf, objDefine, safe, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { createDynamicConfig } from \"../Config/DynamicConfig\";\r\nimport { _DYN_ADD_NOTIFICATION_LIS1, _DYN_CANCEL, _DYN_DATA, _DYN_IS_ASYNC, _DYN_IS_CHILD_EVT, _DYN_LENGTH, _DYN_PUSH, _DYN_REMOVE_NOTIFICATION_0, _DYN_SPLICE, _DYN_UNLOAD, _DYN_WATCH } from \"../__DynamicConstants\";\r\nimport { STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_EVENTS_SENT, STR_OFFLINE_DROP, STR_OFFLINE_SENT, STR_OFFLINE_STORE, STR_PERF_EVENT } from \"./InternalConstants\";\r\nvar defaultValues = {\r\n    perfEvtsSendAll: false\r\n};\r\nfunction _runScheduledListeners(asyncNotifications) {\r\n    asyncNotifications.h = null;\r\n    var callbacks = asyncNotifications.cb;\r\n    asyncNotifications.cb = [];\r\n    arrForEach(callbacks, function (cb) {\r\n        // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running\r\n        safe(cb.fn, [cb.arg]);\r\n    });\r\n}\r\n// This function is used to combine the logic of running the listeners and handling the async notifications so that they don't\r\n// create multiple timers if there are multiple async listeners.\r\nfunction _runListeners(listeners, name, asyncNotifications, callback) {\r\n    arrForEach(listeners, function (listener) {\r\n        if (listener && listener[name]) {\r\n            if (asyncNotifications) {\r\n                // Schedule the callback to be called after the current call stack has cleared.\r\n                asyncNotifications.cb[_DYN_PUSH /* @min:%2epush */]({\r\n                    fn: callback,\r\n                    arg: listener\r\n                });\r\n                asyncNotifications.h = asyncNotifications.h || scheduleTimeout(_runScheduledListeners, 0, asyncNotifications);\r\n            }\r\n            else {\r\n                // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running\r\n                safe(callback, [listener]);\r\n            }\r\n        }\r\n    });\r\n}\r\n/**\r\n * Class to manage sending notifications to all the listeners.\r\n */\r\nvar NotificationManager = /** @class */ (function () {\r\n    function NotificationManager(config) {\r\n        this.listeners = [];\r\n        var perfEvtsSendAll;\r\n        var unloadHandler;\r\n        var _listeners = [];\r\n        var _asyncNotifications = {\r\n            h: null,\r\n            cb: []\r\n        };\r\n        var cfgHandler = createDynamicConfig(config, defaultValues);\r\n        unloadHandler = cfgHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\r\n            perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;\r\n        });\r\n        dynamicProto(NotificationManager, this, function (_self) {\r\n            objDefine(_self, \"listeners\", {\r\n                g: function () { return _listeners; }\r\n            });\r\n            _self[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {\r\n                _listeners[_DYN_PUSH /* @min:%2epush */](listener);\r\n            };\r\n            /**\r\n             * Removes all instances of the listener.\r\n             * @param listener - AWTNotificationListener to remove.\r\n             */\r\n            _self[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {\r\n                var index = arrIndexOf(_listeners, listener);\r\n                while (index > -1) {\r\n                    _listeners[_DYN_SPLICE /* @min:%2esplice */](index, 1);\r\n                    index = arrIndexOf(_listeners, listener);\r\n                }\r\n            };\r\n            /**\r\n             * Notification for events sent.\r\n             * @param events - The array of events that have been sent.\r\n             */\r\n            _self[STR_EVENTS_SENT /* @min:%2eeventsSent */] = function (events) {\r\n                _runListeners(_listeners, STR_EVENTS_SENT, _asyncNotifications, function (listener) {\r\n                    listener[STR_EVENTS_SENT /* @min:%2eeventsSent */](events);\r\n                });\r\n            };\r\n            /**\r\n             * Notification for events being discarded.\r\n             * @param events - The array of events that have been discarded by the SDK.\r\n             * @param reason - The reason for which the SDK discarded the events. The EventsDiscardedReason\r\n             * constant should be used to check the different values.\r\n             */\r\n            _self[STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */] = function (events, reason) {\r\n                _runListeners(_listeners, STR_EVENTS_DISCARDED, _asyncNotifications, function (listener) {\r\n                    listener[STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */](events, reason);\r\n                });\r\n            };\r\n            /**\r\n             * [Optional] A function called when the events have been requested to be sent to the sever.\r\n             * @param sendReason - The reason why the event batch is being sent.\r\n             * @param isAsync - A flag which identifies whether the requests are being sent in an async or sync manner.\r\n             */\r\n            _self[STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */] = function (sendReason, isAsync) {\r\n                _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function (listener) {\r\n                    listener[STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendReason, isAsync);\r\n                });\r\n            };\r\n            _self[STR_PERF_EVENT /* @min:%2eperfEvent */] = function (perfEvent) {\r\n                if (perfEvent) {\r\n                    // Send all events or only parent events\r\n                    if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */]()) {\r\n                        _runListeners(_listeners, STR_PERF_EVENT, null, function (listener) {\r\n                            if (perfEvent[_DYN_IS_ASYNC /* @min:%2eisAsync */]) {\r\n                                scheduleTimeout(function () { return listener[STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent); }, 0);\r\n                            }\r\n                            else {\r\n                                listener[STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            _self[STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */] = function (events) {\r\n                if (events && events[_DYN_LENGTH /* @min:%2elength */]) {\r\n                    _runListeners(_listeners, STR_OFFLINE_STORE, _asyncNotifications, function (listener) {\r\n                        listener[STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */](events);\r\n                    });\r\n                }\r\n            };\r\n            _self[STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */] = function (batch) {\r\n                if (batch && batch[_DYN_DATA /* @min:%2edata */]) {\r\n                    _runListeners(_listeners, STR_OFFLINE_SENT, _asyncNotifications, function (listener) {\r\n                        listener[STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */](batch);\r\n                    });\r\n                }\r\n            };\r\n            _self[STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */] = function (cnt, reason) {\r\n                if (cnt > 0) {\r\n                    var rn_1 = reason || 0; // default is unknown\r\n                    _runListeners(_listeners, STR_OFFLINE_DROP, _asyncNotifications, function (listener) {\r\n                        listener[STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */](cnt, rn_1);\r\n                    });\r\n                }\r\n            };\r\n            _self[_DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {\r\n                var _finishUnload = function () {\r\n                    unloadHandler && unloadHandler.rm();\r\n                    unloadHandler = null;\r\n                    _listeners = [];\r\n                    // Clear any async listener\r\n                    _asyncNotifications.h && _asyncNotifications.h[_DYN_CANCEL /* @min:%2ecancel */]();\r\n                    _asyncNotifications.h = null;\r\n                    _asyncNotifications.cb = [];\r\n                };\r\n                var waiting;\r\n                _runListeners(_listeners, \"unload\", null, function (listener) {\r\n                    var asyncUnload = listener[_DYN_UNLOAD /* @min:%2eunload */](isAsync);\r\n                    if (asyncUnload) {\r\n                        if (!waiting) {\r\n                            waiting = [];\r\n                        }\r\n                        waiting[_DYN_PUSH /* @min:%2epush */](asyncUnload);\r\n                    }\r\n                });\r\n                if (waiting) {\r\n                    return createPromise(function (resolve) {\r\n                        return doAwaitResponse(createAllPromise(waiting), function () {\r\n                            _finishUnload();\r\n                            resolve();\r\n                        });\r\n                    });\r\n                }\r\n                else {\r\n                    _finishUnload();\r\n                }\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Adds a notification listener.\r\n     * @param listener - The notification listener to be added.\r\n     */\r\n    NotificationManager.prototype.addNotificationListener = function (listener) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Removes all instances of the listener.\r\n     * @param listener - AWTNotificationListener to remove.\r\n     */\r\n    NotificationManager.prototype.removeNotificationListener = function (listener) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Notification for events sent.\r\n     * @param events - The array of events that have been sent.\r\n     */\r\n    NotificationManager.prototype.eventsSent = function (events) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Notification for events being discarded.\r\n     * @param events - The array of events that have been discarded by the SDK.\r\n     * @param reason - The reason for which the SDK discarded the events. The EventsDiscardedReason\r\n     * constant should be used to check the different values.\r\n     */\r\n    NotificationManager.prototype.eventsDiscarded = function (events, reason) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] A function called when the events have been requested to be sent to the sever.\r\n     * @param sendReason - The reason why the event batch is being sent.\r\n     * @param isAsync - A flag which identifies whether the requests are being sent in an async or sync manner.\r\n     */\r\n    NotificationManager.prototype.eventsSendRequest = function (sendReason, isAsync) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] This event is sent if you have enabled perf events, they are primarily used to track internal performance testing and debugging\r\n     * the event can be displayed via the debug plugin extension.\r\n     * @param perfEvent\r\n     */\r\n    NotificationManager.prototype.perfEvent = function (perfEvent) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Unload and remove any state that this INotificationManager may be holding, this is generally called when the\r\n     * owning SDK is being unloaded.\r\n     * @param isAsync - Can the unload be performed asynchronously (default)\r\n     * @return If the unload occurs synchronously then nothing should be returned, if happening asynchronously then\r\n     * the function should return an [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * / Promise to allow any listeners to wait for the operation to complete.\r\n     */\r\n    NotificationManager.prototype.unload = function (isAsync) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] A function called when the offline events have been stored to the persistent storage\r\n     * @param events - events that are stored in the persistent storage\r\n     */\r\n    NotificationManager.prototype.offlineEventsStored = function (events) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] A function called when the offline events have been sent from the persistent storage\r\n     * @param batch - payload data that is sent from the persistent storage\r\n     */\r\n    NotificationManager.prototype.offlineBatchSent = function (batch) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] A function called when the offline events have been dropped from the persistent storage\r\n     * @param cnt - count of batches dropped\r\n     * @param reason - the reason why the batches is dropped\r\n     * @since v3.1.1\r\n     */\r\n    NotificationManager.prototype.offlineBatchDrop = function (cnt, reason) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return NotificationManager;\r\n}());\r\nexport { NotificationManager };\r\n//# sourceMappingURL=NotificationManager.js.map"],"mappings":";;;;;AAEA,OAAAA,YAAA;AACA,SAAAC,gBAAA,EAAAC,aAAA,EAAAC,eAAA;AACA,SAAAC,UAAA,EAAAC,UAAA,EAAAC,SAAA,EAAAC,IAAA,EAAAC,eAAA;AACA,SAAAC,mBAAA;AACA,SAAAC,0BAAA,EAAAC,WAAA,EAAAC,SAAA,EAAAC,aAAA,EAAAC,iBAAA,EAAAC,WAAA,EAAAC,SAAA,EAAAC,0BAAA,EAAAC,WAAA,EAAAC,WAAA,EAAAC,UAAA;AACA,SAAAC,oBAAA,EAAAC,uBAAA,EAAAC,eAAA,EAAAC,gBAAA,EAAAC,gBAAA,EAAAC,iBAAA,EAAAC,cAAA;AACA,IAAAC,aAAA;EACAC,eAAA;AACA;AACA,SAAAC,uBAAAC,kBAAA;EACAA,kBAAA,CAAAC,CAAA;EACA,IAAAC,SAAA,GAAAF,kBAAA,CAAAG,EAAA;EACAH,kBAAA,CAAAG,EAAA;EACA9B,UAAA,CAAA6B,SAAA,YAAAC,EAAA;IACA;IACA3B,IAAA,CAAA2B,EAAA,CAAAC,EAAA,GAAAD,EAAA,CAAAE,GAAA;EACA;AACA;AACA;AACA;AACA,SAAAC,cAAAC,SAAA,EAAAC,IAAA,EAAAR,kBAAA,EAAAS,QAAA;EACApC,UAAA,CAAAkC,SAAA,YAAAG,QAAA;IACA,IAAAA,QAAA,IAAAA,QAAA,CAAAF,IAAA;MACA,IAAAR,kBAAA;QACA;QACAA,kBAAA,CAAAG,EAAA,CAAAlB,SAAA;UACAmB,EAAA,EAAAK,QAAA;UACAJ,GAAA,EAAAK;QACA;QACAV,kBAAA,CAAAC,CAAA,GAAAD,kBAAA,CAAAC,CAAA,IAAAxB,eAAA,CAAAsB,sBAAA,KAAAC,kBAAA;MACA,OACA;QACA;QACAxB,IAAA,CAAAiC,QAAA,GAAAC,QAAA;MACA;IACA;EACA;AACA;AACA;AACA;AACA;AACA,IAAAC,mBAAA;EACA,SAAAA,oBAAAC,MAAA;IACA,KAAAL,SAAA;IACA,IAAAT,eAAA;IACA,IAAAe,aAAA;IACA,IAAAC,UAAA;IACA,IAAAC,mBAAA;MACAd,CAAA;MACAE,EAAA;IACA;IACA,IAAAa,UAAA,GAAAtC,mBAAA,CAAAkC,MAAA,EAAAf,aAAA;IACAgB,aAAA,GAAAG,UAAA,CAAA3B,UAAA,gCAAA4B,OAAA;MACAnB,eAAA,KAAAmB,OAAA,CAAAC,GAAA,CAAApB,eAAA;IACA;IACA7B,YAAA,CAAA0C,mBAAA,kBAAAQ,KAAA;MACA5C,SAAA,CAAA4C,KAAA;QACAC,CAAA,WAAAA,CAAA;UAAA,OAAAN,UAAA;QAAA;MACA;MACAK,KAAA,CAAAxC,0BAAA,oDAAA+B,QAAA;QACAI,UAAA,CAAA7B,SAAA,qBAAAyB,QAAA;MACA;MACA;AACA;AACA;AACA;MACAS,KAAA,CAAAjC,0BAAA,uDAAAwB,QAAA;QACA,IAAAW,KAAA,GAAA/C,UAAA,CAAAwC,UAAA,EAAAJ,QAAA;QACA,OAAAW,KAAA;UACAP,UAAA,CAAA3B,WAAA,uBAAAkC,KAAA;UACAA,KAAA,GAAA/C,UAAA,CAAAwC,UAAA,EAAAJ,QAAA;QACA;MACA;MACA;AACA;AACA;AACA;MACAS,KAAA,CAAA3B,eAAA,uCAAA8B,MAAA;QACAhB,aAAA,CAAAQ,UAAA,EAAAtB,eAAA,EAAAuB,mBAAA,YAAAL,QAAA;UACAA,QAAA,CAAAlB,eAAA,2BAAA8B,MAAA;QACA;MACA;MACA;AACA;AACA;AACA;AACA;AACA;MACAH,KAAA,CAAA7B,oBAAA,4CAAAgC,MAAA,EAAAC,MAAA;QACAjB,aAAA,CAAAQ,UAAA,EAAAxB,oBAAA,EAAAyB,mBAAA,YAAAL,QAAA;UACAA,QAAA,CAAApB,oBAAA,gCAAAgC,MAAA,EAAAC,MAAA;QACA;MACA;MACA;AACA;AACA;AACA;AACA;MACAJ,KAAA,CAAA5B,uBAAA,8CAAAiC,UAAA,EAAAC,OAAA;QACAnB,aAAA,CAAAQ,UAAA,EAAAvB,uBAAA,EAAAkC,OAAA,GAAAV,mBAAA,mBAAAL,QAAA;UACAA,QAAA,CAAAnB,uBAAA,kCAAAiC,UAAA,EAAAC,OAAA;QACA;MACA;MACAN,KAAA,CAAAvB,cAAA,sCAAA8B,SAAA;QACA,IAAAA,SAAA;UACA;UACA,IAAA5B,eAAA,KAAA4B,SAAA,CAAA3C,iBAAA;YACAuB,aAAA,CAAAQ,UAAA,EAAAlB,cAAA,kBAAAc,QAAA;cACA,IAAAgB,SAAA,CAAA5C,aAAA;gBACAL,eAAA;kBAAA,OAAAiC,QAAA,CAAAd,cAAA,0BAAA8B,SAAA;gBAAA;cACA,OACA;gBACAhB,QAAA,CAAAd,cAAA,0BAAA8B,SAAA;cACA;YACA;UACA;QACA;MACA;MACAP,KAAA,CAAAxB,iBAAA,gDAAA2B,MAAA;QACA,IAAAA,MAAA,IAAAA,MAAA,CAAAtC,WAAA;UACAsB,aAAA,CAAAQ,UAAA,EAAAnB,iBAAA,EAAAoB,mBAAA,YAAAL,QAAA;YACAA,QAAA,CAAAf,iBAAA,oCAAA2B,MAAA;UACA;QACA;MACA;MACAH,KAAA,CAAAzB,gBAAA,6CAAAiC,KAAA;QACA,IAAAA,KAAA,IAAAA,KAAA,CAAA9C,SAAA;UACAyB,aAAA,CAAAQ,UAAA,EAAApB,gBAAA,EAAAqB,mBAAA,YAAAL,QAAA;YACAA,QAAA,CAAAhB,gBAAA,iCAAAiC,KAAA;UACA;QACA;MACA;MACAR,KAAA,CAAA1B,gBAAA,6CAAAmC,GAAA,EAAAL,MAAA;QACA,IAAAK,GAAA;UACA,IAAAC,IAAA,GAAAN,MAAA;UACAjB,aAAA,CAAAQ,UAAA,EAAArB,gBAAA,EAAAsB,mBAAA,YAAAL,QAAA;YACAA,QAAA,CAAAjB,gBAAA,iCAAAmC,GAAA,EAAAC,IAAA;UACA;QACA;MACA;MACAV,KAAA,CAAA/B,WAAA,mCAAAqC,OAAA;QACA,IAAAK,aAAA,YAAAA,CAAA;UACAjB,aAAA,IAAAA,aAAA,CAAAkB,EAAA;UACAlB,aAAA;UACAC,UAAA;UACA;UACAC,mBAAA,CAAAd,CAAA,IAAAc,mBAAA,CAAAd,CAAA,CAAArB,WAAA;UACAmC,mBAAA,CAAAd,CAAA;UACAc,mBAAA,CAAAZ,EAAA;QACA;QACA,IAAA6B,OAAA;QACA1B,aAAA,CAAAQ,UAAA,4BAAAJ,QAAA;UACA,IAAAuB,WAAA,GAAAvB,QAAA,CAAAtB,WAAA,uBAAAqC,OAAA;UACA,IAAAQ,WAAA;YACA,KAAAD,OAAA;cACAA,OAAA;YACA;YACAA,OAAA,CAAA/C,SAAA,qBAAAgD,WAAA;UACA;QACA;QACA,IAAAD,OAAA;UACA,OAAA7D,aAAA,WAAA+D,OAAA;YACA,OAAA9D,eAAA,CAAAF,gBAAA,CAAA8D,OAAA;cACAF,aAAA;cACAI,OAAA;YACA;UACA;QACA,OACA;UACAJ,aAAA;QACA;MACA;IACA;EACA;EACA;;;;;;;;;;;;;;AAiFA;AACA,SAAAnB,mBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}