{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport { dumpObj, isUndefined, objDefine, objForEachKey } from \"@nevware21/ts-utils\";\nimport { createUniqueNamespace } from \"../JavaScriptSDK/DataCacheHelper\";\nimport { STR_NOT_DYNAMIC_ERROR } from \"../JavaScriptSDK/InternalConstants\";\nimport { _DYN_BLK_VAL, _DYN_LOGGER, _DYN_NOTIFY, _DYN_RD_ONLY, _DYN_SET_DF, _DYN_THROW_INTERNAL, _DYN_WARN_TO_CONSOLE, _DYN_WATCH } from \"../__DynamicConstants\";\nimport { _applyDefaultValue } from \"./ConfigDefaults\";\nimport { _makeDynamicObject, _setDynamicProperty, _setDynamicPropertyState, _throwDynamicError } from \"./DynamicProperty\";\nimport { _createState } from \"./DynamicState\";\nimport { CFG_HANDLER_LINK, _cfgDeepCopy, getDynamicConfigHandler, throwInvalidAccess } from \"./DynamicSupport\";\n/**\r\n * Identifies a function which will be re-called whenever any of it's accessed configuration values\r\n * change.\r\n * @param configHandler - The callback that will be called for the initial request and then whenever any\r\n * accessed configuration changes are identified.\r\n */\nfunction _createAndUseHandler(state, configHandler) {\n  var handler = {\n    fn: configHandler,\n    rm: function () {\n      // Clear all references to the handler so it can be garbage collected\n      // This will also cause this handler to never get called and eventually removed\n      handler.fn = null;\n      state = null;\n      configHandler = null;\n    }\n  };\n  objDefine(handler, \"toJSON\", {\n    v: function () {\n      return \"WatcherHandler\" + (handler.fn ? \"\" : \"[X]\");\n    }\n  });\n  state.use(handler, configHandler);\n  return handler;\n}\n/**\r\n * Creates the dynamic config handler and associates with the target config as the root object\r\n * @param target - The config that you want to be root of the dynamic config\r\n * @param inPlace - Should the passed config be converted in-place or a new proxy returned\r\n * @returns The existing dynamic handler or a new instance with the provided config values\r\n */\nfunction _createDynamicHandler(logger, target, inPlace) {\n  var _a;\n  var dynamicHandler = getDynamicConfigHandler(target);\n  if (dynamicHandler) {\n    // The passed config is already dynamic so return it's tracker\n    return dynamicHandler;\n  }\n  var uid = createUniqueNamespace(\"dyncfg\", true);\n  var newTarget = target && inPlace !== false ? target : _cfgDeepCopy(target);\n  var theState;\n  function _notifyWatchers() {\n    theState[_DYN_NOTIFY /* @min:%2enotify */]();\n  }\n  function _setValue(target, name, value) {\n    try {\n      target = _setDynamicProperty(theState, target, name, value);\n    } catch (e) {\n      // Unable to convert to dynamic property so just leave as non-dynamic\n      _throwDynamicError(logger, name, \"Setting value\", e);\n    }\n    return target[name];\n  }\n  function _watch(configHandler) {\n    return _createAndUseHandler(theState, configHandler);\n  }\n  function _block(configHandler, allowUpdate) {\n    theState.use(null, function (details) {\n      var prevUpd = theState.upd;\n      try {\n        if (!isUndefined(allowUpdate)) {\n          theState.upd = allowUpdate;\n        }\n        configHandler(details);\n      } finally {\n        theState.upd = prevUpd;\n      }\n    });\n  }\n  function _ref(target, name) {\n    var _a;\n    // Make sure it's dynamic and mark as referenced with it's current value\n    return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0 /* _eSetDynamicPropertyFlags.inPlace */] = true, _a))[name];\n  }\n  function _rdOnly(target, name) {\n    var _a;\n    // Make sure it's dynamic and mark as readonly with it's current value\n    return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1 /* _eSetDynamicPropertyFlags.readOnly */] = true, _a))[name];\n  }\n  function _blkPropValue(target, name) {\n    var _a;\n    // Make sure it's dynamic and mark as readonly with it's current value\n    return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2 /* _eSetDynamicPropertyFlags.blockDynamicProperty */] = true, _a))[name];\n  }\n  function _applyDefaults(theConfig, defaultValues) {\n    if (defaultValues) {\n      // Resolve/apply the defaults\n      objForEachKey(defaultValues, function (name, value) {\n        // Sets the value and makes it dynamic (if it doesn't already exist)\n        _applyDefaultValue(cfgHandler, theConfig, name, value);\n      });\n    }\n    return theConfig;\n  }\n  var cfgHandler = (_a = {\n    uid: null,\n    cfg: newTarget\n  }, _a[_DYN_LOGGER /* @min:logger */] = logger, _a[_DYN_NOTIFY /* @min:notify */] = _notifyWatchers, _a.set = _setValue, _a[_DYN_SET_DF /* @min:setDf */] = _applyDefaults, _a[_DYN_WATCH /* @min:watch */] = _watch, _a.ref = _ref, _a[_DYN_RD_ONLY /* @min:rdOnly */] = _rdOnly, _a[_DYN_BLK_VAL /* @min:blkVal */] = _blkPropValue, _a._block = _block, _a);\n  objDefine(cfgHandler, \"uid\", {\n    c: false,\n    e: false,\n    w: false,\n    v: uid\n  });\n  theState = _createState(cfgHandler);\n  // Setup tracking for all defined default keys\n  _makeDynamicObject(theState, newTarget, \"config\", \"Creating\");\n  return cfgHandler;\n}\n/**\r\n * Log an invalid access message to the console\r\n * @param message\r\n */\nfunction _logInvalidAccess(logger, message) {\n  if (logger) {\n    logger[_DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);\n    logger[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](2 /* eLoggingSeverity.WARNING */, 108 /* _eInternalMessageId.DynamicConfigException */, message);\n  } else {\n    // We don't have a logger so just throw an exception\n    throwInvalidAccess(message);\n  }\n}\n/**\r\n * Create or return a dynamic version of the passed config, if it is not already dynamic\r\n * @param config - The config to be converted into a dynamic config\r\n * @param defaultConfig - The default values to apply on the config if the properties don't already exist\r\n * @param inPlace - Should the config be converted in-place into a dynamic config or a new instance returned, defaults to true\r\n * @returns The dynamic config handler for the config (whether new or existing)\r\n */\nexport function createDynamicConfig(config, defaultConfig, logger, inPlace) {\n  var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);\n  if (defaultConfig) {\n    dynamicHandler[_DYN_SET_DF /* @min:%2esetDf */](dynamicHandler.cfg, defaultConfig);\n  }\n  return dynamicHandler;\n}\n/**\r\n * Watch and track changes for accesses to the current config, the provided config MUST already be\r\n * a dynamic config or a child accessed via the dynamic config\r\n * @param config\r\n * @param configHandler\r\n * @param logger - The logger instance to use if there is no existing handler\r\n * @returns A watcher handler instance that can be used to remove itself when being unloaded\r\n * @throws TypeError if the provided config is not a dynamic config instance\r\n */\nexport function onConfigChange(config, configHandler, logger) {\n  var handler = config[CFG_HANDLER_LINK] || config;\n  if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {\n    return handler[_DYN_WATCH /* @min:%2ewatch */](configHandler);\n  }\n  _logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config));\n  return createDynamicConfig(config, null, logger)[_DYN_WATCH /* @min:%2ewatch */](configHandler);\n}","map":{"version":3,"names":["dumpObj","isUndefined","objDefine","objForEachKey","createUniqueNamespace","STR_NOT_DYNAMIC_ERROR","_DYN_BLK_VAL","_DYN_LOGGER","_DYN_NOTIFY","_DYN_RD_ONLY","_DYN_SET_DF","_DYN_THROW_INTERNAL","_DYN_WARN_TO_CONSOLE","_DYN_WATCH","_applyDefaultValue","_makeDynamicObject","_setDynamicProperty","_setDynamicPropertyState","_throwDynamicError","_createState","CFG_HANDLER_LINK","_cfgDeepCopy","getDynamicConfigHandler","throwInvalidAccess","_createAndUseHandler","state","configHandler","handler","fn","rm","v","use","_createDynamicHandler","logger","target","inPlace","_a","dynamicHandler","uid","newTarget","theState","_notifyWatchers","_setValue","name","value","e","_watch","_block","allowUpdate","details","prevUpd","upd","_ref","_rdOnly","_blkPropValue","_applyDefaults","theConfig","defaultValues","cfgHandler","cfg","set","ref","c","w","_logInvalidAccess","message","createDynamicConfig","config","defaultConfig","onConfigChange"],"sources":["/home/veeresh133/app/my-app/node_modules/@microsoft/applicationinsights-core-js/dist-es5/Config/DynamicConfig.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { dumpObj, isUndefined, objDefine, objForEachKey } from \"@nevware21/ts-utils\";\r\nimport { createUniqueNamespace } from \"../JavaScriptSDK/DataCacheHelper\";\r\nimport { STR_NOT_DYNAMIC_ERROR } from \"../JavaScriptSDK/InternalConstants\";\r\nimport { _DYN_BLK_VAL, _DYN_LOGGER, _DYN_NOTIFY, _DYN_RD_ONLY, _DYN_SET_DF, _DYN_THROW_INTERNAL, _DYN_WARN_TO_CONSOLE, _DYN_WATCH } from \"../__DynamicConstants\";\r\nimport { _applyDefaultValue } from \"./ConfigDefaults\";\r\nimport { _makeDynamicObject, _setDynamicProperty, _setDynamicPropertyState, _throwDynamicError } from \"./DynamicProperty\";\r\nimport { _createState } from \"./DynamicState\";\r\nimport { CFG_HANDLER_LINK, _cfgDeepCopy, getDynamicConfigHandler, throwInvalidAccess } from \"./DynamicSupport\";\r\n/**\r\n * Identifies a function which will be re-called whenever any of it's accessed configuration values\r\n * change.\r\n * @param configHandler - The callback that will be called for the initial request and then whenever any\r\n * accessed configuration changes are identified.\r\n */\r\nfunction _createAndUseHandler(state, configHandler) {\r\n    var handler = {\r\n        fn: configHandler,\r\n        rm: function () {\r\n            // Clear all references to the handler so it can be garbage collected\r\n            // This will also cause this handler to never get called and eventually removed\r\n            handler.fn = null;\r\n            state = null;\r\n            configHandler = null;\r\n        }\r\n    };\r\n    objDefine(handler, \"toJSON\", { v: function () { return \"WatcherHandler\" + (handler.fn ? \"\" : \"[X]\"); } });\r\n    state.use(handler, configHandler);\r\n    return handler;\r\n}\r\n/**\r\n * Creates the dynamic config handler and associates with the target config as the root object\r\n * @param target - The config that you want to be root of the dynamic config\r\n * @param inPlace - Should the passed config be converted in-place or a new proxy returned\r\n * @returns The existing dynamic handler or a new instance with the provided config values\r\n */\r\nfunction _createDynamicHandler(logger, target, inPlace) {\r\n    var _a;\r\n    var dynamicHandler = getDynamicConfigHandler(target);\r\n    if (dynamicHandler) {\r\n        // The passed config is already dynamic so return it's tracker\r\n        return dynamicHandler;\r\n    }\r\n    var uid = createUniqueNamespace(\"dyncfg\", true);\r\n    var newTarget = (target && inPlace !== false) ? target : _cfgDeepCopy(target);\r\n    var theState;\r\n    function _notifyWatchers() {\r\n        theState[_DYN_NOTIFY /* @min:%2enotify */]();\r\n    }\r\n    function _setValue(target, name, value) {\r\n        try {\r\n            target = _setDynamicProperty(theState, target, name, value);\r\n        }\r\n        catch (e) {\r\n            // Unable to convert to dynamic property so just leave as non-dynamic\r\n            _throwDynamicError(logger, name, \"Setting value\", e);\r\n        }\r\n        return target[name];\r\n    }\r\n    function _watch(configHandler) {\r\n        return _createAndUseHandler(theState, configHandler);\r\n    }\r\n    function _block(configHandler, allowUpdate) {\r\n        theState.use(null, function (details) {\r\n            var prevUpd = theState.upd;\r\n            try {\r\n                if (!isUndefined(allowUpdate)) {\r\n                    theState.upd = allowUpdate;\r\n                }\r\n                configHandler(details);\r\n            }\r\n            finally {\r\n                theState.upd = prevUpd;\r\n            }\r\n        });\r\n    }\r\n    function _ref(target, name) {\r\n        var _a;\r\n        // Make sure it's dynamic and mark as referenced with it's current value\r\n        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[0 /* _eSetDynamicPropertyFlags.inPlace */] = true, _a))[name];\r\n    }\r\n    function _rdOnly(target, name) {\r\n        var _a;\r\n        // Make sure it's dynamic and mark as readonly with it's current value\r\n        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[1 /* _eSetDynamicPropertyFlags.readOnly */] = true, _a))[name];\r\n    }\r\n    function _blkPropValue(target, name) {\r\n        var _a;\r\n        // Make sure it's dynamic and mark as readonly with it's current value\r\n        return _setDynamicPropertyState(theState, target, name, (_a = {}, _a[2 /* _eSetDynamicPropertyFlags.blockDynamicProperty */] = true, _a))[name];\r\n    }\r\n    function _applyDefaults(theConfig, defaultValues) {\r\n        if (defaultValues) {\r\n            // Resolve/apply the defaults\r\n            objForEachKey(defaultValues, function (name, value) {\r\n                // Sets the value and makes it dynamic (if it doesn't already exist)\r\n                _applyDefaultValue(cfgHandler, theConfig, name, value);\r\n            });\r\n        }\r\n        return theConfig;\r\n    }\r\n    var cfgHandler = (_a = {\r\n            uid: null,\r\n            cfg: newTarget\r\n        },\r\n        _a[_DYN_LOGGER /* @min:logger */] = logger,\r\n        _a[_DYN_NOTIFY /* @min:notify */] = _notifyWatchers,\r\n        _a.set = _setValue,\r\n        _a[_DYN_SET_DF /* @min:setDf */] = _applyDefaults,\r\n        _a[_DYN_WATCH /* @min:watch */] = _watch,\r\n        _a.ref = _ref,\r\n        _a[_DYN_RD_ONLY /* @min:rdOnly */] = _rdOnly,\r\n        _a[_DYN_BLK_VAL /* @min:blkVal */] = _blkPropValue,\r\n        _a._block = _block,\r\n        _a);\r\n    objDefine(cfgHandler, \"uid\", {\r\n        c: false,\r\n        e: false,\r\n        w: false,\r\n        v: uid\r\n    });\r\n    theState = _createState(cfgHandler);\r\n    // Setup tracking for all defined default keys\r\n    _makeDynamicObject(theState, newTarget, \"config\", \"Creating\");\r\n    return cfgHandler;\r\n}\r\n/**\r\n * Log an invalid access message to the console\r\n * @param message\r\n */\r\nfunction _logInvalidAccess(logger, message) {\r\n    if (logger) {\r\n        logger[_DYN_WARN_TO_CONSOLE /* @min:%2ewarnToConsole */](message);\r\n        logger[_DYN_THROW_INTERNAL /* @min:%2ethrowInternal */](2 /* eLoggingSeverity.WARNING */, 108 /* _eInternalMessageId.DynamicConfigException */, message);\r\n    }\r\n    else {\r\n        // We don't have a logger so just throw an exception\r\n        throwInvalidAccess(message);\r\n    }\r\n}\r\n/**\r\n * Create or return a dynamic version of the passed config, if it is not already dynamic\r\n * @param config - The config to be converted into a dynamic config\r\n * @param defaultConfig - The default values to apply on the config if the properties don't already exist\r\n * @param inPlace - Should the config be converted in-place into a dynamic config or a new instance returned, defaults to true\r\n * @returns The dynamic config handler for the config (whether new or existing)\r\n */\r\nexport function createDynamicConfig(config, defaultConfig, logger, inPlace) {\r\n    var dynamicHandler = _createDynamicHandler(logger, config || {}, inPlace);\r\n    if (defaultConfig) {\r\n        dynamicHandler[_DYN_SET_DF /* @min:%2esetDf */](dynamicHandler.cfg, defaultConfig);\r\n    }\r\n    return dynamicHandler;\r\n}\r\n/**\r\n * Watch and track changes for accesses to the current config, the provided config MUST already be\r\n * a dynamic config or a child accessed via the dynamic config\r\n * @param config\r\n * @param configHandler\r\n * @param logger - The logger instance to use if there is no existing handler\r\n * @returns A watcher handler instance that can be used to remove itself when being unloaded\r\n * @throws TypeError if the provided config is not a dynamic config instance\r\n */\r\nexport function onConfigChange(config, configHandler, logger) {\r\n    var handler = config[CFG_HANDLER_LINK] || config;\r\n    if (handler.cfg && (handler.cfg === config || handler.cfg[CFG_HANDLER_LINK] === handler)) {\r\n        return handler[_DYN_WATCH /* @min:%2ewatch */](configHandler);\r\n    }\r\n    _logInvalidAccess(logger, STR_NOT_DYNAMIC_ERROR + dumpObj(config));\r\n    return createDynamicConfig(config, null, logger)[_DYN_WATCH /* @min:%2ewatch */](configHandler);\r\n}\r\n//# sourceMappingURL=DynamicConfig.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}