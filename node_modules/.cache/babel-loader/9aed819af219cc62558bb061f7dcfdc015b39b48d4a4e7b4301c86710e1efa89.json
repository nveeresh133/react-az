{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport { arrForEach, arrIndexOf, getDocument, getWindow, isArray, objForEachKey, objKeys } from \"@nevware21/ts-utils\";\nimport { _DYN_HANDLER, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_REPLACE, _DYN_SPLICE, _DYN_SPLIT, _DYN_TYPE } from \"../__DynamicConstants\";\nimport { createElmNodeData, createUniqueNamespace } from \"./DataCacheHelper\";\nimport { STR_EMPTY } from \"./InternalConstants\";\n// Added to help with minfication\nvar strOnPrefix = \"on\";\nvar strAttachEvent = \"attachEvent\";\nvar strAddEventHelper = \"addEventListener\";\nvar strDetachEvent = \"detachEvent\";\nvar strRemoveEventListener = \"removeEventListener\";\nvar strEvents = \"events\";\nvar strVisibilityChangeEvt = \"visibilitychange\";\nvar strPageHide = \"pagehide\";\nvar strPageShow = \"pageshow\";\nvar strUnload = \"unload\";\nvar strBeforeUnload = \"beforeunload\";\nvar strPageHideNamespace = createUniqueNamespace(\"aiEvtPageHide\");\nvar strPageShowNamespace = createUniqueNamespace(\"aiEvtPageShow\");\nvar rRemoveEmptyNs = /\\.[\\.]+/g;\nvar rRemoveTrailingEmptyNs = /[\\.]+$/;\nvar _guid = 1;\nvar elmNodeData = createElmNodeData(\"events\");\nvar eventNamespace = /^([^.]*)(?:\\.(.+)|)/;\nfunction _normalizeNamespace(name) {\n  if (name && name[_DYN_REPLACE /* @min:%2ereplace */]) {\n    return name[_DYN_REPLACE /* @min:%2ereplace */](/^[\\s\\.]+|(?=[\\s\\.])[\\.\\s]+$/g, STR_EMPTY);\n  }\n  return name;\n}\nfunction _getEvtNamespace(eventName, evtNamespace) {\n  var _a;\n  if (evtNamespace) {\n    var theNamespace_1 = STR_EMPTY;\n    if (isArray(evtNamespace)) {\n      theNamespace_1 = STR_EMPTY;\n      arrForEach(evtNamespace, function (name) {\n        name = _normalizeNamespace(name);\n        if (name) {\n          if (name[0] !== \".\") {\n            name = \".\" + name;\n          }\n          theNamespace_1 += name;\n        }\n      });\n    } else {\n      theNamespace_1 = _normalizeNamespace(evtNamespace);\n    }\n    if (theNamespace_1) {\n      if (theNamespace_1[0] !== \".\") {\n        theNamespace_1 = \".\" + theNamespace_1;\n      }\n      // We may only have the namespace and not an eventName\n      eventName = (eventName || STR_EMPTY) + theNamespace_1;\n    }\n  }\n  var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY) || [];\n  return _a = {}, _a[_DYN_TYPE /* @min:type */] = parsedEvent[1], _a.ns = (parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, \".\").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT /* @min:%2esplit */](\".\").sort().join(\".\"), _a;\n}\n/**\r\n * Get all of the registered events on the target object, this is primarily used for testing cleanup but may also be used by\r\n * applications to remove their own events\r\n * @param target - The EventTarget that has registered events\r\n * @param eventName - [Optional] The name of the event to return the registered handlers and full name (with namespaces)\r\n * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,\r\n * if the eventName also includes a namespace the namespace(s) are merged into a single namespace\r\n */\nexport function __getRegisteredEvents(target, eventName, evtNamespace) {\n  var theEvents = [];\n  var eventCache = elmNodeData.get(target, strEvents, {}, false);\n  var evtName = _getEvtNamespace(eventName, evtNamespace);\n  objForEachKey(eventCache, function (evtType, registeredEvents) {\n    arrForEach(registeredEvents, function (value) {\n      var _a;\n      if (!evtName[_DYN_TYPE /* @min:%2etype */] || evtName[_DYN_TYPE /* @min:%2etype */] === value.evtName[_DYN_TYPE /* @min:%2etype */]) {\n        if (!evtName.ns || evtName.ns === evtName.ns) {\n          theEvents[_DYN_PUSH /* @min:%2epush */]((_a = {}, _a[_DYN_NAME /* @min:name */] = value.evtName[_DYN_TYPE /* @min:%2etype */] + (value.evtName.ns ? \".\" + value.evtName.ns : STR_EMPTY), _a.handler = value[_DYN_HANDLER /* @min:%2ehandler */], _a));\n        }\n      }\n    });\n  });\n  return theEvents;\n}\n// Exported for internal unit testing only\nfunction _getRegisteredEvents(target, evtName, addDefault) {\n  if (addDefault === void 0) {\n    addDefault = true;\n  }\n  var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);\n  var registeredEvents = aiEvts[evtName];\n  if (!registeredEvents) {\n    registeredEvents = aiEvts[evtName] = [];\n  }\n  return registeredEvents;\n}\nfunction _doDetach(obj, evtName, handlerRef, useCapture) {\n  if (obj && evtName && evtName[_DYN_TYPE /* @min:%2etype */]) {\n    if (obj[strRemoveEventListener]) {\n      obj[strRemoveEventListener](evtName[_DYN_TYPE /* @min:%2etype */], handlerRef, useCapture);\n    } else if (obj[strDetachEvent]) {\n      obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE /* @min:%2etype */], handlerRef);\n    }\n  }\n}\nfunction _doAttach(obj, evtName, handlerRef, useCapture) {\n  var result = false;\n  if (obj && evtName && evtName[_DYN_TYPE /* @min:%2etype */] && handlerRef) {\n    if (obj[strAddEventHelper]) {\n      // all browsers except IE before version 9\n      obj[strAddEventHelper](evtName[_DYN_TYPE /* @min:%2etype */], handlerRef, useCapture);\n      result = true;\n    } else if (obj[strAttachEvent]) {\n      // IE before version 9\n      obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE /* @min:%2etype */], handlerRef);\n      result = true;\n    }\n  }\n  return result;\n}\nfunction _doUnregister(target, events, evtName, unRegFn) {\n  var idx = events[_DYN_LENGTH /* @min:%2elength */];\n  while (idx--) {\n    var theEvent = events[idx];\n    if (theEvent) {\n      if (!evtName.ns || evtName.ns === theEvent.evtName.ns) {\n        if (!unRegFn || unRegFn(theEvent)) {\n          _doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER /* @min:%2ehandler */], theEvent.capture);\n          // Remove the registered event\n          events[_DYN_SPLICE /* @min:%2esplice */](idx, 1);\n        }\n      }\n    }\n  }\n}\nfunction _unregisterEvents(target, evtName, unRegFn) {\n  if (evtName[_DYN_TYPE /* @min:%2etype */]) {\n    _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE /* @min:%2etype */]), evtName, unRegFn);\n  } else {\n    var eventCache = elmNodeData.get(target, strEvents, {});\n    objForEachKey(eventCache, function (evtType, events) {\n      _doUnregister(target, events, evtName, unRegFn);\n    });\n    // Cleanup\n    if (objKeys(eventCache)[_DYN_LENGTH /* @min:%2elength */] === 0) {\n      elmNodeData.kill(target, strEvents);\n    }\n  }\n}\nexport function mergeEvtNamespace(theNamespace, namespaces) {\n  var newNamespaces;\n  if (namespaces) {\n    if (isArray(namespaces)) {\n      newNamespaces = [theNamespace].concat(namespaces);\n    } else {\n      newNamespaces = [theNamespace, namespaces];\n    }\n    // resort the namespaces so they are always in order\n    newNamespaces = _getEvtNamespace(\"xx\", newNamespaces).ns[_DYN_SPLIT /* @min:%2esplit */](\".\");\n  } else {\n    newNamespaces = theNamespace;\n  }\n  return newNamespaces;\n}\n/**\r\n * Binds the specified function to an event, so that the function gets called whenever the event fires on the object\r\n * @param obj - Object to add the event too.\r\n * @param eventName - String that specifies any of the standard DHTML Events without \"on\" prefix, if may also include an optional (dot \".\" prefixed)\r\n * namespaces \"click\" \"click.mynamespace\" in addition to specific namespaces.\r\n * @param handlerRef - Pointer that specifies the function to call when event fires\r\n * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,\r\n * if the eventName also includes a namespace the namespace(s) are merged into a single namespace\r\n * @param useCapture - [Optional] Defaults to false\r\n * @returns True if the function was bound successfully to the event, otherwise false\r\n */\nexport function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {\n  var _a;\n  if (useCapture === void 0) {\n    useCapture = false;\n  }\n  var result = false;\n  if (target) {\n    try {\n      var evtName = _getEvtNamespace(eventName, evtNamespace);\n      result = _doAttach(target, evtName, handlerRef, useCapture);\n      if (result && elmNodeData.accept(target)) {\n        var registeredEvent = (_a = {\n          guid: _guid++,\n          evtName: evtName\n        }, _a[_DYN_HANDLER /* @min:handler */] = handlerRef, _a.capture = useCapture, _a);\n        _getRegisteredEvents(target, evtName.type)[_DYN_PUSH /* @min:%2epush */](registeredEvent);\n      }\n    } catch (e) {\n      // Just Ignore any error so that we don't break any execution path\n    }\n  }\n  return result;\n}\n/**\r\n * Removes an event handler for the specified event\r\n * @param Object - to remove the event from\r\n * @param eventName - {string} - The name of the event, with optional namespaces or just the namespaces,\r\n * such as \"click\", \"click.mynamespace\" or \".mynamespace\"\r\n * @param handlerRef - {any} - The callback function that needs to be removed from the given event, when using a\r\n * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers\r\n * otherwise this will only remove events with this specific handler.\r\n * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,\r\n * if the eventName also includes a namespace the namespace(s) are merged into a single namespace\r\n * @param useCapture - [Optional] Defaults to false\r\n */\nexport function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {\n  if (useCapture === void 0) {\n    useCapture = false;\n  }\n  if (target) {\n    try {\n      var evtName_1 = _getEvtNamespace(eventName, evtNamespace);\n      var found_1 = false;\n      _unregisterEvents(target, evtName_1, function (regEvent) {\n        if (evtName_1.ns && !handlerRef || regEvent[_DYN_HANDLER /* @min:%2ehandler */] === handlerRef) {\n          found_1 = true;\n          return true;\n        }\n        return false;\n      });\n      if (!found_1) {\n        // fallback to try and remove as requested\n        _doDetach(target, evtName_1, handlerRef, useCapture);\n      }\n    } catch (e) {\n      // Just Ignore any error so that we don't break any execution path\n    }\n  }\n}\n/**\r\n * Binds the specified function to an event, so that the function gets called whenever the event fires on the object\r\n * @param obj - Object to add the event too.\r\n * @param eventNameWithoutOn - String that specifies any of the standard DHTML Events without \"on\" prefix and optional (dot \".\" prefixed) namespaces \"click\" \"click.mynamespace\".\r\n * @param handlerRef - Pointer that specifies the function to call when event fires\r\n * @param useCapture - [Optional] Defaults to false\r\n * @returns True if the function was bound successfully to the event, otherwise false\r\n */\nexport function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {\n  if (useCapture === void 0) {\n    useCapture = false;\n  }\n  return eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);\n}\n/**\r\n * Removes an event handler for the specified event\r\n * @param Object - to remove the event from\r\n * @param eventNameWithoutOn - {string} - The name of the event, with optional namespaces or just the namespaces,\r\n * such as \"click\", \"click.mynamespace\" or \".mynamespace\"\r\n * @param handlerRef - {any} - The callback function that needs to be removed from the given event, when using a\r\n * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers\r\n * otherwise this will only remove events with this specific handler.\r\n * @param useCapture - [Optional] Defaults to false\r\n */\nexport function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {\n  if (useCapture === void 0) {\n    useCapture = false;\n  }\n  eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);\n}\n/**\r\n * Trys to add an event handler for the specified event to the window, body and document\r\n * @param eventName - {string} - The name of the event\r\n * @param callback - {any} - The callback function that needs to be executed for the given event\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n * @return {boolean} - true if the handler was successfully added\r\n */\nexport function addEventHandler(eventName, callback, evtNamespace) {\n  var result = false;\n  var w = getWindow();\n  if (w) {\n    result = eventOn(w, eventName, callback, evtNamespace);\n    result = eventOn(w[\"body\"], eventName, callback, evtNamespace) || result;\n  }\n  var doc = getDocument();\n  if (doc) {\n    result = eventOn(doc, eventName, callback, evtNamespace) || result;\n  }\n  return result;\n}\n/**\r\n * Trys to remove event handler(s) for the specified event/namespace to the window, body and document\r\n * @param eventName - {string} - The name of the event, with optional namespaces or just the namespaces,\r\n * such as \"click\", \"click.mynamespace\" or \".mynamespace\"\r\n * @param callback - {any} - - The callback function that needs to be removed from the given event, when using a\r\n * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers\r\n * otherwise this will only remove events with this specific handler.\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n */\nexport function removeEventHandler(eventName, callback, evtNamespace) {\n  var w = getWindow();\n  if (w) {\n    eventOff(w, eventName, callback, evtNamespace);\n    eventOff(w[\"body\"], eventName, callback, evtNamespace);\n  }\n  var doc = getDocument();\n  if (doc) {\n    eventOff(doc, eventName, callback, evtNamespace);\n  }\n}\n/**\r\n * Bind the listener to the array of events\r\n * @param events - An string array of event names to bind the listener to\r\n * @param listener - The event callback to call when the event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\nfunction _addEventListeners(events, listener, excludeEvents, evtNamespace) {\n  var added = false;\n  if (listener && events && events[_DYN_LENGTH /* @min:%2elength */] > 0) {\n    arrForEach(events, function (name) {\n      if (name) {\n        if (!excludeEvents || arrIndexOf(excludeEvents, name) === -1) {\n          added = addEventHandler(name, listener, evtNamespace) || added;\n        }\n      }\n    });\n  }\n  return added;\n}\n/**\r\n * Bind the listener to the array of events\r\n * @param events - An string array of event names to bind the listener to\r\n * @param listener - The event callback to call when the event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\nexport function addEventListeners(events, listener, excludeEvents, evtNamespace) {\n  var added = false;\n  if (listener && events && isArray(events)) {\n    added = _addEventListeners(events, listener, excludeEvents, evtNamespace);\n    if (!added && excludeEvents && excludeEvents[_DYN_LENGTH /* @min:%2elength */] > 0) {\n      // Failed to add any listeners and we excluded some, so just attempt to add the excluded events\n      added = _addEventListeners(events, listener, null, evtNamespace);\n    }\n  }\n  return added;\n}\n/**\r\n * Remove the listener from the array of events\r\n * @param events - An string array of event names to bind the listener to\r\n * @param listener - The event callback to call when the event is triggered\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n */\nexport function removeEventListeners(events, listener, evtNamespace) {\n  if (events && isArray(events)) {\n    arrForEach(events, function (name) {\n      if (name) {\n        removeEventHandler(name, listener, evtNamespace);\n      }\n    });\n  }\n}\n/**\r\n * Listen to the 'beforeunload', 'unload' and 'pagehide' events which indicates a page unload is occurring,\r\n * this does NOT listen to the 'visibilitychange' event as while it does indicate that the page is being hidden\r\n * it does not *necessarily* mean that the page is being completely unloaded, it can mean that the user is\r\n * just navigating to a different Tab and may come back (without unloading the page). As such you may also\r\n * need to listen to the 'addPageHideEventListener' and 'addPageShowEventListener' events.\r\n * @param listener - The event callback to call when a page unload event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked, unless no other events can be.\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\nexport function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {\n  // Hook the unload event for the document, window and body to ensure that the client events are flushed to the server\n  // As just hooking the window does not always fire (on chrome) for page navigation's.\n  return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);\n}\n/**\r\n * Remove any matching 'beforeunload', 'unload' and 'pagehide' events that may have been added via addEventListener,\r\n * addEventListeners, addPageUnloadEventListener or addPageHideEventListener.\r\n * @param listener - The specific event callback to to be removed\r\n * @param evtNamespace - [Optional] Namespace(s) uniquely identified and removed based on this namespace.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\nexport function removePageUnloadEventListener(listener, evtNamespace) {\n  removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);\n}\n/**\r\n * Listen to the pagehide and visibility changing to 'hidden' events, because the 'visibilitychange' uses\r\n * an internal proxy to detect the visibility state you SHOULD use a unique namespace when if you plan to call\r\n * removePageShowEventListener as the remove ignores the listener argument for the 'visibilitychange' event.\r\n * @param listener - The event callback to call when a page hide event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.\r\n * @param evtNamespace - [Optional] A Namespace to append to the event listeners so they can be uniquely identified and removed\r\n * based on this namespace. This call also adds an additional unique \"pageshow\" namespace to the events\r\n * so that only the matching \"removePageHideEventListener\" can remove these events.\r\n * Suggestion: pass as true if you are also calling addPageUnloadEventListener as that also hooks pagehide\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\nexport function addPageHideEventListener(listener, excludeEvents, evtNamespace) {\n  function _handlePageVisibility(evt) {\n    var doc = getDocument();\n    if (listener && doc && doc.visibilityState === \"hidden\") {\n      listener(evt);\n    }\n  }\n  // add the unique page show namespace to any provided namespace so we can only remove the ones added by \"pagehide\"\n  var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);\n  var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);\n  if (!excludeEvents || arrIndexOf(excludeEvents, strVisibilityChangeEvt) === -1) {\n    pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;\n  }\n  if (!pageUnloadAdded && excludeEvents) {\n    // Failed to add any listeners and we where requested to exclude some, so just call again without excluding anything\n    pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);\n  }\n  return pageUnloadAdded;\n}\n/**\r\n * Removes the pageHide event listeners added by addPageHideEventListener, because the 'visibilitychange' uses\r\n * an internal proxy to detect the visibility state you SHOULD use a unique namespace when calling addPageHideEventListener\r\n * as the remove ignores the listener argument for the 'visibilitychange' event.\r\n * @param listener - The specific listener to remove for the 'pageshow' event only (ignored for 'visibilitychange')\r\n * @param evtNamespace - The unique namespace used when calling addPageShowEventListener\r\n */\nexport function removePageHideEventListener(listener, evtNamespace) {\n  // add the unique page show namespace to any provided namespace so we only remove the ones added by \"pagehide\"\n  var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);\n  removeEventListeners([strPageHide], listener, newNamespaces);\n  removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);\n}\n/**\r\n * Listen to the pageshow and visibility changing to 'visible' events, because the 'visibilitychange' uses\r\n * an internal proxy to detect the visibility state you SHOULD use a unique namespace when if you plan to call\r\n * removePageShowEventListener as the remove ignores the listener argument for the 'visibilitychange' event.\r\n * @param listener - The event callback to call when a page is show event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.\r\n * @param evtNamespace - [Optional/Recommended] A Namespace to append to the event listeners so they can be uniquely\r\n * identified and removed based on this namespace. This call also adds an additional unique \"pageshow\" namespace to the events\r\n * so that only the matching \"removePageShowEventListener\" can remove these events.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\nexport function addPageShowEventListener(listener, excludeEvents, evtNamespace) {\n  function _handlePageVisibility(evt) {\n    var doc = getDocument();\n    if (listener && doc && doc.visibilityState === \"visible\") {\n      listener(evt);\n    }\n  }\n  // add the unique page show namespace to any provided namespace so we can only remove the ones added by \"pageshow\"\n  var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);\n  var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);\n  pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;\n  if (!pageShowAdded && excludeEvents) {\n    // Failed to add any listeners and we where requested to exclude some, so just call again without excluding anything\n    pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);\n  }\n  return pageShowAdded;\n}\n/**\r\n * Removes the pageShow event listeners added by addPageShowEventListener, because the 'visibilitychange' uses\r\n * an internal proxy to detect the visibility state you SHOULD use a unique namespace when calling addPageShowEventListener\r\n * as the remove ignores the listener argument for the 'visibilitychange' event.\r\n * @param listener - The specific listener to remove for the 'pageshow' event only (ignored for 'visibilitychange')\r\n * @param evtNamespace - The unique namespace used when calling addPageShowEventListener\r\n */\nexport function removePageShowEventListener(listener, evtNamespace) {\n  // add the unique page show namespace to any provided namespace so we only remove the ones added by \"pageshow\"\n  var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);\n  removeEventListeners([strPageShow], listener, newNamespaces);\n  removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);\n}","map":{"version":3,"names":["arrForEach","arrIndexOf","getDocument","getWindow","isArray","objForEachKey","objKeys","_DYN_HANDLER","_DYN_LENGTH","_DYN_NAME","_DYN_PUSH","_DYN_REPLACE","_DYN_SPLICE","_DYN_SPLIT","_DYN_TYPE","createElmNodeData","createUniqueNamespace","STR_EMPTY","strOnPrefix","strAttachEvent","strAddEventHelper","strDetachEvent","strRemoveEventListener","strEvents","strVisibilityChangeEvt","strPageHide","strPageShow","strUnload","strBeforeUnload","strPageHideNamespace","strPageShowNamespace","rRemoveEmptyNs","rRemoveTrailingEmptyNs","_guid","elmNodeData","eventNamespace","_normalizeNamespace","name","_getEvtNamespace","eventName","evtNamespace","_a","theNamespace_1","parsedEvent","exec","ns","replace","sort","join","__getRegisteredEvents","target","theEvents","eventCache","get","evtName","evtType","registeredEvents","value","handler","_getRegisteredEvents","addDefault","aiEvts","_doDetach","obj","handlerRef","useCapture","_doAttach","result","_doUnregister","events","unRegFn","idx","theEvent","capture","_unregisterEvents","kill","mergeEvtNamespace","theNamespace","namespaces","newNamespaces","concat","eventOn","accept","registeredEvent","guid","type","e","eventOff","evtName_1","found_1","regEvent","attachEvent","eventNameWithoutOn","detachEvent","addEventHandler","callback","w","doc","removeEventHandler","_addEventListeners","listener","excludeEvents","added","addEventListeners","removeEventListeners","addPageUnloadEventListener","removePageUnloadEventListener","addPageHideEventListener","_handlePageVisibility","evt","visibilityState","pageUnloadAdded","removePageHideEventListener","addPageShowEventListener","pageShowAdded","removePageShowEventListener"],"sources":["/home/veeresh133/app/my-app/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/EventHelpers.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { arrForEach, arrIndexOf, getDocument, getWindow, isArray, objForEachKey, objKeys } from \"@nevware21/ts-utils\";\r\nimport { _DYN_HANDLER, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_REPLACE, _DYN_SPLICE, _DYN_SPLIT, _DYN_TYPE } from \"../__DynamicConstants\";\r\nimport { createElmNodeData, createUniqueNamespace } from \"./DataCacheHelper\";\r\nimport { STR_EMPTY } from \"./InternalConstants\";\r\n// Added to help with minfication\r\nvar strOnPrefix = \"on\";\r\nvar strAttachEvent = \"attachEvent\";\r\nvar strAddEventHelper = \"addEventListener\";\r\nvar strDetachEvent = \"detachEvent\";\r\nvar strRemoveEventListener = \"removeEventListener\";\r\nvar strEvents = \"events\";\r\nvar strVisibilityChangeEvt = \"visibilitychange\";\r\nvar strPageHide = \"pagehide\";\r\nvar strPageShow = \"pageshow\";\r\nvar strUnload = \"unload\";\r\nvar strBeforeUnload = \"beforeunload\";\r\nvar strPageHideNamespace = createUniqueNamespace(\"aiEvtPageHide\");\r\nvar strPageShowNamespace = createUniqueNamespace(\"aiEvtPageShow\");\r\nvar rRemoveEmptyNs = /\\.[\\.]+/g;\r\nvar rRemoveTrailingEmptyNs = /[\\.]+$/;\r\nvar _guid = 1;\r\nvar elmNodeData = createElmNodeData(\"events\");\r\nvar eventNamespace = /^([^.]*)(?:\\.(.+)|)/;\r\nfunction _normalizeNamespace(name) {\r\n    if (name && name[_DYN_REPLACE /* @min:%2ereplace */]) {\r\n        return name[_DYN_REPLACE /* @min:%2ereplace */](/^[\\s\\.]+|(?=[\\s\\.])[\\.\\s]+$/g, STR_EMPTY);\r\n    }\r\n    return name;\r\n}\r\nfunction _getEvtNamespace(eventName, evtNamespace) {\r\n    var _a;\r\n    if (evtNamespace) {\r\n        var theNamespace_1 = STR_EMPTY;\r\n        if (isArray(evtNamespace)) {\r\n            theNamespace_1 = STR_EMPTY;\r\n            arrForEach(evtNamespace, function (name) {\r\n                name = _normalizeNamespace(name);\r\n                if (name) {\r\n                    if (name[0] !== \".\") {\r\n                        name = \".\" + name;\r\n                    }\r\n                    theNamespace_1 += name;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            theNamespace_1 = _normalizeNamespace(evtNamespace);\r\n        }\r\n        if (theNamespace_1) {\r\n            if (theNamespace_1[0] !== \".\") {\r\n                theNamespace_1 = \".\" + theNamespace_1;\r\n            }\r\n            // We may only have the namespace and not an eventName\r\n            eventName = (eventName || STR_EMPTY) + theNamespace_1;\r\n        }\r\n    }\r\n    var parsedEvent = (eventNamespace.exec(eventName || STR_EMPTY) || []);\r\n    return _a = {},\r\n        _a[_DYN_TYPE /* @min:type */] = parsedEvent[1],\r\n        _a.ns = ((parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, \".\").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT /* @min:%2esplit */](\".\").sort()).join(\".\"),\r\n        _a;\r\n}\r\n/**\r\n * Get all of the registered events on the target object, this is primarily used for testing cleanup but may also be used by\r\n * applications to remove their own events\r\n * @param target - The EventTarget that has registered events\r\n * @param eventName - [Optional] The name of the event to return the registered handlers and full name (with namespaces)\r\n * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,\r\n * if the eventName also includes a namespace the namespace(s) are merged into a single namespace\r\n */\r\nexport function __getRegisteredEvents(target, eventName, evtNamespace) {\r\n    var theEvents = [];\r\n    var eventCache = elmNodeData.get(target, strEvents, {}, false);\r\n    var evtName = _getEvtNamespace(eventName, evtNamespace);\r\n    objForEachKey(eventCache, function (evtType, registeredEvents) {\r\n        arrForEach(registeredEvents, function (value) {\r\n            var _a;\r\n            if (!evtName[_DYN_TYPE /* @min:%2etype */] || evtName[_DYN_TYPE /* @min:%2etype */] === value.evtName[_DYN_TYPE /* @min:%2etype */]) {\r\n                if (!evtName.ns || evtName.ns === evtName.ns) {\r\n                    theEvents[_DYN_PUSH /* @min:%2epush */]((_a = {},\r\n                        _a[_DYN_NAME /* @min:name */] = value.evtName[_DYN_TYPE /* @min:%2etype */] + (value.evtName.ns ? \".\" + value.evtName.ns : STR_EMPTY),\r\n                        _a.handler = value[_DYN_HANDLER /* @min:%2ehandler */],\r\n                        _a));\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return theEvents;\r\n}\r\n// Exported for internal unit testing only\r\nfunction _getRegisteredEvents(target, evtName, addDefault) {\r\n    if (addDefault === void 0) { addDefault = true; }\r\n    var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);\r\n    var registeredEvents = aiEvts[evtName];\r\n    if (!registeredEvents) {\r\n        registeredEvents = aiEvts[evtName] = [];\r\n    }\r\n    return registeredEvents;\r\n}\r\nfunction _doDetach(obj, evtName, handlerRef, useCapture) {\r\n    if (obj && evtName && evtName[_DYN_TYPE /* @min:%2etype */]) {\r\n        if (obj[strRemoveEventListener]) {\r\n            obj[strRemoveEventListener](evtName[_DYN_TYPE /* @min:%2etype */], handlerRef, useCapture);\r\n        }\r\n        else if (obj[strDetachEvent]) {\r\n            obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE /* @min:%2etype */], handlerRef);\r\n        }\r\n    }\r\n}\r\nfunction _doAttach(obj, evtName, handlerRef, useCapture) {\r\n    var result = false;\r\n    if (obj && evtName && evtName[_DYN_TYPE /* @min:%2etype */] && handlerRef) {\r\n        if (obj[strAddEventHelper]) {\r\n            // all browsers except IE before version 9\r\n            obj[strAddEventHelper](evtName[_DYN_TYPE /* @min:%2etype */], handlerRef, useCapture);\r\n            result = true;\r\n        }\r\n        else if (obj[strAttachEvent]) {\r\n            // IE before version 9\r\n            obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE /* @min:%2etype */], handlerRef);\r\n            result = true;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction _doUnregister(target, events, evtName, unRegFn) {\r\n    var idx = events[_DYN_LENGTH /* @min:%2elength */];\r\n    while (idx--) {\r\n        var theEvent = events[idx];\r\n        if (theEvent) {\r\n            if (!evtName.ns || evtName.ns === theEvent.evtName.ns) {\r\n                if (!unRegFn || unRegFn(theEvent)) {\r\n                    _doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER /* @min:%2ehandler */], theEvent.capture);\r\n                    // Remove the registered event\r\n                    events[_DYN_SPLICE /* @min:%2esplice */](idx, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction _unregisterEvents(target, evtName, unRegFn) {\r\n    if (evtName[_DYN_TYPE /* @min:%2etype */]) {\r\n        _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE /* @min:%2etype */]), evtName, unRegFn);\r\n    }\r\n    else {\r\n        var eventCache = elmNodeData.get(target, strEvents, {});\r\n        objForEachKey(eventCache, function (evtType, events) {\r\n            _doUnregister(target, events, evtName, unRegFn);\r\n        });\r\n        // Cleanup\r\n        if (objKeys(eventCache)[_DYN_LENGTH /* @min:%2elength */] === 0) {\r\n            elmNodeData.kill(target, strEvents);\r\n        }\r\n    }\r\n}\r\nexport function mergeEvtNamespace(theNamespace, namespaces) {\r\n    var newNamespaces;\r\n    if (namespaces) {\r\n        if (isArray(namespaces)) {\r\n            newNamespaces = [theNamespace].concat(namespaces);\r\n        }\r\n        else {\r\n            newNamespaces = [theNamespace, namespaces];\r\n        }\r\n        // resort the namespaces so they are always in order\r\n        newNamespaces = (_getEvtNamespace(\"xx\", newNamespaces).ns)[_DYN_SPLIT /* @min:%2esplit */](\".\");\r\n    }\r\n    else {\r\n        newNamespaces = theNamespace;\r\n    }\r\n    return newNamespaces;\r\n}\r\n/**\r\n * Binds the specified function to an event, so that the function gets called whenever the event fires on the object\r\n * @param obj - Object to add the event too.\r\n * @param eventName - String that specifies any of the standard DHTML Events without \"on\" prefix, if may also include an optional (dot \".\" prefixed)\r\n * namespaces \"click\" \"click.mynamespace\" in addition to specific namespaces.\r\n * @param handlerRef - Pointer that specifies the function to call when event fires\r\n * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,\r\n * if the eventName also includes a namespace the namespace(s) are merged into a single namespace\r\n * @param useCapture - [Optional] Defaults to false\r\n * @returns True if the function was bound successfully to the event, otherwise false\r\n */\r\nexport function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {\r\n    var _a;\r\n    if (useCapture === void 0) { useCapture = false; }\r\n    var result = false;\r\n    if (target) {\r\n        try {\r\n            var evtName = _getEvtNamespace(eventName, evtNamespace);\r\n            result = _doAttach(target, evtName, handlerRef, useCapture);\r\n            if (result && elmNodeData.accept(target)) {\r\n                var registeredEvent = (_a = {\r\n                        guid: _guid++,\r\n                        evtName: evtName\r\n                    },\r\n                    _a[_DYN_HANDLER /* @min:handler */] = handlerRef,\r\n                    _a.capture = useCapture,\r\n                    _a);\r\n                _getRegisteredEvents(target, evtName.type)[_DYN_PUSH /* @min:%2epush */](registeredEvent);\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Just Ignore any error so that we don't break any execution path\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Removes an event handler for the specified event\r\n * @param Object - to remove the event from\r\n * @param eventName - {string} - The name of the event, with optional namespaces or just the namespaces,\r\n * such as \"click\", \"click.mynamespace\" or \".mynamespace\"\r\n * @param handlerRef - {any} - The callback function that needs to be removed from the given event, when using a\r\n * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers\r\n * otherwise this will only remove events with this specific handler.\r\n * @param evtNamespace - [Optional] Additional namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace,\r\n * if the eventName also includes a namespace the namespace(s) are merged into a single namespace\r\n * @param useCapture - [Optional] Defaults to false\r\n */\r\nexport function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {\r\n    if (useCapture === void 0) { useCapture = false; }\r\n    if (target) {\r\n        try {\r\n            var evtName_1 = _getEvtNamespace(eventName, evtNamespace);\r\n            var found_1 = false;\r\n            _unregisterEvents(target, evtName_1, function (regEvent) {\r\n                if ((evtName_1.ns && !handlerRef) || regEvent[_DYN_HANDLER /* @min:%2ehandler */] === handlerRef) {\r\n                    found_1 = true;\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            if (!found_1) {\r\n                // fallback to try and remove as requested\r\n                _doDetach(target, evtName_1, handlerRef, useCapture);\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Just Ignore any error so that we don't break any execution path\r\n        }\r\n    }\r\n}\r\n/**\r\n * Binds the specified function to an event, so that the function gets called whenever the event fires on the object\r\n * @param obj - Object to add the event too.\r\n * @param eventNameWithoutOn - String that specifies any of the standard DHTML Events without \"on\" prefix and optional (dot \".\" prefixed) namespaces \"click\" \"click.mynamespace\".\r\n * @param handlerRef - Pointer that specifies the function to call when event fires\r\n * @param useCapture - [Optional] Defaults to false\r\n * @returns True if the function was bound successfully to the event, otherwise false\r\n */\r\nexport function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {\r\n    if (useCapture === void 0) { useCapture = false; }\r\n    return eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);\r\n}\r\n/**\r\n * Removes an event handler for the specified event\r\n * @param Object - to remove the event from\r\n * @param eventNameWithoutOn - {string} - The name of the event, with optional namespaces or just the namespaces,\r\n * such as \"click\", \"click.mynamespace\" or \".mynamespace\"\r\n * @param handlerRef - {any} - The callback function that needs to be removed from the given event, when using a\r\n * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers\r\n * otherwise this will only remove events with this specific handler.\r\n * @param useCapture - [Optional] Defaults to false\r\n */\r\nexport function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {\r\n    if (useCapture === void 0) { useCapture = false; }\r\n    eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);\r\n}\r\n/**\r\n * Trys to add an event handler for the specified event to the window, body and document\r\n * @param eventName - {string} - The name of the event\r\n * @param callback - {any} - The callback function that needs to be executed for the given event\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n * @return {boolean} - true if the handler was successfully added\r\n */\r\nexport function addEventHandler(eventName, callback, evtNamespace) {\r\n    var result = false;\r\n    var w = getWindow();\r\n    if (w) {\r\n        result = eventOn(w, eventName, callback, evtNamespace);\r\n        result = eventOn(w[\"body\"], eventName, callback, evtNamespace) || result;\r\n    }\r\n    var doc = getDocument();\r\n    if (doc) {\r\n        result = eventOn(doc, eventName, callback, evtNamespace) || result;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Trys to remove event handler(s) for the specified event/namespace to the window, body and document\r\n * @param eventName - {string} - The name of the event, with optional namespaces or just the namespaces,\r\n * such as \"click\", \"click.mynamespace\" or \".mynamespace\"\r\n * @param callback - {any} - - The callback function that needs to be removed from the given event, when using a\r\n * namespace (with or without a qualifying event) this may be null to remove all previously attached event handlers\r\n * otherwise this will only remove events with this specific handler.\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n */\r\nexport function removeEventHandler(eventName, callback, evtNamespace) {\r\n    var w = getWindow();\r\n    if (w) {\r\n        eventOff(w, eventName, callback, evtNamespace);\r\n        eventOff(w[\"body\"], eventName, callback, evtNamespace);\r\n    }\r\n    var doc = getDocument();\r\n    if (doc) {\r\n        eventOff(doc, eventName, callback, evtNamespace);\r\n    }\r\n}\r\n/**\r\n * Bind the listener to the array of events\r\n * @param events - An string array of event names to bind the listener to\r\n * @param listener - The event callback to call when the event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\r\nfunction _addEventListeners(events, listener, excludeEvents, evtNamespace) {\r\n    var added = false;\r\n    if (listener && events && events[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n        arrForEach(events, function (name) {\r\n            if (name) {\r\n                if (!excludeEvents || arrIndexOf(excludeEvents, name) === -1) {\r\n                    added = addEventHandler(name, listener, evtNamespace) || added;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return added;\r\n}\r\n/**\r\n * Bind the listener to the array of events\r\n * @param events - An string array of event names to bind the listener to\r\n * @param listener - The event callback to call when the event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\r\nexport function addEventListeners(events, listener, excludeEvents, evtNamespace) {\r\n    var added = false;\r\n    if (listener && events && isArray(events)) {\r\n        added = _addEventListeners(events, listener, excludeEvents, evtNamespace);\r\n        if (!added && excludeEvents && excludeEvents[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n            // Failed to add any listeners and we excluded some, so just attempt to add the excluded events\r\n            added = _addEventListeners(events, listener, null, evtNamespace);\r\n        }\r\n    }\r\n    return added;\r\n}\r\n/**\r\n * Remove the listener from the array of events\r\n * @param events - An string array of event names to bind the listener to\r\n * @param listener - The event callback to call when the event is triggered\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n */\r\nexport function removeEventListeners(events, listener, evtNamespace) {\r\n    if (events && isArray(events)) {\r\n        arrForEach(events, function (name) {\r\n            if (name) {\r\n                removeEventHandler(name, listener, evtNamespace);\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Listen to the 'beforeunload', 'unload' and 'pagehide' events which indicates a page unload is occurring,\r\n * this does NOT listen to the 'visibilitychange' event as while it does indicate that the page is being hidden\r\n * it does not *necessarily* mean that the page is being completely unloaded, it can mean that the user is\r\n * just navigating to a different Tab and may come back (without unloading the page). As such you may also\r\n * need to listen to the 'addPageHideEventListener' and 'addPageShowEventListener' events.\r\n * @param listener - The event callback to call when a page unload event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked, unless no other events can be.\r\n * @param evtNamespace - [Optional] Namespace(s) to append to the event listeners so they can be uniquely identified and removed based on this namespace.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\r\nexport function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {\r\n    // Hook the unload event for the document, window and body to ensure that the client events are flushed to the server\r\n    // As just hooking the window does not always fire (on chrome) for page navigation's.\r\n    return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);\r\n}\r\n/**\r\n * Remove any matching 'beforeunload', 'unload' and 'pagehide' events that may have been added via addEventListener,\r\n * addEventListeners, addPageUnloadEventListener or addPageHideEventListener.\r\n * @param listener - The specific event callback to to be removed\r\n * @param evtNamespace - [Optional] Namespace(s) uniquely identified and removed based on this namespace.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\r\nexport function removePageUnloadEventListener(listener, evtNamespace) {\r\n    removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);\r\n}\r\n/**\r\n * Listen to the pagehide and visibility changing to 'hidden' events, because the 'visibilitychange' uses\r\n * an internal proxy to detect the visibility state you SHOULD use a unique namespace when if you plan to call\r\n * removePageShowEventListener as the remove ignores the listener argument for the 'visibilitychange' event.\r\n * @param listener - The event callback to call when a page hide event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.\r\n * @param evtNamespace - [Optional] A Namespace to append to the event listeners so they can be uniquely identified and removed\r\n * based on this namespace. This call also adds an additional unique \"pageshow\" namespace to the events\r\n * so that only the matching \"removePageHideEventListener\" can remove these events.\r\n * Suggestion: pass as true if you are also calling addPageUnloadEventListener as that also hooks pagehide\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\r\nexport function addPageHideEventListener(listener, excludeEvents, evtNamespace) {\r\n    function _handlePageVisibility(evt) {\r\n        var doc = getDocument();\r\n        if (listener && doc && doc.visibilityState === \"hidden\") {\r\n            listener(evt);\r\n        }\r\n    }\r\n    // add the unique page show namespace to any provided namespace so we can only remove the ones added by \"pagehide\"\r\n    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);\r\n    var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);\r\n    if (!excludeEvents || arrIndexOf(excludeEvents, strVisibilityChangeEvt) === -1) {\r\n        pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;\r\n    }\r\n    if (!pageUnloadAdded && excludeEvents) {\r\n        // Failed to add any listeners and we where requested to exclude some, so just call again without excluding anything\r\n        pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);\r\n    }\r\n    return pageUnloadAdded;\r\n}\r\n/**\r\n * Removes the pageHide event listeners added by addPageHideEventListener, because the 'visibilitychange' uses\r\n * an internal proxy to detect the visibility state you SHOULD use a unique namespace when calling addPageHideEventListener\r\n * as the remove ignores the listener argument for the 'visibilitychange' event.\r\n * @param listener - The specific listener to remove for the 'pageshow' event only (ignored for 'visibilitychange')\r\n * @param evtNamespace - The unique namespace used when calling addPageShowEventListener\r\n */\r\nexport function removePageHideEventListener(listener, evtNamespace) {\r\n    // add the unique page show namespace to any provided namespace so we only remove the ones added by \"pagehide\"\r\n    var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);\r\n    removeEventListeners([strPageHide], listener, newNamespaces);\r\n    removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);\r\n}\r\n/**\r\n * Listen to the pageshow and visibility changing to 'visible' events, because the 'visibilitychange' uses\r\n * an internal proxy to detect the visibility state you SHOULD use a unique namespace when if you plan to call\r\n * removePageShowEventListener as the remove ignores the listener argument for the 'visibilitychange' event.\r\n * @param listener - The event callback to call when a page is show event is triggered\r\n * @param excludeEvents - [Optional] An array of events that should not be hooked (if possible), unless no other events can be.\r\n * @param evtNamespace - [Optional/Recommended] A Namespace to append to the event listeners so they can be uniquely\r\n * identified and removed based on this namespace. This call also adds an additional unique \"pageshow\" namespace to the events\r\n * so that only the matching \"removePageShowEventListener\" can remove these events.\r\n * @returns true - when at least one of the events was registered otherwise false\r\n */\r\nexport function addPageShowEventListener(listener, excludeEvents, evtNamespace) {\r\n    function _handlePageVisibility(evt) {\r\n        var doc = getDocument();\r\n        if (listener && doc && doc.visibilityState === \"visible\") {\r\n            listener(evt);\r\n        }\r\n    }\r\n    // add the unique page show namespace to any provided namespace so we can only remove the ones added by \"pageshow\"\r\n    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);\r\n    var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);\r\n    pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;\r\n    if (!pageShowAdded && excludeEvents) {\r\n        // Failed to add any listeners and we where requested to exclude some, so just call again without excluding anything\r\n        pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);\r\n    }\r\n    return pageShowAdded;\r\n}\r\n/**\r\n * Removes the pageShow event listeners added by addPageShowEventListener, because the 'visibilitychange' uses\r\n * an internal proxy to detect the visibility state you SHOULD use a unique namespace when calling addPageShowEventListener\r\n * as the remove ignores the listener argument for the 'visibilitychange' event.\r\n * @param listener - The specific listener to remove for the 'pageshow' event only (ignored for 'visibilitychange')\r\n * @param evtNamespace - The unique namespace used when calling addPageShowEventListener\r\n */\r\nexport function removePageShowEventListener(listener, evtNamespace) {\r\n    // add the unique page show namespace to any provided namespace so we only remove the ones added by \"pageshow\"\r\n    var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);\r\n    removeEventListeners([strPageShow], listener, newNamespaces);\r\n    removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);\r\n}\r\n//# sourceMappingURL=EventHelpers.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}