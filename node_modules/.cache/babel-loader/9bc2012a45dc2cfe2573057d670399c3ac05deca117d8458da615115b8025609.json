{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\nimport { arrForEach, isArray, isString, strLeft, strTrim } from \"@nevware21/ts-utils\";\nimport { _DYN_GET_ATTRIBUTE, _DYN_LENGTH, _DYN_PUSH, _DYN_SPAN_ID, _DYN_SPLIT, _DYN_TO_LOWER_CASE, _DYN_TRACE_FLAGS, _DYN_TRACE_ID, _DYN_VERSION } from \"../__DynamicConstants\";\nimport { generateW3CId } from \"./CoreUtils\";\nimport { findMetaTag, findNamedServerTiming } from \"./EnvUtils\";\nimport { STR_EMPTY } from \"./InternalConstants\";\n// using {0,16} for leading and trailing whitespace just to constrain the possible runtime of a random string\nvar TRACE_PARENT_REGEX = /^([\\da-f]{2})-([\\da-f]{32})-([\\da-f]{16})-([\\da-f]{2})(-[^\\s]{1,64})?$/i;\nvar DEFAULT_VERSION = \"00\";\nvar INVALID_VERSION = \"ff\";\nvar INVALID_TRACE_ID = \"00000000000000000000000000000000\";\nvar INVALID_SPAN_ID = \"0000000000000000\";\nvar SAMPLED_FLAG = 0x01;\nfunction _isValid(value, len, invalidValue) {\n  if (value && value[_DYN_LENGTH /* @min:%2elength */] === len && value !== invalidValue) {\n    return !!value.match(/^[\\da-f]*$/i);\n  }\n  return false;\n}\nfunction _formatValue(value, len, defValue) {\n  if (_isValid(value, len)) {\n    return value;\n  }\n  return defValue;\n}\nfunction _formatFlags(value) {\n  if (isNaN(value) || value < 0 || value > 255) {\n    value = 0x01;\n  }\n  var result = value.toString(16);\n  while (result[_DYN_LENGTH /* @min:%2elength */] < 2) {\n    result = \"0\" + result;\n  }\n  return result;\n}\n/**\r\n * Create a new ITraceParent instance using the provided values.\r\n * @param traceId - The traceId to use, when invalid a new random W3C id will be generated.\r\n * @param spanId - The parent/span id to use, a new random value will be generated if it is invalid.\r\n * @param flags - The traceFlags to use, defaults to zero (0) if not supplied or invalid\r\n * @param version - The version to used, defaults to version \"01\" if not supplied or invalid.\r\n * @returns\r\n */\nexport function createTraceParent(traceId, spanId, flags, version) {\n  var _a;\n  return _a = {}, _a[_DYN_VERSION /* @min:version */] = _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION, _a[_DYN_TRACE_ID /* @min:traceId */] = isValidTraceId(traceId) ? traceId : generateW3CId(), _a[_DYN_SPAN_ID /* @min:spanId */] = isValidSpanId(spanId) ? spanId : strLeft(generateW3CId(), 16), _a.traceFlags = flags >= 0 && flags <= 0xFF ? flags : 1, _a;\n}\n/**\r\n * Attempt to parse the provided string as a W3C TraceParent header value (https://www.w3.org/TR/trace-context/#traceparent-header)\r\n *\r\n * @param value - The value to be parsed\r\n * @param selectIdx - If the found value is comma separated which is the preferred entry to select, defaults to the first\r\n * @returns\r\n */\nexport function parseTraceParent(value, selectIdx) {\n  var _a;\n  if (!value) {\n    // Don't pass a null/undefined or empty string\n    return null;\n  }\n  if (isArray(value)) {\n    // The value may have been encoded on the page into an array so handle this automatically\n    value = value[0] || \"\";\n  }\n  if (!value || !isString(value) || value[_DYN_LENGTH /* @min:%2elength */] > 8192) {\n    // limit potential processing based on total length\n    return null;\n  }\n  if (value.indexOf(\",\") !== -1) {\n    var values = value[_DYN_SPLIT /* @min:%2esplit */](\",\");\n    value = values[selectIdx > 0 && values[_DYN_LENGTH /* @min:%2elength */] > selectIdx ? selectIdx : 0];\n  }\n  // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\n  var match = TRACE_PARENT_REGEX.exec(strTrim(value));\n  if (!match ||\n  // No match\n  match[1] === INVALID_VERSION ||\n  // version ff is forbidden\n  match[2] === INVALID_TRACE_ID ||\n  // All zeros is considered to be invalid\n  match[3] === INVALID_SPAN_ID) {\n    // All zeros is considered to be invalid\n    return null;\n  }\n  return _a = {\n    version: (match[1] || STR_EMPTY)[_DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),\n    traceId: (match[2] || STR_EMPTY)[_DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),\n    spanId: (match[3] || STR_EMPTY)[_DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]()\n  }, _a[_DYN_TRACE_FLAGS /* @min:traceFlags */] = parseInt(match[4], 16), _a;\n}\n/**\r\n * Is the provided W3c Trace Id a valid string representation, it must be a 32-character string\r\n * of lowercase hexadecimal characters for example, 4bf92f3577b34da6a3ce929d0e0e4736.\r\n * If all characters as zero (00000000000000000000000000000000) it will be considered an invalid value.\r\n * @param value - The W3c trace Id to be validated\r\n * @returns true if valid otherwise false\r\n */\nexport function isValidTraceId(value) {\n  return _isValid(value, 32, INVALID_TRACE_ID);\n}\n/**\r\n * Is the provided W3c span id (aka. parent id) a valid string representation, it must be a 16-character\r\n * string of lowercase hexadecimal characters, for example, 00f067aa0ba902b7.\r\n * If all characters are zero (0000000000000000) this is considered an invalid value.\r\n * @param value - The W3c span id to be validated\r\n * @returns true if valid otherwise false\r\n */\nexport function isValidSpanId(value) {\n  return _isValid(value, 16, INVALID_SPAN_ID);\n}\n/**\r\n * Validates that the provided ITraceParent instance conforms to the currently supported specifications\r\n * @param value\r\n * @returns\r\n */\nexport function isValidTraceParent(value) {\n  if (!value || !_isValid(value[_DYN_VERSION /* @min:%2eversion */], 2, INVALID_VERSION) || !_isValid(value[_DYN_TRACE_ID /* @min:%2etraceId */], 32, INVALID_TRACE_ID) || !_isValid(value[_DYN_SPAN_ID /* @min:%2espanId */], 16, INVALID_SPAN_ID) || !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */]), 2)) {\n    // Each known field must contain a valid value\n    return false;\n  }\n  return true;\n}\n/**\r\n * Is the parsed traceParent indicating that the trace is currently sampled.\r\n * @param value - The parsed traceParent value\r\n * @returns\r\n */\nexport function isSampledFlag(value) {\n  if (isValidTraceParent(value)) {\n    return (value[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */] & SAMPLED_FLAG) === SAMPLED_FLAG;\n  }\n  return false;\n}\n/**\r\n * Format the ITraceParent value as a string using the supported and know version formats.\r\n * So even if the passed traceParent is a later version the string value returned from this\r\n * function will convert it to only the known version formats.\r\n * This currently only supports version \"00\" and invalid \"ff\"\r\n * @param value - The parsed traceParent value\r\n * @returns\r\n */\nexport function formatTraceParent(value) {\n  if (value) {\n    // Special Note: This only supports formatting as version 00, future versions should encode any known supported version\n    // So parsing a future version will populate the correct version value but reformatting will reduce it to version 00.\n    var flags = _formatFlags(value[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */]);\n    if (!_isValid(flags, 2)) {\n      flags = \"01\";\n    }\n    var version = value[_DYN_VERSION /* @min:%2eversion */] || DEFAULT_VERSION;\n    if (version !== \"00\" && version !== \"ff\") {\n      // Reduce version to \"00\"\n      version = DEFAULT_VERSION;\n    }\n    // Format as version 00\n    return \"\".concat(version.toLowerCase(), \"-\").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), \"-\").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), \"-\").concat(flags.toLowerCase());\n  }\n  return \"\";\n}\n/**\r\n * Helper function to fetch the passed traceparent from the page, looking for it as a meta-tag or a Server-Timing header.\r\n * @param selectIdx - If the found value is comma separated which is the preferred entry to select, defaults to the first\r\n * @returns\r\n */\nexport function findW3cTraceParent(selectIdx) {\n  var name = \"traceparent\";\n  var traceParent = parseTraceParent(findMetaTag(name), selectIdx);\n  if (!traceParent) {\n    traceParent = parseTraceParent(findNamedServerTiming(name), selectIdx);\n  }\n  return traceParent;\n}\n/**\r\n * Find all script tags in the provided document and return the information about them.\r\n * @param doc\r\n * @returns\r\n */\nexport function findAllScripts(doc) {\n  var scripts = doc.getElementsByTagName(\"script\");\n  var result = [];\n  arrForEach(scripts, function (script) {\n    var src = script[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](\"src\");\n    if (src) {\n      var crossOrigin = script[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](\"crossorigin\");\n      var async = script.hasAttribute(\"async\") === true;\n      var defer = script.hasAttribute(\"defer\") === true;\n      var referrerPolicy = script[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](\"referrerpolicy\");\n      var info = {\n        url: src\n      };\n      if (crossOrigin) {\n        info.crossOrigin = crossOrigin;\n      }\n      if (async) {\n        info.async = async;\n      }\n      if (defer) {\n        info.defer = defer;\n      }\n      if (referrerPolicy) {\n        info.referrerPolicy = referrerPolicy;\n      }\n      result[_DYN_PUSH /* @min:%2epush */](info);\n    }\n  });\n  return result;\n}","map":{"version":3,"names":["arrForEach","isArray","isString","strLeft","strTrim","_DYN_GET_ATTRIBUTE","_DYN_LENGTH","_DYN_PUSH","_DYN_SPAN_ID","_DYN_SPLIT","_DYN_TO_LOWER_CASE","_DYN_TRACE_FLAGS","_DYN_TRACE_ID","_DYN_VERSION","generateW3CId","findMetaTag","findNamedServerTiming","STR_EMPTY","TRACE_PARENT_REGEX","DEFAULT_VERSION","INVALID_VERSION","INVALID_TRACE_ID","INVALID_SPAN_ID","SAMPLED_FLAG","_isValid","value","len","invalidValue","match","_formatValue","defValue","_formatFlags","isNaN","result","toString","createTraceParent","traceId","spanId","flags","version","_a","isValidTraceId","isValidSpanId","traceFlags","parseTraceParent","selectIdx","indexOf","values","exec","parseInt","isValidTraceParent","isSampledFlag","formatTraceParent","concat","toLowerCase","findW3cTraceParent","name","traceParent","findAllScripts","doc","scripts","getElementsByTagName","script","src","crossOrigin","async","hasAttribute","defer","referrerPolicy","info","url"],"sources":["/home/veeresh133/app/test-error-react/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/W3cTraceParent.js"],"sourcesContent":["import { arrForEach, isArray, isString, strLeft, strTrim } from \"@nevware21/ts-utils\";\r\nimport { _DYN_GET_ATTRIBUTE, _DYN_LENGTH, _DYN_PUSH, _DYN_SPAN_ID, _DYN_SPLIT, _DYN_TO_LOWER_CASE, _DYN_TRACE_FLAGS, _DYN_TRACE_ID, _DYN_VERSION } from \"../__DynamicConstants\";\r\nimport { generateW3CId } from \"./CoreUtils\";\r\nimport { findMetaTag, findNamedServerTiming } from \"./EnvUtils\";\r\nimport { STR_EMPTY } from \"./InternalConstants\";\r\n// using {0,16} for leading and trailing whitespace just to constrain the possible runtime of a random string\r\nvar TRACE_PARENT_REGEX = /^([\\da-f]{2})-([\\da-f]{32})-([\\da-f]{16})-([\\da-f]{2})(-[^\\s]{1,64})?$/i;\r\nvar DEFAULT_VERSION = \"00\";\r\nvar INVALID_VERSION = \"ff\";\r\nvar INVALID_TRACE_ID = \"00000000000000000000000000000000\";\r\nvar INVALID_SPAN_ID = \"0000000000000000\";\r\nvar SAMPLED_FLAG = 0x01;\r\nfunction _isValid(value, len, invalidValue) {\r\n    if (value && value[_DYN_LENGTH /* @min:%2elength */] === len && value !== invalidValue) {\r\n        return !!value.match(/^[\\da-f]*$/i);\r\n    }\r\n    return false;\r\n}\r\nfunction _formatValue(value, len, defValue) {\r\n    if (_isValid(value, len)) {\r\n        return value;\r\n    }\r\n    return defValue;\r\n}\r\nfunction _formatFlags(value) {\r\n    if (isNaN(value) || value < 0 || value > 255) {\r\n        value = 0x01;\r\n    }\r\n    var result = value.toString(16);\r\n    while (result[_DYN_LENGTH /* @min:%2elength */] < 2) {\r\n        result = \"0\" + result;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Create a new ITraceParent instance using the provided values.\r\n * @param traceId - The traceId to use, when invalid a new random W3C id will be generated.\r\n * @param spanId - The parent/span id to use, a new random value will be generated if it is invalid.\r\n * @param flags - The traceFlags to use, defaults to zero (0) if not supplied or invalid\r\n * @param version - The version to used, defaults to version \"01\" if not supplied or invalid.\r\n * @returns\r\n */\r\nexport function createTraceParent(traceId, spanId, flags, version) {\r\n    var _a;\r\n    return _a = {},\r\n        _a[_DYN_VERSION /* @min:version */] = _isValid(version, 2, INVALID_VERSION) ? version : DEFAULT_VERSION,\r\n        _a[_DYN_TRACE_ID /* @min:traceId */] = isValidTraceId(traceId) ? traceId : generateW3CId(),\r\n        _a[_DYN_SPAN_ID /* @min:spanId */] = isValidSpanId(spanId) ? spanId : strLeft(generateW3CId(), 16),\r\n        _a.traceFlags = flags >= 0 && flags <= 0xFF ? flags : 1,\r\n        _a;\r\n}\r\n/**\r\n * Attempt to parse the provided string as a W3C TraceParent header value (https://www.w3.org/TR/trace-context/#traceparent-header)\r\n *\r\n * @param value - The value to be parsed\r\n * @param selectIdx - If the found value is comma separated which is the preferred entry to select, defaults to the first\r\n * @returns\r\n */\r\nexport function parseTraceParent(value, selectIdx) {\r\n    var _a;\r\n    if (!value) {\r\n        // Don't pass a null/undefined or empty string\r\n        return null;\r\n    }\r\n    if (isArray(value)) {\r\n        // The value may have been encoded on the page into an array so handle this automatically\r\n        value = value[0] || \"\";\r\n    }\r\n    if (!value || !isString(value) || value[_DYN_LENGTH /* @min:%2elength */] > 8192) {\r\n        // limit potential processing based on total length\r\n        return null;\r\n    }\r\n    if (value.indexOf(\",\") !== -1) {\r\n        var values = value[_DYN_SPLIT /* @min:%2esplit */](\",\");\r\n        value = values[selectIdx > 0 && values[_DYN_LENGTH /* @min:%2elength */] > selectIdx ? selectIdx : 0];\r\n    }\r\n    // See https://www.w3.org/TR/trace-context/#versioning-of-traceparent\r\n    var match = TRACE_PARENT_REGEX.exec(strTrim(value));\r\n    if (!match || // No match\r\n        match[1] === INVALID_VERSION || // version ff is forbidden\r\n        match[2] === INVALID_TRACE_ID || // All zeros is considered to be invalid\r\n        match[3] === INVALID_SPAN_ID) { // All zeros is considered to be invalid\r\n        return null;\r\n    }\r\n    return _a = {\r\n            version: (match[1] || STR_EMPTY)[_DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),\r\n            traceId: (match[2] || STR_EMPTY)[_DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */](),\r\n            spanId: (match[3] || STR_EMPTY)[_DYN_TO_LOWER_CASE /* @min:%2etoLowerCase */]()\r\n        },\r\n        _a[_DYN_TRACE_FLAGS /* @min:traceFlags */] = parseInt(match[4], 16),\r\n        _a;\r\n}\r\n/**\r\n * Is the provided W3c Trace Id a valid string representation, it must be a 32-character string\r\n * of lowercase hexadecimal characters for example, 4bf92f3577b34da6a3ce929d0e0e4736.\r\n * If all characters as zero (00000000000000000000000000000000) it will be considered an invalid value.\r\n * @param value - The W3c trace Id to be validated\r\n * @returns true if valid otherwise false\r\n */\r\nexport function isValidTraceId(value) {\r\n    return _isValid(value, 32, INVALID_TRACE_ID);\r\n}\r\n/**\r\n * Is the provided W3c span id (aka. parent id) a valid string representation, it must be a 16-character\r\n * string of lowercase hexadecimal characters, for example, 00f067aa0ba902b7.\r\n * If all characters are zero (0000000000000000) this is considered an invalid value.\r\n * @param value - The W3c span id to be validated\r\n * @returns true if valid otherwise false\r\n */\r\nexport function isValidSpanId(value) {\r\n    return _isValid(value, 16, INVALID_SPAN_ID);\r\n}\r\n/**\r\n * Validates that the provided ITraceParent instance conforms to the currently supported specifications\r\n * @param value\r\n * @returns\r\n */\r\nexport function isValidTraceParent(value) {\r\n    if (!value ||\r\n        !_isValid(value[_DYN_VERSION /* @min:%2eversion */], 2, INVALID_VERSION) ||\r\n        !_isValid(value[_DYN_TRACE_ID /* @min:%2etraceId */], 32, INVALID_TRACE_ID) ||\r\n        !_isValid(value[_DYN_SPAN_ID /* @min:%2espanId */], 16, INVALID_SPAN_ID) ||\r\n        !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */]), 2)) {\r\n        // Each known field must contain a valid value\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Is the parsed traceParent indicating that the trace is currently sampled.\r\n * @param value - The parsed traceParent value\r\n * @returns\r\n */\r\nexport function isSampledFlag(value) {\r\n    if (isValidTraceParent(value)) {\r\n        return (value[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */] & SAMPLED_FLAG) === SAMPLED_FLAG;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Format the ITraceParent value as a string using the supported and know version formats.\r\n * So even if the passed traceParent is a later version the string value returned from this\r\n * function will convert it to only the known version formats.\r\n * This currently only supports version \"00\" and invalid \"ff\"\r\n * @param value - The parsed traceParent value\r\n * @returns\r\n */\r\nexport function formatTraceParent(value) {\r\n    if (value) {\r\n        // Special Note: This only supports formatting as version 00, future versions should encode any known supported version\r\n        // So parsing a future version will populate the correct version value but reformatting will reduce it to version 00.\r\n        var flags = _formatFlags(value[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */]);\r\n        if (!_isValid(flags, 2)) {\r\n            flags = \"01\";\r\n        }\r\n        var version = value[_DYN_VERSION /* @min:%2eversion */] || DEFAULT_VERSION;\r\n        if (version !== \"00\" && version !== \"ff\") {\r\n            // Reduce version to \"00\"\r\n            version = DEFAULT_VERSION;\r\n        }\r\n        // Format as version 00\r\n        return \"\".concat(version.toLowerCase(), \"-\").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID).toLowerCase(), \"-\").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID).toLowerCase(), \"-\").concat(flags.toLowerCase());\r\n    }\r\n    return \"\";\r\n}\r\n/**\r\n * Helper function to fetch the passed traceparent from the page, looking for it as a meta-tag or a Server-Timing header.\r\n * @param selectIdx - If the found value is comma separated which is the preferred entry to select, defaults to the first\r\n * @returns\r\n */\r\nexport function findW3cTraceParent(selectIdx) {\r\n    var name = \"traceparent\";\r\n    var traceParent = parseTraceParent(findMetaTag(name), selectIdx);\r\n    if (!traceParent) {\r\n        traceParent = parseTraceParent(findNamedServerTiming(name), selectIdx);\r\n    }\r\n    return traceParent;\r\n}\r\n/**\r\n * Find all script tags in the provided document and return the information about them.\r\n * @param doc\r\n * @returns\r\n */\r\nexport function findAllScripts(doc) {\r\n    var scripts = doc.getElementsByTagName(\"script\");\r\n    var result = [];\r\n    arrForEach(scripts, function (script) {\r\n        var src = script[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](\"src\");\r\n        if (src) {\r\n            var crossOrigin = script[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](\"crossorigin\");\r\n            var async = script.hasAttribute(\"async\") === true;\r\n            var defer = script.hasAttribute(\"defer\") === true;\r\n            var referrerPolicy = script[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](\"referrerpolicy\");\r\n            var info = { url: src };\r\n            if (crossOrigin) {\r\n                info.crossOrigin = crossOrigin;\r\n            }\r\n            if (async) {\r\n                info.async = async;\r\n            }\r\n            if (defer) {\r\n                info.defer = defer;\r\n            }\r\n            if (referrerPolicy) {\r\n                info.referrerPolicy = referrerPolicy;\r\n            }\r\n            result[_DYN_PUSH /* @min:%2epush */](info);\r\n        }\r\n    });\r\n    return result;\r\n}\r\n//# sourceMappingURL=W3cTraceParent.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}