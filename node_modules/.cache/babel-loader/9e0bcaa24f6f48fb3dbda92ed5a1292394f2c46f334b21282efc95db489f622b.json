{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport { asString, isArray, isDefined, isNullOrUndefined, isObject, isPlainObject, isUndefined, objForEachKey, objHasOwn } from \"@nevware21/ts-utils\";\nimport { _DYN_BLK_VAL, _DYN_LENGTH, _DYN_RD_ONLY } from \"../__DynamicConstants\";\nfunction _isConfigDefaults(value) {\n  return value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, \"v\") || objHasOwn(value, \"mrg\") || objHasOwn(value, \"ref\") || value.set);\n}\nfunction _getDefault(dynamicHandler, theConfig, cfgDefaults) {\n  var defValue;\n  var isDefaultValid = cfgDefaults.dfVal || isDefined;\n  // There is a fallback config key so try and grab that first\n  if (theConfig && cfgDefaults.fb) {\n    var fallbacks = cfgDefaults.fb;\n    if (!isArray(fallbacks)) {\n      fallbacks = [fallbacks];\n    }\n    for (var lp = 0; lp < fallbacks[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n      var fallback = fallbacks[lp];\n      var fbValue = theConfig[fallback];\n      if (isDefaultValid(fbValue)) {\n        defValue = fbValue;\n      } else if (dynamicHandler) {\n        // Needed to ensure that the fallback value (and potentially) new field is also dynamic even if null/undefined\n        fbValue = dynamicHandler.cfg[fallback];\n        if (isDefaultValid(fbValue)) {\n          defValue = fbValue;\n        }\n        // Needed to ensure that the fallback value (and potentially) new field is also dynamic even if null/undefined\n        dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);\n      }\n      if (isDefaultValid(defValue)) {\n        // We have a valid default so break out of the look\n        break;\n      }\n    }\n  }\n  // If the value is still not defined and we have a default value then use that\n  if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {\n    defValue = cfgDefaults.v;\n  }\n  return defValue;\n}\n/**\r\n * Recursively resolve the default value\r\n * @param dynamicHandler\r\n * @param theConfig\r\n * @param cfgDefaults\r\n * @returns\r\n */\nfunction _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {\n  var theValue = cfgDefaults;\n  if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {\n    theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);\n  }\n  if (theValue) {\n    if (_isConfigDefaults(theValue)) {\n      theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);\n    }\n    var newValue_1;\n    if (isArray(theValue)) {\n      newValue_1 = [];\n      newValue_1[_DYN_LENGTH /* @min:%2elength */] = theValue[_DYN_LENGTH /* @min:%2elength */];\n    } else if (isPlainObject(theValue)) {\n      newValue_1 = {};\n    }\n    if (newValue_1) {\n      objForEachKey(theValue, function (key, value) {\n        if (value && _isConfigDefaults(value)) {\n          value = _resolveDefaultValue(dynamicHandler, theConfig, value);\n        }\n        newValue_1[key] = value;\n      });\n      theValue = newValue_1;\n    }\n  }\n  return theValue;\n}\n/**\r\n * Applies the default value on the config property and makes sure that it's dynamic\r\n * @param theConfig\r\n * @param name\r\n * @param defaultValue\r\n */\nexport function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {\n  // Resolve the initial config value from the provided value or use the defined default\n  var isValid;\n  var setFn;\n  var defValue;\n  var cfgDefaults = defaultValue;\n  var mergeDf;\n  var reference;\n  var readOnly;\n  var blkDynamicValue;\n  if (_isConfigDefaults(cfgDefaults)) {\n    // looks like a IConfigDefault\n    isValid = cfgDefaults.isVal;\n    setFn = cfgDefaults.set;\n    readOnly = cfgDefaults[_DYN_RD_ONLY /* @min:%2erdOnly */];\n    blkDynamicValue = cfgDefaults[_DYN_BLK_VAL /* @min:%2eblkVal */];\n    mergeDf = cfgDefaults.mrg;\n    reference = cfgDefaults.ref;\n    if (!reference && isUndefined(reference)) {\n      reference = !!mergeDf;\n    }\n    defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);\n  } else {\n    defValue = defaultValue;\n  }\n  if (blkDynamicValue) {\n    // Mark the property so that any value assigned will be blocked from conversion, we need to do this\n    // before assigning or fetching the value to ensure it's not converted\n    dynamicHandler[_DYN_BLK_VAL /* @min:%2eblkVal */](theConfig, name);\n  }\n  // Set the value to the default value;\n  var theValue;\n  var usingDefault = true;\n  var cfgValue = theConfig[name];\n  // try and get and user provided values\n  if (cfgValue || !isNullOrUndefined(cfgValue)) {\n    // Use the defined theConfig[name] value\n    theValue = cfgValue;\n    usingDefault = false;\n    // The values are different and we have a special default value check, which is used to\n    // override config values like empty strings to continue using the default\n    if (isValid && theValue !== defValue && !isValid(theValue)) {\n      theValue = defValue;\n      usingDefault = true;\n    }\n    if (setFn) {\n      theValue = setFn(theValue, defValue, theConfig);\n      usingDefault = theValue === defValue;\n    }\n  }\n  if (!usingDefault) {\n    if (isPlainObject(theValue) || isArray(defValue)) {\n      // we are using the user supplied value and it's an object\n      if (mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue))) {\n        // Resolve/apply the defaults\n        objForEachKey(defValue, function (dfName, dfValue) {\n          // Sets the value and makes it dynamic (if it doesn't already exist)\n          _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);\n        });\n      }\n    }\n  } else if (defValue) {\n    // Just resolve the default\n    theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);\n  } else {\n    theValue = defValue;\n  }\n  // if (theValue && usingDefault && (isPlainObject(theValue) || isArray(theValue))) {\n  //     theValue = _cfgDeepCopy(theValue);\n  // }\n  // Needed to ensure that the (potentially) new field is dynamic even if null/undefined\n  dynamicHandler.set(theConfig, name, theValue);\n  if (reference) {\n    dynamicHandler.ref(theConfig, name);\n  }\n  if (readOnly) {\n    dynamicHandler[_DYN_RD_ONLY /* @min:%2erdOnly */](theConfig, name);\n  }\n}","map":{"version":3,"names":["asString","isArray","isDefined","isNullOrUndefined","isObject","isPlainObject","isUndefined","objForEachKey","objHasOwn","_DYN_BLK_VAL","_DYN_LENGTH","_DYN_RD_ONLY","_isConfigDefaults","value","isVal","fb","set","_getDefault","dynamicHandler","theConfig","cfgDefaults","defValue","isDefaultValid","dfVal","fallbacks","lp","fallback","fbValue","cfg","v","_resolveDefaultValue","theValue","newValue_1","key","_applyDefaultValue","name","defaultValue","isValid","setFn","mergeDf","reference","readOnly","blkDynamicValue","mrg","ref","usingDefault","cfgValue","dfName","dfValue"],"sources":["/home/veeresh133/app/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/Config/ConfigDefaults.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { asString, isArray, isDefined, isNullOrUndefined, isObject, isPlainObject, isUndefined, objForEachKey, objHasOwn } from \"@nevware21/ts-utils\";\r\nimport { _DYN_BLK_VAL, _DYN_LENGTH, _DYN_RD_ONLY } from \"../__DynamicConstants\";\r\nfunction _isConfigDefaults(value) {\r\n    return (value && isObject(value) && (value.isVal || value.fb || objHasOwn(value, \"v\") || objHasOwn(value, \"mrg\") || objHasOwn(value, \"ref\") || value.set));\r\n}\r\nfunction _getDefault(dynamicHandler, theConfig, cfgDefaults) {\r\n    var defValue;\r\n    var isDefaultValid = cfgDefaults.dfVal || isDefined;\r\n    // There is a fallback config key so try and grab that first\r\n    if (theConfig && cfgDefaults.fb) {\r\n        var fallbacks = cfgDefaults.fb;\r\n        if (!isArray(fallbacks)) {\r\n            fallbacks = [fallbacks];\r\n        }\r\n        for (var lp = 0; lp < fallbacks[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n            var fallback = fallbacks[lp];\r\n            var fbValue = theConfig[fallback];\r\n            if (isDefaultValid(fbValue)) {\r\n                defValue = fbValue;\r\n            }\r\n            else if (dynamicHandler) {\r\n                // Needed to ensure that the fallback value (and potentially) new field is also dynamic even if null/undefined\r\n                fbValue = dynamicHandler.cfg[fallback];\r\n                if (isDefaultValid(fbValue)) {\r\n                    defValue = fbValue;\r\n                }\r\n                // Needed to ensure that the fallback value (and potentially) new field is also dynamic even if null/undefined\r\n                dynamicHandler.set(dynamicHandler.cfg, asString(fallback), fbValue);\r\n            }\r\n            if (isDefaultValid(defValue)) {\r\n                // We have a valid default so break out of the look\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // If the value is still not defined and we have a default value then use that\r\n    if (!isDefaultValid(defValue) && isDefaultValid(cfgDefaults.v)) {\r\n        defValue = cfgDefaults.v;\r\n    }\r\n    return defValue;\r\n}\r\n/**\r\n * Recursively resolve the default value\r\n * @param dynamicHandler\r\n * @param theConfig\r\n * @param cfgDefaults\r\n * @returns\r\n */\r\nfunction _resolveDefaultValue(dynamicHandler, theConfig, cfgDefaults) {\r\n    var theValue = cfgDefaults;\r\n    if (cfgDefaults && _isConfigDefaults(cfgDefaults)) {\r\n        theValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);\r\n    }\r\n    if (theValue) {\r\n        if (_isConfigDefaults(theValue)) {\r\n            theValue = _resolveDefaultValue(dynamicHandler, theConfig, theValue);\r\n        }\r\n        var newValue_1;\r\n        if (isArray(theValue)) {\r\n            newValue_1 = [];\r\n            newValue_1[_DYN_LENGTH /* @min:%2elength */] = theValue[_DYN_LENGTH /* @min:%2elength */];\r\n        }\r\n        else if (isPlainObject(theValue)) {\r\n            newValue_1 = {};\r\n        }\r\n        if (newValue_1) {\r\n            objForEachKey(theValue, function (key, value) {\r\n                if (value && _isConfigDefaults(value)) {\r\n                    value = _resolveDefaultValue(dynamicHandler, theConfig, value);\r\n                }\r\n                newValue_1[key] = value;\r\n            });\r\n            theValue = newValue_1;\r\n        }\r\n    }\r\n    return theValue;\r\n}\r\n/**\r\n * Applies the default value on the config property and makes sure that it's dynamic\r\n * @param theConfig\r\n * @param name\r\n * @param defaultValue\r\n */\r\nexport function _applyDefaultValue(dynamicHandler, theConfig, name, defaultValue) {\r\n    // Resolve the initial config value from the provided value or use the defined default\r\n    var isValid;\r\n    var setFn;\r\n    var defValue;\r\n    var cfgDefaults = defaultValue;\r\n    var mergeDf;\r\n    var reference;\r\n    var readOnly;\r\n    var blkDynamicValue;\r\n    if (_isConfigDefaults(cfgDefaults)) {\r\n        // looks like a IConfigDefault\r\n        isValid = cfgDefaults.isVal;\r\n        setFn = cfgDefaults.set;\r\n        readOnly = cfgDefaults[_DYN_RD_ONLY /* @min:%2erdOnly */];\r\n        blkDynamicValue = cfgDefaults[_DYN_BLK_VAL /* @min:%2eblkVal */];\r\n        mergeDf = cfgDefaults.mrg;\r\n        reference = cfgDefaults.ref;\r\n        if (!reference && isUndefined(reference)) {\r\n            reference = !!mergeDf;\r\n        }\r\n        defValue = _getDefault(dynamicHandler, theConfig, cfgDefaults);\r\n    }\r\n    else {\r\n        defValue = defaultValue;\r\n    }\r\n    if (blkDynamicValue) {\r\n        // Mark the property so that any value assigned will be blocked from conversion, we need to do this\r\n        // before assigning or fetching the value to ensure it's not converted\r\n        dynamicHandler[_DYN_BLK_VAL /* @min:%2eblkVal */](theConfig, name);\r\n    }\r\n    // Set the value to the default value;\r\n    var theValue;\r\n    var usingDefault = true;\r\n    var cfgValue = theConfig[name];\r\n    // try and get and user provided values\r\n    if (cfgValue || !isNullOrUndefined(cfgValue)) {\r\n        // Use the defined theConfig[name] value\r\n        theValue = cfgValue;\r\n        usingDefault = false;\r\n        // The values are different and we have a special default value check, which is used to\r\n        // override config values like empty strings to continue using the default\r\n        if (isValid && theValue !== defValue && !isValid(theValue)) {\r\n            theValue = defValue;\r\n            usingDefault = true;\r\n        }\r\n        if (setFn) {\r\n            theValue = setFn(theValue, defValue, theConfig);\r\n            usingDefault = theValue === defValue;\r\n        }\r\n    }\r\n    if (!usingDefault) {\r\n        if (isPlainObject(theValue) || isArray(defValue)) {\r\n            // we are using the user supplied value and it's an object\r\n            if (mergeDf && defValue && (isPlainObject(defValue) || isArray(defValue))) {\r\n                // Resolve/apply the defaults\r\n                objForEachKey(defValue, function (dfName, dfValue) {\r\n                    // Sets the value and makes it dynamic (if it doesn't already exist)\r\n                    _applyDefaultValue(dynamicHandler, theValue, dfName, dfValue);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    else if (defValue) {\r\n        // Just resolve the default\r\n        theValue = _resolveDefaultValue(dynamicHandler, theConfig, defValue);\r\n    }\r\n    else {\r\n        theValue = defValue;\r\n    }\r\n    // if (theValue && usingDefault && (isPlainObject(theValue) || isArray(theValue))) {\r\n    //     theValue = _cfgDeepCopy(theValue);\r\n    // }\r\n    // Needed to ensure that the (potentially) new field is dynamic even if null/undefined\r\n    dynamicHandler.set(theConfig, name, theValue);\r\n    if (reference) {\r\n        dynamicHandler.ref(theConfig, name);\r\n    }\r\n    if (readOnly) {\r\n        dynamicHandler[_DYN_RD_ONLY /* @min:%2erdOnly */](theConfig, name);\r\n    }\r\n}\r\n//# sourceMappingURL=ConfigDefaults.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}