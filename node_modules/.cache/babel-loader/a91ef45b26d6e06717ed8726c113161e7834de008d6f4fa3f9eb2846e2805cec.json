{"ast":null,"code":"/*!\n * NevWare21 Solutions LLC - ts-async, 0.5.2\n * https://github.com/nevware21/ts-async\n * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.\n * Licensed under the MIT license.\n */\nimport { isPromiseLike, objDefineProperties, getDocument, createCachedValue, safe, getInst, dumpObj, arrSlice, objDefineProp, hasSymbol, getKnownSymbol, isFunction, throwTypeError, iterForOf, scheduleTimeout, isNode, getWindow, getGlobal, objDefine, objToString, isUndefined, isArray, arrForEach, isIterable, createCustomError, isNumber, scheduleIdleCallback, utcNow, getLength, isIterator, fnCall, arrIndexOf } from '@nevware21/ts-utils';\nvar STR_PROMISE = \"Promise\";\nvar DONE = \"done\";\nvar VALUE = \"value\";\nvar RETURN = \"return\";\nvar REJECTED = \"rejected\";\nfunction doAwaitResponse(value, cb) {\n  return doAwait(value, function (value) {\n    return cb ? cb({\n      status: \"fulfilled\",\n      rejected: false,\n      value: value\n    }) : value;\n  }, function (reason) {\n    return cb ? cb({\n      status: REJECTED,\n      rejected: true,\n      reason: reason\n    }) : reason;\n  });\n}\nfunction doAwait(value, resolveFn, rejectFn, finallyFn) {\n  var result = value;\n  try {\n    if (isPromiseLike(value)) {\n      if (resolveFn || rejectFn) {\n        result = value.then(resolveFn, rejectFn);\n      }\n    } else {\n      try {\n        if (resolveFn) {\n          result = resolveFn(value);\n        }\n      } catch (err) {\n        if (rejectFn) {\n          result = rejectFn(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n  } finally {\n    if (finallyFn) {\n      doFinally(result, finallyFn);\n    }\n  }\n  return result;\n}\nfunction doFinally(value, finallyFn) {\n  var result = value;\n  if (finallyFn) {\n    if (isPromiseLike(value)) {\n      if (value.finally) {\n        result = value.finally(finallyFn);\n      } else {\n        result = value.then(function (value) {\n          finallyFn();\n          return value;\n        }, function (reason) {\n          finallyFn();\n          throw reason;\n        });\n      }\n    } else {\n      finallyFn();\n    }\n  }\n  return result;\n}\nvar _debugState;\nvar _debugResult;\nvar _debugHandled;\nvar _promiseDebugEnabled = false;\nfunction _addDebugState$1(thePromise, stateFn, resultFn, handledFn) {\n  _debugState = _debugState || {\n    toString: function () {\n      return \"[[PromiseState]]\";\n    }\n  };\n  _debugResult = _debugResult || {\n    toString: function () {\n      return \"[[PromiseResult]]\";\n    }\n  };\n  _debugHandled = _debugHandled || {\n    toString: function () {\n      return \"[[PromiseIsHandled]]\";\n    }\n  };\n  var props = {};\n  props[_debugState] = {\n    get: stateFn\n  };\n  props[_debugResult] = {\n    get: resultFn\n  };\n  props[_debugHandled] = {\n    get: handledFn\n  };\n  objDefineProperties(thePromise, props);\n}\nfunction setPromiseDebugState(enabled, logger) {\n  _promiseDebugEnabled = enabled;\n}\nvar STRING_STATES = [\"pending\", \"resolving\", \"resolved\", REJECTED];\nvar DISPATCH_EVENT = \"dispatchEvent\";\nvar _hasInitEvent;\nfunction _hasInitEventFn(doc) {\n  var evt;\n  if (doc && doc.createEvent) {\n    evt = doc.createEvent(\"Event\");\n  }\n  return !!evt && evt.initEvent;\n}\nfunction emitEvent(target, evtName, populateEvent, useNewEvent) {\n  var doc = getDocument();\n  !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [doc]).v));\n  var theEvt = _hasInitEvent.v ? doc.createEvent(\"Event\") : useNewEvent ? new Event(evtName) : {};\n  populateEvent && populateEvent(theEvt);\n  if (_hasInitEvent.v) {\n    theEvt.initEvent(evtName, false, true);\n  }\n  if (theEvt && target[DISPATCH_EVENT]) {\n    target[DISPATCH_EVENT](theEvt);\n  } else {\n    var handler = target[\"on\" + evtName];\n    if (handler) {\n      handler(theEvt);\n    } else {\n      var theConsole = getInst(\"console\");\n      theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, dumpObj(theEvt));\n    }\n  }\n}\nvar NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\nvar UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\nvar _currentPromiseId = [];\nvar _uniquePromiseId = 0;\nvar _unhandledRejectionTimeout = 10;\nvar _aggregationError;\nvar _hasPromiseRejectionEvent;\nfunction dumpFnObj(value) {\n  if (isFunction(value)) {\n    return value.toString();\n  }\n  return dumpObj(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createAggregationError(values) {\n  !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, [\"AggregationError\"]).v || createCustomError(\"AggregationError\", function (self, args) {\n    self.errors = args[0];\n  })));\n  return new _aggregationError.v(values);\n}\nfunction _createPromise(newPromise, processor, executor) {\n  var additionalArgs = arrSlice(arguments, 3);\n  var _state = 0;\n  var _hasResolved = false;\n  var _settledValue;\n  var _queue = [];\n  var _id = _uniquePromiseId++;\n  var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\n  var _handled = false;\n  var _unHandledRejectionHandler = null;\n  var _thePromise;\n  function _then(onResolved, onRejected) {\n    try {\n      _currentPromiseId.push(_id);\n      _handled = true;\n      _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\n      _unHandledRejectionHandler = null;\n      var thenPromise = newPromise(function (resolve, reject) {\n        _queue.push(function () {\n          try {\n            var handler = _state === 2 ? onResolved : onRejected;\n            var value = isUndefined(handler) ? _settledValue : isFunction(handler) ? handler(_settledValue) : handler;\n            if (isPromiseLike(value)) {\n              value.then(resolve, reject);\n            } else if (handler) {\n              resolve(value);\n            } else if (_state === 3) {\n              reject(value);\n            } else {\n              resolve(value);\n            }\n          } catch (e) {\n            reject(e);\n          }\n        });\n        if (_hasResolved) {\n          _processQueue();\n        }\n      }, additionalArgs);\n      return thenPromise;\n    } finally {\n      _currentPromiseId.pop();\n    }\n  }\n  function _catch(onRejected) {\n    return _then(undefined, onRejected);\n  }\n  function _finally(onFinally) {\n    var thenFinally = onFinally;\n    var catchFinally = onFinally;\n    if (isFunction(onFinally)) {\n      thenFinally = function (value) {\n        onFinally && onFinally();\n        return value;\n      };\n      catchFinally = function (reason) {\n        onFinally && onFinally();\n        throw reason;\n      };\n    }\n    return _then(thenFinally, catchFinally);\n  }\n  function _strState() {\n    return STRING_STATES[_state];\n  }\n  function _processQueue() {\n    if (_queue.length > 0) {\n      var pending = _queue.slice();\n      _queue = [];\n      _handled = true;\n      _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\n      _unHandledRejectionHandler = null;\n      processor(pending);\n    }\n  }\n  function _createSettleIfFn(newState, allowState) {\n    return function (theValue) {\n      if (_state === allowState) {\n        if (newState === 2 && isPromiseLike(theValue)) {\n          _state = 1;\n          theValue.then(_createSettleIfFn(2, 1), _createSettleIfFn(3, 1));\n          return;\n        }\n        _state = newState;\n        _hasResolved = true;\n        _settledValue = theValue;\n        _processQueue();\n        if (!_handled && newState === 3 && !_unHandledRejectionHandler) {\n          _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);\n        }\n      }\n    };\n  }\n  function _notifyUnhandledRejection() {\n    if (!_handled) {\n      _handled = true;\n      if (isNode()) {\n        process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\n      } else {\n        var gbl = getWindow() || getGlobal();\n        !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe(getInst, [STR_PROMISE + \"RejectionEvent\"]).v));\n        emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {\n          objDefine(theEvt, \"promise\", {\n            g: function () {\n              return _thePromise;\n            }\n          });\n          theEvt.reason = _settledValue;\n          return theEvt;\n        }, !!_hasPromiseRejectionEvent.v);\n      }\n    }\n  }\n  _thePromise = {\n    then: _then,\n    \"catch\": _catch,\n    finally: _finally\n  };\n  objDefineProp(_thePromise, \"state\", {\n    get: _strState\n  });\n  if (_promiseDebugEnabled) {\n    _addDebugState$1(_thePromise, _strState, function () {\n      return objToString(_settledValue);\n    }, function () {\n      return _handled;\n    });\n  }\n  if (hasSymbol()) {\n    _thePromise[getKnownSymbol(11)] = \"IPromise\";\n  }\n  function _toString() {\n    return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? \":\" + _parentId : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? \" - \" + dumpFnObj(_settledValue) : \"\") + \"\";\n  }\n  _thePromise.toString = _toString;\n  (function _initialize() {\n    if (!isFunction(executor)) {\n      throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\n    }\n    var _rejectFn = _createSettleIfFn(3, 0);\n    try {\n      executor.call(_thePromise, _createSettleIfFn(2, 0), _rejectFn);\n    } catch (e) {\n      _rejectFn(e);\n    }\n  })();\n  return _thePromise;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createAllPromise(newPromise) {\n  return function (input) {\n    var additionalArgs = arrSlice(arguments, 1);\n    return newPromise(function (resolve, reject) {\n      try {\n        var values_1 = [];\n        var pending_1 = 1;\n        iterForOf(input, function (item, idx) {\n          if (item) {\n            pending_1++;\n            doAwait(item, function (value) {\n              values_1[idx] = value;\n              if (--pending_1 === 0) {\n                resolve(values_1);\n              }\n            }, reject);\n          }\n        });\n        pending_1--;\n        if (pending_1 === 0) {\n          resolve(values_1);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    }, additionalArgs);\n  };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createResolvedPromise(newPromise) {\n  return function (value) {\n    var additionalArgs = arrSlice(arguments, 1);\n    if (isPromiseLike(value)) {\n      return value;\n    }\n    return newPromise(function (resolve) {\n      resolve(value);\n    }, additionalArgs);\n  };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createRejectedPromise(newPromise) {\n  return function (reason) {\n    var additionalArgs = arrSlice(arguments, 1);\n    return newPromise(function (_resolve, reject) {\n      reject(reason);\n    }, additionalArgs);\n  };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createAllSettledPromise(newPromise) {\n  return createCachedValue(function (input) {\n    var additionalArgs = arrSlice(arguments, 1);\n    return newPromise(function (resolve, reject) {\n      var values = [];\n      var pending = 1;\n      function processItem(item, idx) {\n        pending++;\n        doAwaitResponse(item, function (value) {\n          if (value.rejected) {\n            values[idx] = {\n              status: REJECTED,\n              reason: value.reason\n            };\n          } else {\n            values[idx] = {\n              status: \"fulfilled\",\n              value: value.value\n            };\n          }\n          if (--pending === 0) {\n            resolve(values);\n          }\n        });\n      }\n      try {\n        if (isArray(input)) {\n          arrForEach(input, processItem);\n        } else if (isIterable(input)) {\n          iterForOf(input, processItem);\n        } else {\n          throwTypeError(\"Input is not an iterable\");\n        }\n        pending--;\n        if (pending === 0) {\n          resolve(values);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    }, additionalArgs);\n  });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createRacePromise(newPromise) {\n  return createCachedValue(function (input) {\n    var additionalArgs = arrSlice(arguments, 1);\n    return newPromise(function (resolve, reject) {\n      var isDone = false;\n      function processItem(item) {\n        doAwaitResponse(item, function (value) {\n          if (!isDone) {\n            isDone = true;\n            if (value.rejected) {\n              reject(value.reason);\n            } else {\n              resolve(value.value);\n            }\n          }\n        });\n      }\n      try {\n        if (isArray(input)) {\n          arrForEach(input, processItem);\n        } else if (isIterable(input)) {\n          iterForOf(input, processItem);\n        } else {\n          throwTypeError(\"Input is not an iterable\");\n        }\n      } catch (e) {\n        reject(e);\n      }\n    }, additionalArgs);\n  });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createAnyPromise(newPromise) {\n  return createCachedValue(function (input) {\n    var additionalArgs = arrSlice(arguments, 1);\n    return newPromise(function (resolve, reject) {\n      var theErros = [];\n      var pending = 1;\n      var isDone = false;\n      function processItem(item, idx) {\n        pending++;\n        doAwaitResponse(item, function (value) {\n          if (!value.rejected) {\n            isDone = true;\n            resolve(value.value);\n            return;\n          } else {\n            theErros[idx] = value.reason;\n          }\n          if (--pending === 0 && !isDone) {\n            reject(_createAggregationError(theErros));\n          }\n        });\n      }\n      try {\n        if (isArray(input)) {\n          arrForEach(input, processItem);\n        } else if (isIterable(input)) {\n          iterForOf(input, processItem);\n        } else {\n          throwTypeError(\"Input is not an iterable\");\n        }\n        pending--;\n        if (pending === 0 && !isDone) {\n          reject(_createAggregationError(theErros));\n        }\n      } catch (e) {\n        reject(e);\n      }\n    }, additionalArgs);\n  });\n}\nfunction syncItemProcessor(pending) {\n  arrForEach(pending, function (fn) {\n    try {\n      fn();\n    } catch (e) {}\n  });\n}\nfunction timeoutItemProcessor(timeout) {\n  var callbackTimeout = isNumber(timeout) ? timeout : 0;\n  return function (pending) {\n    scheduleTimeout(function () {\n      syncItemProcessor(pending);\n    }, callbackTimeout);\n  };\n}\nfunction idleItemProcessor(timeout) {\n  var options;\n  if (timeout >= 0) {\n    options = {\n      timeout: +timeout\n    };\n  }\n  return function (pending) {\n    scheduleIdleCallback(function (deadline) {\n      syncItemProcessor(pending);\n    }, options);\n  };\n}\nvar _allAsyncSettledCreator;\nvar _raceAsyncCreator;\nvar _anyAsyncCreator;\nfunction createAsyncPromise(executor, timeout) {\n  return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\n}\nvar createAsyncAllPromise = /*#__PURE__*/_createAllPromise(createAsyncPromise);\nvar createAsyncResolvedPromise = /*#__PURE__*/_createResolvedPromise(createAsyncPromise);\nvar createAsyncRejectedPromise = /*#__PURE__*/_createRejectedPromise(createAsyncPromise);\nfunction createAsyncAllSettledPromise(input, timeout) {\n  !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));\n  return _allAsyncSettledCreator.v(input, timeout);\n}\nfunction createAsyncRacePromise(values, timeout) {\n  !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));\n  return _raceAsyncCreator.v(values, timeout);\n}\nfunction createAsyncAnyPromise(values, timeout) {\n  !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));\n  return _anyAsyncCreator.v(values, timeout);\n}\nvar _promiseCls;\nvar _allCreator;\nvar _allNativeSettledCreator;\nvar _raceNativeCreator;\nvar _anyNativeCreator;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createNativePromiseHelper(name, func) {\n  !_promiseCls && (_promiseCls = createCachedValue(safe(getInst, [STR_PROMISE]).v || null));\n  if (_promiseCls.v && _promiseCls.v[name]) {\n    return createCachedValue(function (input, timeout) {\n      return createNativePromise(function (resolve, reject) {\n        _promiseCls.v[name](input).then(resolve, reject);\n      });\n    });\n  }\n  return func();\n}\nfunction createNativePromise(executor, timeout) {\n  !_promiseCls && (_promiseCls = createCachedValue(safe(getInst, [STR_PROMISE]).v || null));\n  var PrmCls = _promiseCls.v;\n  if (!PrmCls) {\n    return createAsyncPromise(executor);\n  }\n  if (!isFunction(executor)) {\n    throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpObj(executor));\n  }\n  var _state = 0;\n  function _strState() {\n    return STRING_STATES[_state];\n  }\n  var thePromise = new PrmCls(function (resolve, reject) {\n    function _resolve(value) {\n      _state = 2;\n      resolve(value);\n    }\n    function _reject(reason) {\n      _state = 3;\n      reject(reason);\n    }\n    executor(_resolve, _reject);\n  });\n  objDefineProp(thePromise, \"state\", {\n    get: _strState\n  });\n  return thePromise;\n}\nfunction createNativeAllPromise(input, timeout) {\n  !_allCreator && (_allCreator = _createNativePromiseHelper(\"all\", function () {\n    return createCachedValue(_createAllPromise(createNativePromise));\n  }));\n  return _allCreator.v(input, timeout);\n}\nvar createNativeResolvedPromise = /*#__PURE__*/_createResolvedPromise(createNativePromise);\nvar createNativeRejectedPromise = /*#__PURE__*/_createRejectedPromise(createNativePromise);\nfunction createNativeAllSettledPromise(input, timeout) {\n  !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper(\"allSettled\", function () {\n    return _createAllSettledPromise(createNativePromise);\n  }));\n  return _allNativeSettledCreator.v(input, timeout);\n}\nfunction createNativeRacePromise(values, timeout) {\n  !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper(\"race\", function () {\n    return _createRacePromise(createNativePromise);\n  }));\n  return _raceNativeCreator.v(values, timeout);\n}\nfunction createNativeAnyPromise(values, timeout) {\n  !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper(\"any\", function () {\n    return _createAnyPromise(createNativePromise);\n  }));\n  return _anyNativeCreator.v(values, timeout);\n}\nvar _allSyncSettledCreator;\nvar _raceSyncCreator;\nvar _anySyncCreator;\nfunction createSyncPromise(executor) {\n  return _createPromise(createSyncPromise, syncItemProcessor, executor);\n}\nvar createSyncAllPromise = /*#__PURE__*/_createAllPromise(createSyncPromise);\nvar createSyncResolvedPromise = /*#__PURE__*/_createResolvedPromise(createSyncPromise);\nvar createSyncRejectedPromise = /*#__PURE__*/_createRejectedPromise(createSyncPromise);\nfunction createSyncAllSettledPromise(input, timeout) {\n  !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));\n  return _allSyncSettledCreator.v(input, timeout);\n}\nfunction createSyncRacePromise(values, timeout) {\n  !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));\n  return _raceSyncCreator.v(values, timeout);\n}\nfunction createSyncAnyPromise(values, timeout) {\n  !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));\n  return _anySyncCreator.v(values, timeout);\n}\nvar _defaultIdleTimeout;\nvar _allIdleSettledCreator;\nvar _raceIdleCreator;\nvar _anyIdleCreator;\nfunction setDefaultIdlePromiseTimeout(idleDeadline) {\n  _defaultIdleTimeout = idleDeadline;\n}\nvar setDefaultIdleTimeout = setDefaultIdlePromiseTimeout;\nfunction createIdlePromise(executor, timeout) {\n  var theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;\n  return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);\n}\nvar createIdleAllPromise = /*#__PURE__*/_createAllPromise(createIdlePromise);\nvar createIdleResolvedPromise = /*#__PURE__*/_createResolvedPromise(createIdlePromise);\nvar createIdleRejectedPromise = /*#__PURE__*/_createRejectedPromise(createIdlePromise);\nfunction createIdleAllSettledPromise(input, timeout) {\n  !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));\n  return _allIdleSettledCreator.v(input, timeout);\n}\nfunction createIdleRacePromise(values, timeout) {\n  !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));\n  return _raceIdleCreator.v(values, timeout);\n}\nfunction createIdleAnyPromise(values, timeout) {\n  !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));\n  return _anyIdleCreator.v(values, timeout);\n}\nvar _promiseCreator;\nvar _allSettledCreator;\nvar _raceCreator;\nvar _anyCreator;\nfunction setCreatePromiseImpl(creator) {\n  _promiseCreator = creator ? createCachedValue(creator) : null;\n}\nfunction createPromise(executor, timeout) {\n  !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));\n  return _promiseCreator.v.call(this, executor, timeout);\n}\nvar createAllPromise = /*#__PURE__*/_createAllPromise(createPromise);\nvar createResolvedPromise = /*#__PURE__*/_createResolvedPromise(createPromise);\nvar createRejectedPromise = /*#__PURE__*/_createRejectedPromise(createPromise);\nfunction createAllSettledPromise(input, timeout) {\n  !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));\n  return _allSettledCreator.v(input, timeout);\n}\nfunction createRacePromise(values, timeout) {\n  !_raceCreator && (_raceCreator = _createRacePromise(createPromise));\n  return _raceCreator.v(values, timeout);\n}\nfunction createAnyPromise(values, timeout) {\n  !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));\n  return _anyCreator.v(values, timeout);\n}\nfunction createTimeoutPromise(timeout, resolveReject, message) {\n  return createPromise(function (resolve, reject) {\n    scheduleTimeout(function () {\n      (resolveReject ? resolve : reject)(!isUndefined(message) ? message : \"Timeout of \" + timeout + \"ms exceeded\");\n    }, timeout);\n  });\n}\nfunction _doneChk(isDone, state, value, thisArg) {\n  var result = isDone;\n  state.res = value;\n  if (!result) {\n    if (state.isDone && isFunction(state.isDone)) {\n      return doAwait(state.isDone.call(thisArg, state), function (done) {\n        state.iter++;\n        return !!done;\n      });\n    } else {\n      result = !!state.isDone;\n    }\n  }\n  state.iter++;\n  return result;\n}\nfunction doWhileAsync(callbackFn, isDoneFn, thisArg) {\n  var promise;\n  var resolve;\n  var reject = function (reason) {\n    isDone = true;\n    throw reason;\n  };\n  var isDone = false;\n  var state = {\n    st: utcNow(),\n    iter: 0,\n    isDone: isDoneFn || false\n  };\n  if (callbackFn) {\n    var _createPromise_1 = function () {\n      return createPromise(function (res, rej) {\n        resolve = res;\n        reject = rej;\n      });\n    };\n    var _handleAsyncDone_1 = function (done) {\n      isDone = !!done;\n      if (!isDone) {\n        _processNext_1();\n      } else {\n        resolve(state.res);\n      }\n    };\n    var _processNext_1 = function () {\n      while (!isDone) {\n        try {\n          var cbResult = callbackFn.call(thisArg, state);\n          if (isPromiseLike(cbResult)) {\n            promise = promise || _createPromise_1();\n            doAwait(cbResult, function (res) {\n              try {\n                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone_1, reject);\n              } catch (e) {\n                reject(e);\n              }\n            }, reject);\n            return promise;\n          } else {\n            var dnRes = _doneChk(isDone, state, cbResult, thisArg);\n            if (isPromiseLike(dnRes)) {\n              promise = promise || _createPromise_1();\n              doAwait(dnRes, _handleAsyncDone_1, reject);\n              return promise;\n            } else {\n              isDone = !!dnRes;\n            }\n          }\n        } catch (e) {\n          reject(e);\n          return promise;\n        }\n      }\n      if (isDone && resolve) {\n        resolve(state.res);\n      }\n      return promise || state.res;\n    };\n    return _processNext_1();\n  }\n}\nfunction arrForEachAsync(theArray, callbackFn, thisArg) {\n  if (theArray) {\n    var len_1 = getLength(theArray);\n    if (len_1) {\n      var isDone = function (state) {\n        if (state.iter >= len_1 || state.res === -1) {\n          return true;\n        }\n      };\n      return doWhileAsync(function (state) {\n        var idx = state.iter;\n        if (idx in theArray) {\n          return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);\n        }\n      }, isDone);\n    }\n  }\n}\nvar _iterSymbol;\nvar _iterAsyncSymbol;\nfunction iterForOfAsync(iter, callbackFn, thisArg) {\n  var err;\n  var iterResult;\n  var theIter = iter;\n  function onFailed(failed) {\n    err = {\n      e: failed\n    };\n    if (theIter.throw) {\n      iterResult = null;\n      theIter.throw(err);\n    }\n    throw failed;\n  }\n  function onFinally() {\n    try {\n      if (iterResult && !iterResult[DONE]) {\n        theIter[RETURN] && theIter[RETURN](iterResult);\n      }\n    } finally {\n      if (err) {\n        throw err.e;\n      }\n    }\n  }\n  if (iter) {\n    if (!isIterator(iter)) {\n      !_iterAsyncSymbol && (_iterAsyncSymbol = createCachedValue(getKnownSymbol(0)));\n      theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;\n      if (!theIter) {\n        !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(3)));\n        theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\n      }\n    }\n    if (theIter && isIterator(theIter)) {\n      var result = void 0;\n      try {\n        result = doWhileAsync(function (state) {\n          return doAwait(theIter.next(), function (res) {\n            iterResult = res;\n            if (!res[DONE]) {\n              return fnCall(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);\n            }\n          }, function (reason) {\n            state.isDone = true;\n            onFailed(reason);\n          });\n        }, function (state) {\n          if (!iterResult || iterResult[DONE] || state.res === -1) {\n            onFinally();\n            return true;\n          }\n        }, thisArg || theIter);\n        if (isPromiseLike(result)) {\n          result = doFinally(result.catch(onFailed), onFinally);\n        }\n        return result;\n      } catch (failed) {\n        onFailed(failed);\n      } finally {\n        if (result && !isPromiseLike(result)) {\n          onFinally();\n        }\n      }\n    }\n  }\n}\nvar REJECT = \"reject\";\nvar REJECTED_ERROR = \"Rejected\";\nvar _schedulerId = 0;\nvar _debugName;\nvar _debugIntState;\nvar _customErrors = {};\nfunction _rejectDone() {}\nfunction _createError(type, evt, message) {\n  !_customErrors[type] && (_customErrors[type] = createCustomError(type));\n  var now = utcNow();\n  return new _customErrors[type](\"Task [\".concat(evt.id, \"] \").concat(message || \"\", \"- \").concat(evt.st ? \"Running\" : \"Waiting\", \": \").concat(_calcTime(now, evt.st || evt.cr)));\n}\nfunction _calcTime(now, start) {\n  return (now - start || \"0\") + \" ms\";\n}\nfunction _abortStaleTasks(taskQueue, staleTimeoutPeriod) {\n  var now = utcNow();\n  var expired = now - staleTimeoutPeriod;\n  arrForEach(taskQueue, function (evt) {\n    if (evt && !evt.rj && evt.st && evt.st < expired || !evt.st && evt.cr && evt.cr < expired) {\n      evt && evt[REJECT](evt.rj || _createError(\"Aborted\", evt, \"Stale \"));\n    }\n  });\n}\nfunction _removeTask(queue, taskDetail) {\n  var idx = arrIndexOf(queue, taskDetail);\n  if (idx !== -1) {\n    queue.splice(idx, 1);\n  }\n}\nfunction _addDebugState(theScheduler, nameFn, stateFn) {\n  _debugName = _debugName || {\n    toString: function () {\n      return \"[[SchedulerName]]\";\n    }\n  };\n  _debugIntState = _debugIntState || {\n    toString: function () {\n      return \"[[SchedulerState]]\";\n    }\n  };\n  objDefineProp(theScheduler, _debugName, {\n    get: nameFn\n  });\n  objDefineProp(theScheduler, _debugIntState, {\n    get: stateFn\n  });\n}\nfunction createTaskScheduler(newPromise, name) {\n  var _theTask;\n  var _running = [];\n  var _waiting = [];\n  var _staleTimeoutPeriod = 600000;\n  var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;\n  var _taskCount = 0;\n  var _schedulerName = (name ? name + \".\" : \"\") + _schedulerId++;\n  var _blockedTimer;\n  newPromise = newPromise || createPromise;\n  var _startBlockedTimer = function () {\n    var hasTasks = getLength(_running) + getLength(_waiting) > 0;\n    if (_staleTimeoutPeriod > 0) {\n      if (!_blockedTimer) {\n        _blockedTimer = scheduleTimeout(function () {\n          _abortStaleTasks(_running, _staleTimeoutPeriod);\n          _abortStaleTasks(_waiting, _staleTimeoutPeriod);\n          _blockedTimer && (_blockedTimer.enabled = getLength(_running) + getLength(_waiting) > 0);\n        }, _staleTimeoutCheckPeriod);\n        _blockedTimer.unref();\n      }\n      _blockedTimer && (_blockedTimer.enabled = hasTasks);\n    }\n  };\n  var _queueTask = function (startAction, taskName, timeout) {\n    var _a;\n    var taskId = _schedulerName + \".\" + _taskCount++;\n    if (taskName) {\n      taskId += \"-(\" + taskName + \")\";\n    }\n    var newTask = (_a = {\n      id: taskId,\n      cr: utcNow(),\n      to: timeout\n    }, _a[REJECT] = function (reason) {\n      newTask.rj = reason || _createError(REJECTED_ERROR, newTask);\n      newTask[REJECT] = _rejectDone;\n    }, _a);\n    if (!_theTask) {\n      newTask.p = newPromise(_runTask(newTask, startAction));\n    } else {\n      newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);\n    }\n    _theTask = newTask;\n    return newTask.p;\n  };\n  var _runTask = function (taskDetail, startAction) {\n    taskDetail.st = utcNow();\n    _running.push(taskDetail);\n    _startBlockedTimer();\n    return function (onTaskResolve, onTaskReject) {\n      var _promiseReject = function (reason) {\n        taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);\n        taskDetail[REJECT] = _rejectDone;\n        _doCleanup(taskDetail);\n        onTaskResolve = null;\n        onTaskReject && onTaskReject(reason);\n        onTaskReject = null;\n      };\n      var taskId = taskDetail.id;\n      if (taskDetail.rj) {\n        _promiseReject(taskDetail.rj);\n      } else {\n        taskDetail[REJECT] = _promiseReject;\n        try {\n          var startResult = startAction(taskId);\n          if (taskDetail.to && isPromiseLike(startResult)) {\n            taskDetail.t = scheduleTimeout(function () {\n              _promiseReject(_createError(\"Timeout\", taskDetail));\n            }, taskDetail.to);\n          }\n          doAwait(startResult, function (theResult) {\n            _doCleanup(taskDetail);\n            try {\n              onTaskResolve && onTaskResolve(theResult);\n            } catch (e) {\n              onTaskReject && onTaskReject(e);\n            }\n            onTaskReject = null;\n            onTaskResolve = null;\n          }, _promiseReject);\n        } catch (e) {\n          _promiseReject(e);\n        }\n      }\n    };\n  };\n  var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {\n    _waiting.push(taskDetail);\n    _startBlockedTimer();\n    return newPromise(function (onWaitResolve, onWaitReject) {\n      doAwaitResponse(prevTask.p, function () {\n        _removeTask(_waiting, taskDetail);\n        _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);\n      });\n    });\n  };\n  var _doCleanup = function (taskDetail) {\n    _removeTask(_running, taskDetail);\n    taskDetail.t && taskDetail.t.cancel();\n    taskDetail.t = null;\n    if (_theTask && _theTask === taskDetail) {\n      _theTask = null;\n      if (getLength(_running) + getLength(_waiting) === 0) {\n        _blockedTimer && _blockedTimer.cancel();\n        _blockedTimer = null;\n      }\n    }\n  };\n  var theScheduler = {\n    idle: true,\n    queue: _queueTask,\n    setStaleTimeout: function (staleTimeout, staleCheckPeriod) {\n      _blockedTimer && _blockedTimer.cancel();\n      _blockedTimer = null;\n      _staleTimeoutPeriod = staleTimeout;\n      _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;\n      _startBlockedTimer();\n    }\n  };\n  objDefine(theScheduler, \"idle\", {\n    g: function () {\n      return getLength(_running) + getLength(_waiting) === 0;\n    }\n  });\n  _addDebugState(theScheduler, function () {\n    return _schedulerName;\n  }, function () {\n    return {\n      l: _theTask,\n      r: _running,\n      w: _waiting\n    };\n  });\n  return theScheduler;\n}\nvar toStringTagSymbol = getKnownSymbol(11);\nvar PolyPromise = /*#__PURE__*/function () {\n  function PolyPromiseImpl(executor) {\n    this._$ = createAsyncPromise(executor);\n    if (toStringTagSymbol) {\n      this[toStringTagSymbol] = \"Promise\";\n    }\n    objDefineProp(this, \"state\", {\n      get: function () {\n        return this._$.state;\n      }\n    });\n  }\n  PolyPromiseImpl.all = createAsyncAllPromise;\n  PolyPromiseImpl.race = createAsyncRacePromise;\n  PolyPromiseImpl.any = createAsyncAnyPromise;\n  PolyPromiseImpl.reject = createAsyncRejectedPromise;\n  PolyPromiseImpl.resolve = createAsyncResolvedPromise;\n  PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\n  var theProto = PolyPromiseImpl.prototype;\n  theProto.then = function (onResolved, onRejected) {\n    return this._$.then(onResolved, onRejected);\n  };\n  theProto.catch = function (onRejected) {\n    return this._$.catch(onRejected);\n  };\n  theProto.finally = function (onfinally) {\n    return this._$.finally(onfinally);\n  };\n  return PolyPromiseImpl;\n}();\nexport { PolyPromise, arrForEachAsync, createAllPromise, createAllSettledPromise, createAnyPromise, createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncAnyPromise, createAsyncPromise, createAsyncRacePromise, createAsyncRejectedPromise, createAsyncResolvedPromise, createIdleAllPromise, createIdleAllSettledPromise, createIdleAnyPromise, createIdlePromise, createIdleRacePromise, createIdleRejectedPromise, createIdleResolvedPromise, createNativeAllPromise, createNativeAllSettledPromise, createNativeAnyPromise, createNativePromise, createNativeRacePromise, createNativeRejectedPromise, createNativeResolvedPromise, createPromise, createRacePromise, createRejectedPromise, createResolvedPromise, createSyncAllPromise, createSyncAllSettledPromise, createSyncAnyPromise, createSyncPromise, createSyncRacePromise, createSyncRejectedPromise, createSyncResolvedPromise, createTaskScheduler, createTimeoutPromise, doAwait, doAwaitResponse, doFinally, doWhileAsync, iterForOfAsync, setCreatePromiseImpl, setDefaultIdlePromiseTimeout, setDefaultIdleTimeout, setPromiseDebugState };","map":{"version":3,"names":["STR_PROMISE","DONE","VALUE","RETURN","REJECTED","doAwaitResponse","value","cb","doAwait","status","rejected","reason","resolveFn","rejectFn","finallyFn","result","isPromiseLike","then","err","doFinally","finally","_debugState","_debugResult","_debugHandled","_promiseDebugEnabled","_addDebugState$1","_addDebugState","thePromise","stateFn","resultFn","handledFn","toString","props","get","objDefineProperties","setPromiseDebugState","enabled","logger","STRING_STATES","DISPATCH_EVENT","_hasInitEvent","_hasInitEventFn","doc","evt","createEvent","initEvent","emitEvent","target","evtName","populateEvent","useNewEvent","getDocument","createCachedValue","safe","v","theEvt","Event","handler","theConsole","getInst","dumpObj","NODE_UNHANDLED_REJECTION","UNHANDLED_REJECTION","toLowerCase","_currentPromiseId","_uniquePromiseId","_unhandledRejectionTimeout","_aggregationError","_hasPromiseRejectionEvent","dumpFnObj","isFunction","_createAggregationError","values","createCustomError","self","args","errors","_createPromise","newPromise","processor","executor","additionalArgs","arrSlice","arguments","_state","_hasResolved","_settledValue","_queue","_id","_parentId","length","undefined","_handled","_unHandledRejectionHandler","_thePromise","_then","onResolved","onRejected","push","cancel","thenPromise","resolve","reject","isUndefined","e","_processQueue","pop","_catch","_finally","onFinally","thenFinally","catchFinally","_strState","pending","slice","_createSettleIfFn","newState","allowState","theValue","scheduleTimeout","_notifyUnhandledRejection","isNode","process","emit","gbl","getWindow","getGlobal","objDefine","g","objDefineProp","objToString","hasSymbol","getKnownSymbol","_toString","_initialize","throwTypeError","_rejectFn","call","_createAllPromise","input","values_1","pending_1","iterForOf","item","idx","_createResolvedPromise","_createRejectedPromise","_resolve","_createAllSettledPromise","processItem","isArray","arrForEach","isIterable","_createRacePromise","isDone","_createAnyPromise","theErros","syncItemProcessor","fn","timeoutItemProcessor","timeout","callbackTimeout","isNumber","idleItemProcessor","options","scheduleIdleCallback","deadline","_allAsyncSettledCreator","_raceAsyncCreator","_anyAsyncCreator","createAsyncPromise","createAsyncAllPromise","createAsyncResolvedPromise","createAsyncRejectedPromise","createAsyncAllSettledPromise","createAsyncRacePromise","createAsyncAnyPromise","_promiseCls","_allCreator","_allNativeSettledCreator","_raceNativeCreator","_anyNativeCreator","_createNativePromiseHelper","name","func","createNativePromise","PrmCls","_reject","createNativeAllPromise","createNativeResolvedPromise","createNativeRejectedPromise","createNativeAllSettledPromise","createNativeRacePromise","createNativeAnyPromise","_allSyncSettledCreator","_raceSyncCreator","_anySyncCreator","createSyncPromise","createSyncAllPromise","createSyncResolvedPromise","createSyncRejectedPromise","createSyncAllSettledPromise","createSyncRacePromise","createSyncAnyPromise","_defaultIdleTimeout","_allIdleSettledCreator","_raceIdleCreator","_anyIdleCreator","setDefaultIdlePromiseTimeout","idleDeadline","setDefaultIdleTimeout","createIdlePromise","theTimeout","createIdleAllPromise","createIdleResolvedPromise","createIdleRejectedPromise","createIdleAllSettledPromise","createIdleRacePromise","createIdleAnyPromise","_promiseCreator","_allSettledCreator","_raceCreator","_anyCreator","setCreatePromiseImpl","creator","createPromise","createAllPromise","createResolvedPromise","createRejectedPromise","createAllSettledPromise","createRacePromise","createAnyPromise","createTimeoutPromise","resolveReject","message","_doneChk","state","thisArg","res","done","iter","doWhileAsync","callbackFn","isDoneFn","promise","st","utcNow","_createPromise_1","rej","_handleAsyncDone_1","_processNext_1","cbResult","dnRes","arrForEachAsync","theArray","len_1","getLength","_iterSymbol","_iterAsyncSymbol","iterForOfAsync","iterResult","theIter","onFailed","failed","throw","isIterator","next","fnCall","catch","REJECT","REJECTED_ERROR","_schedulerId","_debugName","_debugIntState","_customErrors","_rejectDone","_createError","type","now","concat","id","_calcTime","cr","start","_abortStaleTasks","taskQueue","staleTimeoutPeriod","expired","rj","_removeTask","queue","taskDetail","arrIndexOf","splice","theScheduler","nameFn","createTaskScheduler","_theTask","_running","_waiting","_staleTimeoutPeriod","_staleTimeoutCheckPeriod","_taskCount","_schedulerName","_blockedTimer","_startBlockedTimer","hasTasks","unref","_queueTask","startAction","taskName","_a","taskId","newTask","to","p","_runTask","_waitForPreviousTask","onTaskResolve","onTaskReject","_promiseReject","_doCleanup","startResult","t","theResult","prevTask","onWaitResolve","onWaitReject","idle","setStaleTimeout","staleTimeout","staleCheckPeriod","l","r","w","toStringTagSymbol","PolyPromise","PolyPromiseImpl","_$","all","race","any","allSettled","theProto","prototype","onfinally"],"sources":["/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/internal/constants.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/await.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/debug.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/internal/state.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/event.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/base.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/itemProcessor.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/asyncPromise.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/nativePromise.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/syncPromise.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/idlePromise.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/promise.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/promise/timeoutPromise.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/helpers/doWhileAsync.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/helpers/arrForEachAsync.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/helpers/iterForOfAsync.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/scheduler/taskScheduler.js","/home/veeresh133/app/api-call/react-az/node_modules/@nevware21/ts-async/build/es5/mod/polyfills/promise.js"],"sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nexport var STR_PROMISE = \"Promise\";\r\nexport var DONE = \"done\";\r\nexport var VALUE = \"value\";\r\nexport var ITERATOR = \"iterator\";\r\nexport var RETURN = \"return\";\r\nexport var REJECTED = \"rejected\";\r\n//# sourceMappingURL=constants.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { REJECTED } from \"../internal/constants\";\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait to be resolved or rejected.\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse(value, cb) {\r\n    return doAwait(value, function (value) {\r\n        return cb ? cb({\r\n            status: \"fulfilled\",\r\n            rejected: false,\r\n            value: value\r\n        }) : value;\r\n    }, function (reason) {\r\n        return cb ? cb({\r\n            status: REJECTED,\r\n            rejected: true,\r\n            reason: reason\r\n        }) : reason;\r\n    });\r\n}\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait(value, resolveFn, rejectFn, finallyFn) {\r\n    var result = value;\r\n    try {\r\n        if (isPromiseLike(value)) {\r\n            if (resolveFn || rejectFn) {\r\n                result = value.then(resolveFn, rejectFn);\r\n            }\r\n        }\r\n        else {\r\n            try {\r\n                if (resolveFn) {\r\n                    result = resolveFn(value);\r\n                }\r\n            }\r\n            catch (err) {\r\n                if (rejectFn) {\r\n                    result = rejectFn(err);\r\n                }\r\n                else {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        if (finallyFn) {\r\n            doFinally(result, finallyFn);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally(value, finallyFn) {\r\n    var result = value;\r\n    if (finallyFn) {\r\n        if (isPromiseLike(value)) {\r\n            if (value.finally) {\r\n                result = value.finally(finallyFn);\r\n            }\r\n            else {\r\n                // Simulate finally if not available\r\n                result = value.then(function (value) {\r\n                    finallyFn();\r\n                    return value;\r\n                }, function (reason) {\r\n                    finallyFn();\r\n                    throw reason;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            finallyFn();\r\n        }\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=await.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { objDefineProperties } from \"@nevware21/ts-utils\";\r\nvar _debugState;\r\nvar _debugResult;\r\nvar _debugHandled;\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nexport var _promiseDebugEnabled = false;\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) let _theLogger: (id: string, message: string) => void = null;\r\n//#endif\r\n/**\r\n * @internal\r\n * @ignore Internal function enable logging the internal state of the promise during execution, this code and references are\r\n * removed from the production artifacts\r\n */\r\nexport var _debugLog = /*#__PURE__*/ function (id, message) {\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) if (_theLogger) {\r\n    //#:(!DEBUG)     _theLogger(id, message);\r\n    //#:(!DEBUG) }\r\n    //#endif\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function to add the debug state to the promise so that it provides simular visibility as you would\r\n * see from native promises\r\n * @param thePromise - The Promise implementation\r\n * @param stateFn - The function to return the state of the promise\r\n * @param resultFn - The function to return the result (settled value) of the promise\r\n * @param handledFn - The function to return whether the promise has been handled (used for throwing\r\n * unhandled rejection events)\r\n */\r\nexport function _addDebugState(thePromise, stateFn, resultFn, handledFn) {\r\n    // While the IPromise implementations provide a `state` property, keeping the `[[PromiseState]]`\r\n    // as native promises also have a non-enumerable property of the same name\r\n    _debugState = _debugState || { toString: function () { return \"[[PromiseState]]\"; } };\r\n    _debugResult = _debugResult || { toString: function () { return \"[[PromiseResult]]\"; } };\r\n    _debugHandled = _debugHandled || { toString: function () { return \"[[PromiseIsHandled]]\"; } };\r\n    var props = {};\r\n    props[_debugState] = { get: stateFn };\r\n    props[_debugResult] = { get: resultFn };\r\n    props[_debugHandled] = { get: handledFn };\r\n    objDefineProperties(thePromise, props);\r\n}\r\n/**\r\n * Debug helper to enable internal debugging of the promise implementations. Disabled by default.\r\n * For the generated packages included in the npm package the `logger` will not be called as the\r\n * `_debugLog` function that uses this logger is removed during packaging.\r\n *\r\n * It is available directly from the repository for unit testing.\r\n *\r\n * @group Debug\r\n * @param enabled - Should debugging be enabled (defaults `false`, when `true` promises will have\r\n * additional debug properties and the `toString` will include extra details.\r\n * @param logger - Optional logger that will log internal state changes, only called in debug\r\n * builds as the calling function is removed is the production artifacts.\r\n * @example\r\n * ```ts\r\n * // The Id is the id of the promise\r\n * // The message is the internal debug message\r\n * function promiseDebugLogger(id: string, message: string) {\r\n *     if (console && console.log) {\r\n *         console.log(id, message);\r\n *     }\r\n * }\r\n *\r\n * setPromiseDebugState(true, promiseDebugLogger);\r\n *\r\n * // While the logger will not be called for the production packages\r\n * // Setting the `enabled` flag to tru will cause each promise to have\r\n * // the following additional properties added\r\n * // [[PromiseState]]; => Same as the `state` property\r\n * // [[PromiseResult]]; => The settled value\r\n * // [[PromiseIsHandled]] => Identifies if the promise has been handled\r\n * // It will also cause the `toString` for the promise to include additional\r\n * // debugging information\r\n * ```\r\n */\r\nexport function setPromiseDebugState(enabled, logger) {\r\n    _promiseDebugEnabled = enabled;\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _theLogger = logger;\r\n    //#endif\r\n}\r\n//# sourceMappingURL=debug.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { REJECTED } from \"./constants\";\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport var STRING_STATES = /*#__PURE__*/ [\r\n    \"pending\", \"resolving\", \"resolved\", REJECTED\r\n];\r\n//# sourceMappingURL=state.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { dumpObj, getDocument, getInst, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nvar DISPATCH_EVENT = \"dispatchEvent\";\r\nvar _hasInitEvent;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function to determine if the document has the `initEvent` function\r\n * @param doc - The document to check\r\n * @returns\r\n */\r\nfunction _hasInitEventFn(doc) {\r\n    var evt;\r\n    if (doc && doc.createEvent) {\r\n        evt = doc.createEvent(\"Event\");\r\n    }\r\n    return (!!evt && evt.initEvent);\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param target\r\n * @param evtName\r\n * @param populateEvent\r\n * @param useNewEvent\r\n */\r\nexport function emitEvent(target, evtName, populateEvent, useNewEvent) {\r\n    var doc = getDocument();\r\n    !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [doc]).v));\r\n    var theEvt = _hasInitEvent.v ? doc.createEvent(\"Event\") : (useNewEvent ? new Event(evtName) : {});\r\n    populateEvent && populateEvent(theEvt);\r\n    if (_hasInitEvent.v) {\r\n        theEvt.initEvent(evtName, false, true);\r\n    }\r\n    if (theEvt && target[DISPATCH_EVENT]) {\r\n        target[DISPATCH_EVENT](theEvt);\r\n    }\r\n    else {\r\n        var handler = target[\"on\" + evtName];\r\n        if (handler) {\r\n            handler(theEvt);\r\n        }\r\n        else {\r\n            var theConsole = getInst(\"console\");\r\n            theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, dumpObj(theEvt));\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=event.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined, throwTypeError, objToString, scheduleTimeout, getWindow, isNode, getGlobal, objDefine, objDefineProp, iterForOf, isIterable, isArray, arrForEach, createCachedValue, safe, getInst, createCustomError } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"./await\";\r\nimport { _addDebugState, _promiseDebugEnabled } from \"./debug\";\r\nimport { STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { REJECTED, STR_PROMISE } from \"../internal/constants\";\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"./debug\";\r\n//#endif\r\nvar NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nvar UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\nvar _currentPromiseId = [];\r\nvar _uniquePromiseId = 0;\r\nvar _unhandledRejectionTimeout = 10;\r\nvar _aggregationError;\r\nvar _hasPromiseRejectionEvent;\r\nfunction dumpFnObj(value) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n    return dumpObj(value);\r\n}\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) function _getCaller(prefix: string, start: number) {\r\n//#:(!DEBUG)     let stack = new Error().stack;\r\n//#:(!DEBUG)     if (stack) {\r\n//#:(!DEBUG)         let lines = stack.split(\"\\n\");\r\n//#:(!DEBUG)         if (lines.length > start) {\r\n//#:(!DEBUG)             return prefix + \":\" + arrSlice(lines, start, start + 5).join(\"\\n\") + \"\\n...\";\r\n//#:(!DEBUG)         }\r\n//#:(!DEBUG)     }\r\n//#:(!DEBUG)     return null;\r\n//#:(!DEBUG) }\r\n//#endif\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createAggregationError(values) {\r\n    !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, [\"AggregationError\"]).v || createCustomError(\"AggregationError\", function (self, args) {\r\n        self.errors = args[0];\r\n    })));\r\n    return new _aggregationError.v(values);\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise(newPromise, processor, executor) {\r\n    var additionalArgs = arrSlice(arguments, 3);\r\n    var _state = 0 /* ePromiseState.Pending */;\r\n    var _hasResolved = false;\r\n    var _settledValue;\r\n    var _queue = [];\r\n    var _id = _uniquePromiseId++;\r\n    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    var _handled = false;\r\n    var _unHandledRejectionHandler = null;\r\n    var _thePromise;\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    function _then(onResolved, onRejected) {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            var thenPromise = newPromise(function (resolve, reject) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _getCaller(\"_then\", 7));\r\n                //#endif\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        var handler = _state === 2 /* ePromiseState.Resolved */ ? onResolved : onRejected;\r\n                        var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve, reject);\r\n                        }\r\n                        else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value);\r\n                        }\r\n                        else if (_state === 3 /* ePromiseState.Rejected */) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        }\r\n                        else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n            return thenPromise;\r\n        }\r\n        finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    }\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    function _catch(onRejected) {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    }\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    function _finally(onFinally) {\r\n        var thenFinally = onFinally;\r\n        var catchFinally = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function (value) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            };\r\n            catchFinally = function (reason) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            };\r\n        }\r\n        return _then(thenFinally, catchFinally);\r\n    }\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n    function _processQueue() {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            var pending = _queue.slice();\r\n            _queue = [];\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n        }\r\n        else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    }\r\n    function _createSettleIfFn(newState, allowState) {\r\n        return function (theValue) {\r\n            if (_state === allowState) {\r\n                if (newState === 2 /* ePromiseState.Resolved */ && isPromiseLike(theValue)) {\r\n                    _state = 1 /* ePromiseState.Resolving */;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(_createSettleIfFn(2 /* ePromiseState.Resolved */, 1 /* ePromiseState.Resolving */), _createSettleIfFn(3 /* ePromiseState.Rejected */, 1 /* ePromiseState.Resolving */));\r\n                    return;\r\n                }\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === 3 /* ePromiseState.Rejected */ && !_unHandledRejectionHandler) {\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Setting up unhandled rejection\");\r\n                    //#endif\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);\r\n                }\r\n            }\r\n            else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    }\r\n    function _notifyUnhandledRejection() {\r\n        if (!_handled) {\r\n            // Mark as handled so we don't keep notifying\r\n            _handled = true;\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            }\r\n            else {\r\n                var gbl = getWindow() || getGlobal();\r\n                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe((getInst), [STR_PROMISE + \"RejectionEvent\"]).v));\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {\r\n                    objDefine(theEvt, \"promise\", { g: function () { return _thePromise; } });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    }\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    };\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, function () { return objToString(_settledValue); }, function () { return _handled; });\r\n    }\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol(11 /* WellKnownSymbols.toStringTag */)] = \"IPromise\";\r\n    }\r\n    var createStack;\r\n    //#if DEBUG\r\n    //#:(!{DEBUG}) createStack = _getCaller(\"Created\", 5);\r\n    //#endif\r\n    function _toString() {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\") + (createStack ? \" @ \" + createStack : \"\");\r\n    }\r\n    _thePromise.toString = _toString;\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n        var _rejectFn = _createSettleIfFn(3 /* ePromiseState.Rejected */, 0 /* ePromiseState.Pending */);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(_thePromise, _createSettleIfFn(2 /* ePromiseState.Resolved */, 0 /* ePromiseState.Pending */), _rejectFn);\r\n        }\r\n        catch (e) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Exception thrown: \" + dumpFnObj(e));\r\n            //#endif\r\n            _rejectFn(e);\r\n        }\r\n        //#ifdef DEBUG\r\n        //#:(!DEBUG) _debugLog(_toString(), \"~Executing\");\r\n        //#endif\r\n    })();\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllPromise(newPromise) {\r\n    return function (input) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            try {\r\n                var values_1 = [];\r\n                var pending_1 = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n                iterForOf(input, function (item, idx) {\r\n                    if (item) {\r\n                        pending_1++;\r\n                        doAwait(item, function (value) {\r\n                            // Set the result values\r\n                            values_1[idx] = value;\r\n                            if (--pending_1 === 0) {\r\n                                resolve(values_1);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n                // Now decrement the pending so that we finish correctly\r\n                pending_1--;\r\n                if (pending_1 === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values_1);\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createResolvedPromise(newPromise) {\r\n    return function (value) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike(value)) {\r\n            return value;\r\n        }\r\n        return newPromise(function (resolve) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Resolving Promise\");\r\n            //#endif\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRejectedPromise(newPromise) {\r\n    return function (reason) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (_resolve, reject) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Rejecting Promise\");\r\n            //#endif\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function which when called will return a new Promise object that resolves to an array of\r\n * IPromiseResults from the input promises. The returned promise will resolve when all of the inputs'\r\n * promises have resolved or rejected, or if the input contains no promises. It will resolve only after\r\n * all input promises have been fulfilled (resolve or rejected).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllSettledPromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var values = [];\r\n            var pending = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n            function processItem(item, idx) {\r\n                pending++;\r\n                doAwaitResponse(item, function (value) {\r\n                    if (value.rejected) {\r\n                        values[idx] = {\r\n                            status: REJECTED,\r\n                            reason: value.reason\r\n                        };\r\n                    }\r\n                    else {\r\n                        values[idx] = {\r\n                            status: \"fulfilled\",\r\n                            value: value.value\r\n                        };\r\n                    }\r\n                    if (--pending === 0) {\r\n                        resolve(values);\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise settles with the eventual state of the first promise that settles.\r\n * @description The returned promise is one of the promise concurrency methods. It's useful when you want\r\n * the first async task to complete, but do not care about its eventual state (i.e. it can either succeed\r\n * or fail).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the first promise to settle is fulfilled,\r\n * and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises,\r\n * the returned promise is still settled.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRacePromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var isDone = false;\r\n            function processItem(item) {\r\n                doAwaitResponse(item, function (value) {\r\n                    if (!isDone) {\r\n                        isDone = true;\r\n                        if (value.rejected) {\r\n                            reject(value.reason);\r\n                        }\r\n                        else {\r\n                            resolve(value.value);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment\r\n * value. It rejects when all of the input's promises reject (including when an empty iterable is passed),\r\n * with an AggregateError containing an array of rejection reasons.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the any of the input's promises fulfills,\r\n * with this first fulfillment value. It rejects when all of the input's promises reject (including when\r\n * an empty iterable is passed), with an AggregateError containing an array of rejection reasons.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAnyPromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var theErros = [];\r\n            var pending = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n            var isDone = false;\r\n            function processItem(item, idx) {\r\n                pending++;\r\n                doAwaitResponse(item, function (value) {\r\n                    if (!value.rejected) {\r\n                        isDone = true;\r\n                        resolve(value.value);\r\n                        return;\r\n                    }\r\n                    else {\r\n                        theErros[idx] = value.reason;\r\n                    }\r\n                    if (--pending === 0 && !isDone) {\r\n                        reject(_createAggregationError(theErros));\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0 && !isDone) {\r\n                    // All promises were either resolved or where not a promise\r\n                    reject(_createAggregationError(theErros));\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n//# sourceMappingURL=base.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrForEach, isNumber, scheduleIdleCallback, scheduleTimeout } from \"@nevware21/ts-utils\";\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items synchronously\r\n * @return An item processor\r\n */\r\nexport function syncItemProcessor(pending) {\r\n    arrForEach(pending, function (fn) {\r\n        try {\r\n            fn();\r\n        }\r\n        catch (e) {\r\n            // Don't let 1 failing handler break all others\r\n            // TODO: Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n        }\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items asynchronously using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function timeoutItemProcessor(timeout) {\r\n    var callbackTimeout = isNumber(timeout) ? timeout : 0;\r\n    return function (pending) {\r\n        scheduleTimeout(function () {\r\n            syncItemProcessor(pending);\r\n        }, callbackTimeout);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items using an idle callback (if available) or based on\r\n * a timeout (when `requestIdenCallback` is not supported) using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function idleItemProcessor(timeout) {\r\n    var options;\r\n    if (timeout >= 0) {\r\n        options = {\r\n            timeout: +timeout\r\n        };\r\n    }\r\n    return function (pending) {\r\n        scheduleIdleCallback(function (deadline) {\r\n            syncItemProcessor(pending);\r\n        }, options);\r\n    };\r\n}\r\n//# sourceMappingURL=itemProcessor.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { timeoutItemProcessor } from \"./itemProcessor\";\r\nvar _allAsyncSettledCreator;\r\nvar _raceAsyncCreator;\r\nvar _anyAsyncCreator;\r\n/**\r\n * Creates an asynchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the optional provided timeout value to schedule when the chained items will be ececuted.\r\n * @group Async\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createAsyncPromise(executor, timeout) {\r\n    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createAsyncAllPromise = /*#__PURE__*/ _createAllPromise(createAsyncPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createAsyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createAsyncPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createAsyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createAsyncPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise Aasynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise(input, timeout) {\r\n    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));\r\n    return _allAsyncSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function createAsyncRacePromise(values, timeout) {\r\n    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));\r\n    return _raceAsyncCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createAsyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise(values, timeout) {\r\n    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));\r\n    return _anyAsyncCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=asyncPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createAsyncPromise } from \"./asyncPromise\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { STRING_STATES } from \"../internal/state\";\r\nimport { dumpObj, isFunction, objDefineProp, throwTypeError, getInst, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\n/**\r\n * @internal\r\n * @ignore\r\n * Flag to determine if the native Promise class should be used if available, used for testing purposes.\r\n */\r\nvar _useNative = true;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the native Promise class\r\n */\r\nvar _promiseCls;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.all` method\r\n */\r\nvar _allCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.allSettled` method\r\n */\r\nvar _allNativeSettledCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.race` method\r\n */\r\nvar _raceNativeCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.any` method\r\n */\r\nvar _anyNativeCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Test Hook function to clear the cached values and set whether to use the native Promise class\r\n * @param useNative\r\n */\r\nexport function _clearPromiseCache(useNative) {\r\n    //#ifdef _DEBUG\r\n    //#:(!_DEBUG)     _useNative = !!useNative;\r\n    //#:(!_DEBUG)     _promiseCls = null as any;\r\n    //#:(!_DEBUG)     _allCreator = null as any;\r\n    //#:(!_DEBUG)     _allNativeSettledCreator = null as any;\r\n    //#:(!_DEBUG)     _raceNativeCreator = null as any;\r\n    //#:(!_DEBUG)     _anyNativeCreator = null as any;\r\n    //#endif\r\n}\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createNativePromiseHelper(name, func) {\r\n    !_promiseCls && (_promiseCls = createCachedValue((_useNative && safe(getInst, [STR_PROMISE]).v) || null));\r\n    if (_promiseCls.v && _promiseCls.v[name]) {\r\n        return createCachedValue(function (input, timeout) {\r\n            return createNativePromise(function (resolve, reject) {\r\n                _promiseCls.v[name](input).then(resolve, reject);\r\n            });\r\n        });\r\n    }\r\n    return func();\r\n}\r\n/**\r\n * Creates a Promise instance that when resolved or rejected will execute it's pending chained operations using the\r\n * available native Promise implementation.\r\n * If runtime does not support native `Promise` class (or no polyfill is available) this function will fallback to using\r\n * `createAsyncPromise` which will resolve them __asynchronously__ using the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * @group Alias\r\n * @group Promise\r\n * @group Native\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createNativePromise(executor, timeout) {\r\n    !_promiseCls && (_promiseCls = createCachedValue((_useNative && safe(getInst, [STR_PROMISE]).v) || null));\r\n    var PrmCls = _promiseCls.v;\r\n    if (!PrmCls) {\r\n        return createAsyncPromise(executor);\r\n    }\r\n    if (!isFunction(executor)) {\r\n        throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpObj(executor));\r\n    }\r\n    var _state = 0 /* ePromiseState.Pending */;\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n    var thePromise = new PrmCls(function (resolve, reject) {\r\n        function _resolve(value) {\r\n            _state = 2 /* ePromiseState.Resolved */;\r\n            resolve(value);\r\n        }\r\n        function _reject(reason) {\r\n            _state = 3 /* ePromiseState.Rejected */;\r\n            reject(reason);\r\n        }\r\n        executor(_resolve, _reject);\r\n    });\r\n    objDefineProp(thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n    return thePromise;\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @group Native\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport function createNativeAllPromise(input, timeout) {\r\n    !_allCreator && (_allCreator = _createNativePromiseHelper(\"all\", function () { return createCachedValue(_createAllPromise(createNativePromise)); }));\r\n    return _allCreator.v(input, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @group Native\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createNativeResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createNativePromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @group Native\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createNativeRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createNativePromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise(input, timeout) {\r\n    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper(\"allSettled\", function () { return _createAllSettledPromise(createNativePromise); }));\r\n    return _allNativeSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function createNativeRacePromise(values, timeout) {\r\n    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper(\"race\", function () { return _createRacePromise(createNativePromise); }));\r\n    return _raceNativeCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createNativeAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise(values, timeout) {\r\n    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper(\"any\", function () { return _createAnyPromise(createNativePromise); }));\r\n    return _anyNativeCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=nativePromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { syncItemProcessor } from \"./itemProcessor\";\r\nvar _allSyncSettledCreator;\r\nvar _raceSyncCreator;\r\nvar _anySyncCreator;\r\n/**\r\n * Creates a synchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __synchronously__ in the same execution cycle as the operation that calls the `executors`, `resolve` or `reject` functions.\r\n *\r\n * @group Synchronous\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n */\r\nexport function createSyncPromise(executor) {\r\n    return _createPromise(createSyncPromise, syncItemProcessor, executor);\r\n}\r\n/**\r\n * Returns a single synchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __synchronously__ in the same\r\n * execution cycle as the final operation pending promises have resolved, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __synchronously__ at the point of\r\n * being added (eg. `then()`; `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createSyncAllPromise = /*#__PURE__*/ _createAllPromise(createSyncPromise);\r\n/**\r\n * Returns a single synchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new synchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __synchronously__ at the point of being\r\n * added (calling `then()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n */\r\nexport var createSyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createSyncPromise);\r\n/**\r\n * Returns a single synchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __synchronously__ at the point of being added (eg. `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n */\r\nexport var createSyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createSyncPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createSyncPromise synchronous} promise implementation. Any chained operations will execute\r\n * __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createSyncAllSettledPromise(input, timeout) {\r\n    !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));\r\n    return _allSyncSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createSyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createSyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * synchronously.\r\n */\r\nexport function createSyncRacePromise(values, timeout) {\r\n    !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));\r\n    return _raceSyncCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createSyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createSyncAnyPromise(values, timeout) {\r\n    !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));\r\n    return _anySyncCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=syncPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isUndefined } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { idleItemProcessor } from \"./itemProcessor\";\r\nvar _defaultIdleTimeout;\r\nvar _allIdleSettledCreator;\r\nvar _raceIdleCreator;\r\nvar _anyIdleCreator;\r\n/**\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport function setDefaultIdlePromiseTimeout(idleDeadline) {\r\n    _defaultIdleTimeout = idleDeadline;\r\n}\r\n/**\r\n * @deprecated Use `setDefaultIdlePromiseTimeout` instead\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport var setDefaultIdleTimeout = ( /*#__PURE__*/setDefaultIdlePromiseTimeout);\r\n/**\r\n * Creates an idle Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed. When `requestIdleCallback` is not available this becomes the same as\r\n * `createAsyncPromise` which uses `setTimeout` to schedule executions.\r\n * @group Idle\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional deadline timeout to wait before processing the items, defaults to undefined. If the number of\r\n * milliseconds represented by this parameter has elapsed and the callback has not already been called, then a task to execute\r\n * the callback is queued in the event loop (even if doing so risks causing a negative performance impact). timeout must be a\r\n * positive value or it is ignored.\r\n */\r\nexport function createIdlePromise(executor, timeout) {\r\n    var theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;\r\n    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);\r\n}\r\n/**\r\n * Returns an idle Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__\r\n * using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using\r\n * the `requestIdleCallback` API (if available) with the optional provided timeout value to schedule\r\n * when the chained items will be executed. (eg. `then()`; `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createIdleAllPromise = /*#__PURE__*/ _createAllPromise(createIdlePromise);\r\n/**\r\n * Returns an idle Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the\r\n * `requestIdleCallback` API (if available) with the optional provided timeout value to schedule when\r\n * the chained items will be executed. (eg. `then()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createIdleResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createIdlePromise);\r\n/**\r\n * Returns an idle Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the o`requestIdleCallback` API\r\n * (if available) with the optional provided timeout value to schedule when the chained items will\r\n * be executed. (eg. `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createIdleRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createIdlePromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createIdlePromise idle} promise implementation. Any chained operations will execute\r\n * __asynchronously__ when the environment is idle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createIdleAllSettledPromise(input, timeout) {\r\n    !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));\r\n    return _allIdleSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createIdleRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createIdleRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously when the system detects that the runtime is idle.\r\n */\r\nexport function createIdleRacePromise(values, timeout) {\r\n    !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));\r\n    return _raceIdleCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createIdleAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createIdleAnyPromise(values, timeout) {\r\n    !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));\r\n    return _anyIdleCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=idlePromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createCachedValue } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { createNativePromise } from \"./nativePromise\";\r\nvar _promiseCreator;\r\nvar _allSettledCreator;\r\nvar _raceCreator;\r\nvar _anyCreator;\r\n/**\r\n * Set the default promise implementation to use when calling `createPromise`; `createAllPromise`; `createResolvedPromise`\r\n * and `createRejectedPromise`. This is effective a global value and changing this will affect ALL callers of these\r\n * functions, as such these functions should only be used when switching implementations would have not unexpected\r\n * consequences like switching from a `createSyncPromise` to `createIdlePromise` where idle promises have a possibility\r\n * of never getting called during application shutdown or during an expected timeframe.\r\n * @group Alias\r\n * @group Promise\r\n * @param creator - The creator function to call when a new promise is required.\r\n */\r\nexport function setCreatePromiseImpl(creator) {\r\n    _promiseCreator = creator ? createCachedValue(creator) : null;\r\n}\r\n/**\r\n * Creates a Promise instance using the current default promise creator that when resolved or rejected will execute\r\n * it's pending chained operations.\r\n * @group Alias\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - [Optional] timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createPromise(executor, timeout) {\r\n    !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));\r\n    return _promiseCreator.v.call(this, executor, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createAllPromise = /*#__PURE__*/ _createAllPromise(createPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the current\r\n * promise implementation. If the current implementation is synchronous then the chained operations will\r\n * execute __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. If the current implementation is asynchronous then the chained\r\n * operations will execute __asynchronously__ using the optional provided timeout value to schedule when the\r\n * chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAllSettledPromise(input, timeout) {\r\n    !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));\r\n    return _allSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * based on the current promise implementation.\r\n */\r\nexport function createRacePromise(values, timeout) {\r\n    !_raceCreator && (_raceCreator = _createRacePromise(createPromise));\r\n    return _raceCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAnyPromise(values, timeout) {\r\n    !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));\r\n    return _anyCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=promise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isUndefined, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { createPromise } from \"./promise\";\r\n/**\r\n * Creates a Promise instance that resolve or reject after the specified timeout.\r\n * @since 0.5.0\r\n * @group Timeout\r\n * @group Promise\r\n * @param timeout - The timeout in milliseconds to wait before resolving or rejecting the promise.\r\n * @param resolveReject - [Optional] If true the promise will resolve, otherwise it will reject.\r\n * @param message - [Optional] The message to use when rejecting the promise, if not supplied (or\r\n * undefined) the default message will be used.\r\n * @returns A promise that will resolve or reject after the specified timeout.\r\n * @example\r\n * ```ts\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100);\r\n * // Throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100, false);\r\n * // throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, false, \"Hello\");\r\n * // throws an Error: Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, true, \"Hello\");\r\n * console.log(result); // Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, true, \"Hello\"), (result) => {\r\n *  console.log(result); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   // Not called\r\n * }, (err) => {\r\n *   console.log(err); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwaitResult(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   console.log(result.rejected); // true\r\n *   console.log(result.reason); // Hello\r\n * });\r\n * ```\r\n */\r\nexport function createTimeoutPromise(timeout, resolveReject, message) {\r\n    return createPromise(function (resolve, reject) {\r\n        scheduleTimeout(function () {\r\n            (resolveReject ? resolve : reject)(!isUndefined(message) ? message : \"Timeout of \" + timeout + \"ms exceeded\");\r\n        }, timeout);\r\n    });\r\n}\r\n//# sourceMappingURL=timeoutPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isFunction, isPromiseLike, utcNow } from \"@nevware21/ts-utils\";\r\nimport { createPromise } from \"../promise/promise\";\r\nimport { doAwait } from \"../promise/await\";\r\nfunction _doneChk(isDone, state, value, thisArg) {\r\n    var result = isDone;\r\n    state.res = value;\r\n    if (!result) {\r\n        if (state.isDone && isFunction(state.isDone)) {\r\n            // Handle synchronous or asynchronous isDone function\r\n            return doAwait(state.isDone.call(thisArg, state), function (done) {\r\n                state.iter++;\r\n                return !!done;\r\n            });\r\n        }\r\n        else {\r\n            result = !!state.isDone;\r\n        }\r\n    }\r\n    state.iter++;\r\n    return result;\r\n}\r\n/**\r\n * Performs a while loop, calling the provided `callbackFn` function until the `state.isDone`\r\n * property is set to `true` or the optional `isDOneFn` returns `true`. The callback function will\r\n * receive a single {@link IWhileState state} argument and may return either a value or a promise,\r\n * if a promise is returned the while loop will wait until the promise is resolved before calling\r\n * the callback function again. If the callback function never returns a promise the while loop\r\n * will be executed synchronous and last value returned by the callback will be returned, if the\r\n * callback function returns a promise the while loop will be asynchronous and an {@link IPromise}\r\n * will be returned and resolved with the last value returned by the callback or rejected if the\r\n * callback promise rejects or throws an error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @typeParam T - Identifies the element type returned by the callback function.\r\n * @param callbackFn A function that will be called until the `state.isDone` flag is set to `true`\r\n * the function will receive a single {@link IWhileState state} argument. The callback function\r\n * may return either a value or a promise, if a promise is returned the while loop will wait\r\n * until the promise is resolved before calling the callback function again.\r\n * @param isDoneFn An optional function that will be called after the callback function is called,\r\n * that can be used to stop the while loop. The function will receive a single {@link IWhileState state}\r\n * argument. If the function returns `true` the while loop will stop, otherwise the while loop will continue.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n * If thisArg is omitted, null or undefined the array will be used as the this value.\r\n * @remarks\r\n * - If an `isDoneFn` is provided the `state.isDone` property will be set to the provided value and\r\n * is accessible withing the callback function. The callbackFn may overwrite the value of the\r\n * `state.isDone` property within the callback function with a boolean value or another function that\r\n * returns a boolean value.\r\n * - The callback function is called until until the `state.isDone` property is set to `true` or if\r\n * `state.isDone` is a function until the function returns `true.\r\n * - The callback function will receive a single {@link IWhileState state} argument that contains\r\n * the following properties:\r\n *  - `iter` - The zero-based iteration count, which is incremented after each call to the `callbackFn`\r\n * and any `isDone` function (if provided), the `iter` property is accessible withing the callback\r\n * function and may be overwritten within the callback function.\r\n * - `res` - The last resolved result value returned by the `callbackFn` function.\r\n * - `isDone` - A boolean value or a callback function that will be called to check if the while loop\r\n * should stop, the `isDone` property is accessible withing the callback function and may be\r\n * overwritten within the callback function.\r\n * - The callback function may return either a value or a promise, if a promise is returned the while\r\n * loop will wait until the promise is resolved before calling the callback function again.\r\n * - If the callback function throws an error when executing `synchronously` the exception will\r\n * also be thrown `synchronously` otherwise the returned promise will be rejected with the error.\r\n * @example\r\n * ```ts\r\n * // Synchronous example\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     return \"Hello\";\r\n *  }\r\n * });\r\n *\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Synchronous example with isDoneFn\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     return \"Hello\";\r\n *  }\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Asynchronous examples\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   state.isDone = true;\r\n *   return createResolvedPromise(\"Darkness\");\r\n * });\r\n * console.log(result); // Darkness\r\n *\r\n * // Asynchronous example with isDoneFn\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   return createResolvedPromise(\"Darkness\");\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Darkness after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Combination Synchronous and Asynchronous example\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await\r\n * const result = await doWhileAsync(async (state) => {\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await and dynamically setting the isDone function\r\n * const result = await doWhileAsync(async (state) => {\r\n *   // dynamically set the isDone function\r\n *   if (state.idx < 10) {\r\n *     state.isDone = () => return false;\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = () => return true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n * ```\r\n */\r\nexport function doWhileAsync(callbackFn, isDoneFn, thisArg) {\r\n    var promise;\r\n    var resolve;\r\n    var reject = function (reason) {\r\n        isDone = true;\r\n        throw reason;\r\n    };\r\n    var isDone = false;\r\n    var state = {\r\n        st: utcNow(),\r\n        iter: 0,\r\n        isDone: isDoneFn || false\r\n    };\r\n    if (callbackFn) {\r\n        var _createPromise_1 = function () {\r\n            return createPromise(function (res, rej) {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n        };\r\n        var _handleAsyncDone_1 = function (done) {\r\n            isDone = !!done;\r\n            if (!isDone) {\r\n                _processNext_1();\r\n            }\r\n            else {\r\n                resolve(state.res);\r\n            }\r\n        };\r\n        var _processNext_1 = function () {\r\n            // Attempt to process the next item synchronously if possible (for performance -- to reduce the number of promises created)\r\n            while (!isDone) {\r\n                try {\r\n                    var cbResult = callbackFn.call(thisArg, state);\r\n                    if (isPromiseLike(cbResult)) {\r\n                        promise = promise || _createPromise_1();\r\n                        doAwait(cbResult, function (res) {\r\n                            try {\r\n                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone_1, reject);\r\n                            }\r\n                            catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        }, reject);\r\n                        // Break out of synchronous loop and wait for promise to resolve\r\n                        return promise;\r\n                    }\r\n                    else {\r\n                        var dnRes = _doneChk(isDone, state, cbResult, thisArg);\r\n                        if (isPromiseLike(dnRes)) {\r\n                            promise = promise || _createPromise_1();\r\n                            doAwait(dnRes, _handleAsyncDone_1, reject);\r\n                            // Break out of synchronous loop and wait for promise to resolve\r\n                            return promise;\r\n                        }\r\n                        else {\r\n                            isDone = !!dnRes;\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                    return promise;\r\n                }\r\n            }\r\n            if (isDone && resolve) {\r\n                resolve(state.res);\r\n            }\r\n            return promise || state.res;\r\n        };\r\n        return _processNext_1();\r\n    }\r\n}\r\n//# sourceMappingURL=doWhileAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { getLength } from \"@nevware21/ts-utils\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in an array (or ArratLike) instance in ascending index order. It is not invoked\r\n * for index properties that have been deleted or are uninitialized. And unlike the ES6 forEach() this supports async functions and you CAN stop\r\n * or break the iteration  by returning -1 from the `callbackFn` function.\r\n *\r\n * The range (number of elements) processed by arrForEach() is set before the first call to the `callbackFn`. Any elements added beyond the range\r\n * or elements which as assigned to indexes already processed will not be visited by the `callbackFn`.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise` then the next iteration will not be\r\n * called until the promise is resolved. If the `callbackFn` returns a `Promise` that is rejected then the iteration will stop and the promise\r\n * returned by arrForEachAsync will be rejected with the same error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the element type of the array\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A `asynchronous` or `synchronous` function that accepts up to three arguments. arrForEach calls the callbackfn function one\r\n * time for each element in the array.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the array will be used as the this value.\r\n * @remarks\r\n * arrForEachAsync supports either a `synchronous` or `asynchronous` (returns a `Promise`) callback function. If the callback function returns\r\n * a `Promise` then the next iteration will not be called until the promise is resolved. If the callback function returns a `Promise` that is\r\n * rejected then the iteration will stop and the promise returned by arrForEachAsync will be rejected with the same error.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * arrForEachASync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * // Also supports input as an array like object\r\n * const items = { length: 3, 0: 'item1', 1: 'item2', 2: 'item3' };\r\n *\r\n * // Asynchronous examples using await\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * await arrForEachASync(items, (value, index) => { // Note: DO NOT use async here unless you use await within the function\r\n *   if (index < 5) {\r\n *     // Logs each iteration index\r\n *     // Logs each value\r\n *     console.log(value);\r\n *     // Returning a promise will cause `arrForEachAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true);\r\n *   }\r\n *\r\n *   return -1; // Stop the iteration\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * ```\r\n */\r\nexport function arrForEachAsync(theArray, callbackFn, thisArg) {\r\n    if (theArray) {\r\n        var len_1 = getLength(theArray);\r\n        if (len_1) {\r\n            var isDone = function (state) {\r\n                if (state.iter >= len_1 || state.res === -1) {\r\n                    return true;\r\n                }\r\n            };\r\n            return doWhileAsync(function (state) {\r\n                var idx = state.iter;\r\n                if (idx in theArray) {\r\n                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);\r\n                }\r\n            }, isDone);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=arrForEachAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createCachedValue, fnCall, getKnownSymbol, isIterator, isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { DONE, RETURN, VALUE } from \"../internal/constants\";\r\nimport { doAwait, doFinally } from \"../promise/await\";\r\nvar _iterSymbol;\r\nvar _iterAsyncSymbol;\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in the iterator or iterator returned by\r\n * the iterable and processed in the same order as returned by the iterator. As with the {@link arrForEachAsync}\r\n * you CAN stop or break the iteration by returning -1 from the `callbackFn` function.\r\n *\r\n * The order of processing is not reset if you add or remove elemenets to the iterator, the actual behavior will\r\n * depend on the iterator implementation.\r\n *\r\n * if the passed `iter` is both an Iterable<T> and Iterator<T> the Iterator<T> interface takes precedence. And if\r\n * an iterable and does not have a `Symbol.iterator` property then the `iter` will be used as the iterator.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise`\r\n * then the next iteration will not be called until the promise is resolved. If the `callbackFn` returns a `Promise`\r\n * that is rejected then the iteration will stop and the promise returned by iterForEachAsync will be rejected with\r\n * the same error.\r\n * @remarks\r\n * If Symbols are NOT supported then the iterable MUST be using the same polyFill for the well know symbols, as used\r\n * by the library. If the iterable is using a different polyFill then the `iter` MUST be an Iterator<T> and not an\r\n * Iterable<T>.\r\n * If you are targetting a mixed environment you SHOULD either\r\n * - only use the polyfill Symbol's provided by this library\r\n * - ensure that you add any symbol polyfills BEFORE these utilities\r\n * iterForOfAsync\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the iterator\r\n * @param iter - The iterator or iterable of elements to be searched.\r\n * @param callbackFn - A `asynchronous` or `synchronous` function that accepts up to three arguments. iterForEach\r\n * calls the callbackfn function one time for each element in the iterator.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted,\r\n * null or undefined the iterator will be used as the this value.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * // using async / await\r\n * let result = await iterForOfAsync(items, async (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   await createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  })\r\n *\r\n * console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *\r\n * // using doAwait\r\n * doAwait(iterForOfAsync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   return createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  }), (result) => {\r\n *    console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *  });\r\n */\r\nexport function iterForOfAsync(iter, callbackFn, thisArg) {\r\n    var err;\r\n    var iterResult;\r\n    var theIter = iter;\r\n    function onFailed(failed) {\r\n        err = { e: failed };\r\n        if (theIter.throw) {\r\n            iterResult = null;\r\n            theIter.throw(err);\r\n        }\r\n        throw failed;\r\n    }\r\n    function onFinally() {\r\n        try {\r\n            if (iterResult && !iterResult[DONE]) {\r\n                theIter[RETURN] && theIter[RETURN](iterResult);\r\n            }\r\n        }\r\n        finally {\r\n            if (err) {\r\n                // eslint-disable-next-line no-unsafe-finally\r\n                throw err.e;\r\n            }\r\n        }\r\n    }\r\n    if (iter) {\r\n        if (!isIterator(iter)) {\r\n            // Get the asyncIterator from the iterable\r\n            !_iterAsyncSymbol && (_iterAsyncSymbol = createCachedValue(getKnownSymbol(0 /* WellKnownSymbols.asyncIterator */)));\r\n            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;\r\n            if (!theIter) {\r\n                // Get the iterator from the iterable\r\n                !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(3 /* WellKnownSymbols.iterator */)));\r\n                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\r\n            }\r\n        }\r\n        if (theIter && isIterator(theIter)) {\r\n            var result = void 0;\r\n            try {\r\n                result = doWhileAsync(function (state) {\r\n                    return doAwait(theIter.next(), function (res) {\r\n                        iterResult = res;\r\n                        if (!res[DONE]) {\r\n                            return fnCall(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);\r\n                        }\r\n                    }, function (reason) {\r\n                        state.isDone = true;\r\n                        onFailed(reason);\r\n                    });\r\n                }, function (state) {\r\n                    if (!iterResult || iterResult[DONE] || state.res === -1) {\r\n                        onFinally();\r\n                        return true;\r\n                    }\r\n                }, thisArg || theIter);\r\n                if (isPromiseLike(result)) {\r\n                    result = doFinally(result.catch(onFailed), onFinally);\r\n                }\r\n                return result;\r\n            }\r\n            catch (failed) {\r\n                onFailed(failed);\r\n            }\r\n            finally {\r\n                if (result && !isPromiseLike(result)) {\r\n                    onFinally();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=iterForOfAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrForEach, arrIndexOf, createCustomError, getLength, isPromiseLike, objDefine, objDefineProp, scheduleTimeout, utcNow } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"../promise/await\";\r\nimport { createPromise } from \"../promise/promise\";\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"../promise/debug\";\r\n//#endif\r\nvar REJECT = \"reject\";\r\nvar REJECTED_ERROR = \"Rejected\";\r\nvar _schedulerId = 0;\r\nvar _debugName;\r\nvar _debugIntState;\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nvar _customErrors = {};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Empty reject function to avoid trying to re-reject\r\n */\r\nfunction _rejectDone() {\r\n    // A Do nothing function\r\n}\r\nfunction _createError(type, evt, message) {\r\n    // Lazily create the class\r\n    !_customErrors[type] && (_customErrors[type] = createCustomError(type));\r\n    var now = utcNow();\r\n    return new (_customErrors[type])(\"Task [\".concat(evt.id, \"] \").concat(message || \"\", \"- \").concat((evt.st ? \"Running\" : \"Waiting\"), \": \").concat(_calcTime(now, evt.st || evt.cr)));\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function used for displaying the time in milliseconds (during debugging)\r\n * @param now - The current time\r\n * @param start - The start time to subtract\r\n * @returns A string representation of the time difference\r\n */\r\nfunction _calcTime(now, start) {\r\n    return ((now - start) || \"0\") + \" ms\";\r\n}\r\n/**\r\n * Abort any stale tasks in the provided task Queue\r\n * @param taskQueue - The Task Queue to search\r\n * @param staleTimeoutPeriod - The maxumum stale timeout period\r\n */\r\nfunction _abortStaleTasks(taskQueue, staleTimeoutPeriod) {\r\n    var now = utcNow();\r\n    var expired = now - staleTimeoutPeriod;\r\n    arrForEach(taskQueue, function (evt) {\r\n        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {\r\n            evt && evt[REJECT](evt.rj || _createError(\"Aborted\", evt, \"Stale \"));\r\n        }\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Remove the `taskDetail` from the `queue` if present\r\n * @param queue - The Task Queue\r\n * @param taskDetail - The Task detail to be removed\r\n */\r\nfunction _removeTask(queue, taskDetail) {\r\n    var idx = arrIndexOf(queue, taskDetail);\r\n    if (idx !== -1) {\r\n        queue.splice(idx, 1);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n * @ignore Internal function to add the debug state to the promise, this code is removed from the production artifacts\r\n * @param theScheduler - The scheduler instance to add the debug accessors to.\r\n * @param nameFn - The function to return then name of this scheduler\r\n * @param stateFn - The function to return the internal state of the scheduler\r\n */\r\nfunction _addDebugState(theScheduler, nameFn, stateFn) {\r\n    _debugName = _debugName || { toString: function () { return \"[[SchedulerName]]\"; } };\r\n    _debugIntState = _debugIntState || { toString: function () { return \"[[SchedulerState]]\"; } };\r\n    objDefineProp(theScheduler, _debugName, { get: nameFn });\r\n    objDefineProp(theScheduler, _debugIntState, { get: stateFn });\r\n}\r\n/**\r\n * Create a Task Scheduler using the optional promise implementation and scheduler name.\r\n * The newPromise can be any value promise creation function, where the execution of the\r\n * queued tasks will be processed based on how the promise implementation processes it's\r\n * chained promises (asynchrounsly; synchronously; idle processing, etc)\r\n *\r\n * The functions used to start each task my return a result (synchronous execution) or an\r\n * {@link IPromise}, `PromiseLike` or `Promise` result (asynchronous execution).\r\n *\r\n * Each task is executed in the order that it was queued and the provided `startTask` function\r\n * will not be called until all previous tasks have completed (whther they resolve or reject).\r\n * The result from any previous task does not affect and is not passed to any later scheduled\r\n * task, if you need this capability then your `startTask` functions will need to co-operate to\r\n * share any common context.\r\n *\r\n * By default, queued tasks which have either been \"waiting\" to run or have been running longer\r\n * then 10 minutes will be Auto-Rejected to try and free up resources. If a task is running when\r\n * it rejected then it will continue to \"run\" based on whatever operation it's `startTask` is\r\n * performing. If a task has not yet had it's `startTask` function called it will never get called.\r\n * In both cases the `IPromise` returned by the call to {@link ITaskScheduler.queue | queue} the\r\n * task will be `rejected`. You can change this default time, including disabling completly via\r\n * the {@link ITaskScheduler.setStaleTimeout | setStaleTimeout}\r\n * function.\r\n * @since 0.2.0\r\n * @group Scheduler\r\n * @param newPromise - The function to use for creating a new promise when required, if not\r\n * provided this will default to {@link createPromise} which will use the default registered\r\n * promise creation function which defaults to runtime native promises or async Promise if not\r\n * supported by the runtime.\r\n * @param name - The name you want to associated with this scheduler, mostly useful for debugging\r\n * @returns A new ITaskScheduler instance\r\n * @example\r\n * ```ts\r\n * let scheduler = createTaskScheduler();\r\n *\r\n * // Schedule a task using the ts-async helper promise functions\r\n * scheduler.queue(() => {\r\n *     return createPromise((resolve, reject) => {\r\n *         scheduleTimeout(() => {\r\n *             // Do something after a delay\r\n *         }, 100);\r\n *     });\r\n * });\r\n *\r\n * // Schedule an asynchronous task which uses async/await\r\n * scheduler.queue(async () => {\r\n *     // This task will only execute after the previous task has completed\r\n *     await performAnotherAsyncTask();\r\n * });\r\n *\r\n * // Schedule a synchronous task that executes and completes immediately\r\n * scheduled.queue(() => {\r\n *     // Do some synchronous task\r\n *     return 42;\r\n * });\r\n *\r\n * // Schedule an asynchronous task which returns a promise\r\n * scheduled.queue(() => {\r\n *     return doAwait(fetch(\"https://github.com/nevware21/ts-async/blob/main/README.md\"), (response) => {\r\n *         let theReadMe = response.text();\r\n *         // Do something with the readme\r\n *     });\r\n * });\r\n * ```\r\n */\r\nexport function createTaskScheduler(newPromise, name) {\r\n    var _theTask;\r\n    var _running = [];\r\n    var _waiting = [];\r\n    var _staleTimeoutPeriod = 600000; // 10 Minutes\r\n    var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10; // 1 Minute\r\n    var _taskCount = 0;\r\n    var _schedulerName = (name ? (name + \".\") : \"\") + _schedulerId++;\r\n    var _blockedTimer;\r\n    // Make sure that a promise creator has been assigned\r\n    newPromise = newPromise || createPromise;\r\n    var _startBlockedTimer = function () {\r\n        var hasTasks = (getLength(_running) + getLength(_waiting)) > 0;\r\n        if (_staleTimeoutPeriod > 0) {\r\n            if (!_blockedTimer) {\r\n                // Only attempt to drop stale / blocked tasks if the timeout period is defined\r\n                _blockedTimer = scheduleTimeout(function () {\r\n                    _abortStaleTasks(_running, _staleTimeoutPeriod);\r\n                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);\r\n                    _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));\r\n                }, _staleTimeoutCheckPeriod);\r\n                _blockedTimer.unref();\r\n            }\r\n            _blockedTimer && (_blockedTimer.enabled = hasTasks);\r\n        }\r\n        else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"Stale Timer disabled\");\r\n            //#endif\r\n        }\r\n    };\r\n    var _queueTask = function (startAction, taskName, timeout) {\r\n        var _a;\r\n        var taskId = _schedulerName + \".\" + _taskCount++;\r\n        if (taskName) {\r\n            taskId += \"-(\" + taskName + \")\";\r\n        }\r\n        var newTask = (_a = {\r\n                id: taskId,\r\n                cr: utcNow(),\r\n                to: timeout\r\n            },\r\n            _a[REJECT] = function (reason) {\r\n                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);\r\n                newTask[REJECT] = _rejectDone;\r\n            },\r\n            _a);\r\n        if (!_theTask) {\r\n            // We don't have any currently running task, so just start the next task\r\n            newTask.p = newPromise(_runTask(newTask, startAction));\r\n        }\r\n        else {\r\n            // Start a new promise which will wait until all current active tasks are completed before starting\r\n            // the new task, it does not resolve this scheduled task until after the new task is resolve to\r\n            // ensure that all scheduled tasks are completed in the correct order\r\n            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);\r\n        }\r\n        // Set this new task as the last one, so that any future tasks will wait for this one\r\n        _theTask = newTask;\r\n        return newTask.p;\r\n    };\r\n    var _runTask = function (taskDetail, startAction) {\r\n        taskDetail.st = utcNow();\r\n        // There should only ever be a single \"running\" task, but using an array\r\n        // for code reuse.\r\n        _running.push(taskDetail);\r\n        _startBlockedTimer();\r\n        // Create and return the promise executor for this action\r\n        return function (onTaskResolve, onTaskReject) {\r\n            var _promiseReject = function (reason) {\r\n                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);\r\n                taskDetail[REJECT] = _rejectDone;\r\n                _doCleanup(taskDetail);\r\n                onTaskResolve = null;\r\n                onTaskReject && onTaskReject(reason);\r\n                onTaskReject = null;\r\n            };\r\n            var taskId = taskDetail.id;\r\n            if (taskDetail.rj) {\r\n                // Already aborted / pre-rejected\r\n                _promiseReject(taskDetail.rj);\r\n            }\r\n            else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_schedulerName, \"Task [\" + taskId + \"] Started after \" + _calcTime(taskDetail.st, taskDetail.cr));\r\n                //#endif\r\n                taskDetail[REJECT] = _promiseReject;\r\n                try {\r\n                    var startResult = startAction(taskId);\r\n                    if (taskDetail.to && isPromiseLike(startResult)) {\r\n                        taskDetail.t = scheduleTimeout(function () {\r\n                            _promiseReject(_createError(\"Timeout\", taskDetail));\r\n                        }, taskDetail.to);\r\n                    }\r\n                    doAwait(startResult, function (theResult) {\r\n                        _doCleanup(taskDetail);\r\n                        try {\r\n                            onTaskResolve && onTaskResolve(theResult);\r\n                        }\r\n                        catch (e) {\r\n                            onTaskReject && onTaskReject(e);\r\n                        }\r\n                        onTaskReject = null;\r\n                        onTaskResolve = null;\r\n                    }, _promiseReject);\r\n                }\r\n                catch (e) {\r\n                    _promiseReject(e);\r\n                }\r\n            }\r\n        };\r\n    };\r\n    var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {\r\n        _waiting.push(taskDetail);\r\n        _startBlockedTimer();\r\n        return newPromise(function (onWaitResolve, onWaitReject) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) let taskId = taskDetail.id;\r\n            //#:(!DEBUG) let prevTaskId = prevTask.id;\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"[\" + taskId + \"] is waiting for [\" + prevTaskId + \"] to complete before starting -- [\" + _waiting.length + \"] waiting\");\r\n            //#endif\r\n            // Wait for the previous tasks to complete before starting this one.\r\n            // This ensures the queue execution order and avoids removing tasks that\r\n            // have not yet been started.\r\n            doAwaitResponse(prevTask.p, function () {\r\n                _removeTask(_waiting, taskDetail);\r\n                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);\r\n            });\r\n        });\r\n    };\r\n    var _doCleanup = function (taskDetail) {\r\n        _removeTask(_running, taskDetail);\r\n        // If there was a timeout stop and clear\r\n        taskDetail.t && taskDetail.t.cancel();\r\n        taskDetail.t = null;\r\n        // Clear the matching current task now that it's complete\r\n        if (_theTask && _theTask === taskDetail) {\r\n            _theTask = null;\r\n            if (getLength(_running) + getLength(_waiting) === 0) {\r\n                _blockedTimer && _blockedTimer.cancel();\r\n                _blockedTimer = null;\r\n            }\r\n        }\r\n    };\r\n    var theScheduler = {\r\n        idle: true,\r\n        queue: _queueTask,\r\n        setStaleTimeout: function (staleTimeout, staleCheckPeriod) {\r\n            _blockedTimer && _blockedTimer.cancel();\r\n            _blockedTimer = null;\r\n            _staleTimeoutPeriod = staleTimeout;\r\n            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;\r\n            _startBlockedTimer();\r\n        }\r\n    };\r\n    // Change the idle property to dynamic\r\n    objDefine(theScheduler, \"idle\", {\r\n        g: function () {\r\n            return getLength(_running) + getLength(_waiting) === 0;\r\n        }\r\n    });\r\n    _addDebugState(theScheduler, function () { return _schedulerName; }, function () {\r\n        return {\r\n            l: _theTask,\r\n            r: _running,\r\n            w: _waiting\r\n        };\r\n    });\r\n    return theScheduler;\r\n}\r\n//# sourceMappingURL=taskScheduler.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { getKnownSymbol, objDefineProp } from \"@nevware21/ts-utils\";\r\nimport { createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncAnyPromise, createAsyncPromise, createAsyncRacePromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"../promise/asyncPromise\";\r\nvar toStringTagSymbol = getKnownSymbol(11 /* WellKnownSymbols.toStringTag */);\r\n/**\r\n * A full polyfill for the Promise class.\r\n * Represents the completion of an asynchronous operation, and its resulting value.\r\n * @since 0.5.0\r\n * @class\r\n * @group Polyfill\r\n * @group Promise\r\n */\r\nexport var PolyPromise = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    function PolyPromiseImpl(executor) {\r\n        this._$ = createAsyncPromise(executor);\r\n        if (toStringTagSymbol) {\r\n            this[toStringTagSymbol] = \"Promise\";\r\n        }\r\n        // Re-Expose the state of the underlying promise\r\n        objDefineProp(this, \"state\", {\r\n            get: function () {\r\n                return this._$.state;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     */\r\n    PolyPromiseImpl.all = createAsyncAllPromise;\r\n    PolyPromiseImpl.race = createAsyncRacePromise;\r\n    PolyPromiseImpl.any = createAsyncAnyPromise;\r\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\r\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\r\n    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\r\n    var theProto = PolyPromiseImpl.prototype;\r\n    theProto.then = function (onResolved, onRejected) {\r\n        return this._$.then(onResolved, onRejected);\r\n    };\r\n    theProto.catch = function (onRejected) {\r\n        return this._$.catch(onRejected);\r\n    };\r\n    theProto.finally = function (onfinally) {\r\n        return this._$.finally(onfinally);\r\n    };\r\n    return PolyPromiseImpl;\r\n}());\r\n//# sourceMappingURL=promise.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}