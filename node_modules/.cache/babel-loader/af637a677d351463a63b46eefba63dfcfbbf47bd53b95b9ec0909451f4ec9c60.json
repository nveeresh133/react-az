{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nvar _a;\nimport { __spreadArrayFn as __spreadArray } from \"@microsoft/applicationinsights-shims\";\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { createAllSettledPromise, createPromise, doAwaitResponse } from \"@nevware21/ts-async\";\nimport { arrAppend, arrForEach, arrIndexOf, createTimeout, deepExtend, hasDocument, isFunction, isNullOrUndefined, isPlainObject, isPromiseLike, objDeepFreeze, objDefine, objForEachKey, objFreeze, objHasOwn, scheduleTimeout, throwError } from \"@nevware21/ts-utils\";\nimport { createDynamicConfig, onConfigChange } from \"../Config/DynamicConfig\";\nimport { ActiveStatus } from \"../JavaScriptSDK.Enums/InitActiveStatusEnum\";\nimport { _DYN_ADD_NOTIFICATION_LIS1, _DYN_CANCEL, _DYN_CREATE_NEW, _DYN_ENABLED, _DYN_GET_NOTIFY_MGR, _DYN_GET_PLUGIN, _DYN_GET_PROCESS_TEL_CONT2, _DYN_IDENTIFIER, _DYN_INITIALIZE, _DYN_INSTRUMENTATION_KEY, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_I_KEY, _DYN_LENGTH, _DYN_LOGGER, _DYN_LOGGING_LEVEL_CONSOL4, _DYN_MESSAGE, _DYN_MESSAGE_ID, _DYN_NAME, _DYN_NOTIFY, _DYN_ON_COMPLETE, _DYN_POLL_INTERNAL_LOGS, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_REMOVE_NOTIFICATION_0, _DYN_SET_DF, _DYN_SPLICE, _DYN_STOP_POLLING_INTERNA3, _DYN_TEARDOWN, _DYN_TIME, _DYN_UNLOAD, _DYN_VALUE, _DYN_VERSION, _DYN_WATCH, _DYN__INACTIVE } from \"../__DynamicConstants\";\nimport { doUnloadAll, runTargetUnload } from \"./AsyncUtils\";\nimport { ChannelControllerPriority } from \"./Constants\";\nimport { createCookieMgr } from \"./CookieMgr\";\nimport { createUniqueNamespace } from \"./DataCacheHelper\";\nimport { getDebugListener } from \"./DbgExtensionUtils\";\nimport { DiagnosticLogger, _InternalLogMessage, _throwInternal, _warnToConsole } from \"./DiagnosticLogger\";\nimport { getSetValue, isNotNullOrUndefined, proxyFunctionAs, proxyFunctions, toISOString } from \"./HelperFuncs\";\nimport { STR_CHANNELS, STR_CORE, STR_CREATE_PERF_MGR, STR_DISABLED, STR_EMPTY, STR_EVENTS_DISCARDED, STR_EXTENSIONS, STR_EXTENSION_CONFIG, STR_GET_PERF_MGR, STR_PRIORITY, UNDEFINED_VALUE } from \"./InternalConstants\";\nimport { NotificationManager } from \"./NotificationManager\";\nimport { PerfManager, doPerf, getGblPerfMgr } from \"./PerfManager\";\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext, createTelemetryProxyChain } from \"./ProcessTelemetryContext\";\nimport { _getPluginState, createDistributedTraceContext, initializePlugins, sortPlugins } from \"./TelemetryHelpers\";\nimport { TelemetryInitializerPlugin } from \"./TelemetryInitializerPlugin\";\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\nimport { createUnloadHookContainer } from \"./UnloadHookContainer\";\nvar strValidationError = \"Plugins must provide initialize method\";\nvar strNotificationManager = \"_notificationManager\";\nvar strSdkUnloadingError = \"SDK is still unloading...\";\nvar strSdkNotInitialized = \"SDK is not initialized\";\nvar maxInitQueueSize = 100;\nvar maxInitTimeout = 50000;\n// const strPluginUnloadFailed = \"Failed to unload plugin\";\n/**\r\n * The default settings for the config.\r\n * WE MUST include all defaults here to ensure that the config is created with all of the properties\r\n * defined as dynamic.\r\n */\nvar defaultConfig = objDeepFreeze((_a = {\n  cookieCfg: {}\n}, _a[STR_EXTENSIONS] = {\n  rdOnly: true,\n  ref: true,\n  v: []\n}, _a[STR_CHANNELS] = {\n  rdOnly: true,\n  ref: true,\n  v: []\n}, _a[STR_EXTENSION_CONFIG] = {\n  ref: true,\n  v: {}\n}, _a[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE, _a.loggingLevelConsole = 0 /* eLoggingSeverity.DISABLED */, _a.diagnosticLogInterval = UNDEFINED_VALUE, _a));\n/**\r\n * Helper to create the default performance manager\r\n * @param core\r\n * @param notificationMgr\r\n */\nfunction _createPerfManager(core, notificationMgr) {\n  return new PerfManager(notificationMgr);\n}\nfunction _validateExtensions(logger, channelPriority, allExtensions) {\n  var _a;\n  // Concat all available extensions\n  var coreExtensions = [];\n  var channels = [];\n  // Check if any two extensions have the same priority, then warn to console\n  // And extract the local extensions from the\n  var extPriorities = {};\n  // Extension validation\n  arrForEach(allExtensions, function (ext) {\n    // Check for ext.initialize\n    if (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE /* @min:%2einitialize */])) {\n      throwError(strValidationError);\n    }\n    var extPriority = ext[STR_PRIORITY /* @min:%2epriority */];\n    var identifier = ext[_DYN_IDENTIFIER /* @min:%2eidentifier */];\n    if (ext && extPriority) {\n      if (!isNullOrUndefined(extPriorities[extPriority])) {\n        _warnToConsole(logger, \"Two extensions have same priority #\" + extPriority + \" - \" + extPriorities[extPriority] + \", \" + identifier);\n      } else {\n        // set a value\n        extPriorities[extPriority] = identifier;\n      }\n    }\n    // Split extensions to core and channels\n    if (!extPriority || extPriority < channelPriority) {\n      // Add to core extension that will be managed by AppInsightsCore\n      coreExtensions[_DYN_PUSH /* @min:%2epush */](ext);\n    } else {\n      channels[_DYN_PUSH /* @min:%2epush */](ext);\n    }\n  });\n  return _a = {}, _a[STR_CORE /* @min:core */] = coreExtensions, _a[STR_CHANNELS /* @min:channels */] = channels, _a;\n}\nfunction _isPluginPresent(thePlugin, plugins) {\n  var exists = false;\n  arrForEach(plugins, function (plugin) {\n    if (plugin === thePlugin) {\n      exists = true;\n      return -1;\n    }\n  });\n  return exists;\n}\nfunction _deepMergeConfig(details, target, newValues, merge) {\n  // Lets assign the new values to the existing config\n  if (newValues) {\n    objForEachKey(newValues, function (key, value) {\n      if (merge) {\n        if (isPlainObject(value) && isPlainObject(target[key])) {\n          // The target is an object and it has a value\n          _deepMergeConfig(details, target[key], value, merge);\n        }\n      }\n      if (merge && isPlainObject(value) && isPlainObject(target[key])) {\n        // The target is an object and it has a value\n        _deepMergeConfig(details, target[key], value, merge);\n      } else {\n        // Just Assign (replace) and/or make the property dynamic\n        details.set(target, key, value);\n      }\n    });\n  }\n}\nfunction _findWatcher(listeners, newWatcher) {\n  var theListener = null;\n  var idx = -1;\n  arrForEach(listeners, function (listener, lp) {\n    if (listener.w === newWatcher) {\n      theListener = listener;\n      idx = lp;\n      return -1;\n    }\n  });\n  return {\n    i: idx,\n    l: theListener\n  };\n}\nfunction _addDelayedCfgListener(listeners, newWatcher) {\n  var theListener = _findWatcher(listeners, newWatcher).l;\n  if (!theListener) {\n    theListener = {\n      w: newWatcher,\n      rm: function () {\n        var fnd = _findWatcher(listeners, newWatcher);\n        if (fnd.i !== -1) {\n          listeners[_DYN_SPLICE /* @min:%2esplice */](fnd.i, 1);\n        }\n      }\n    };\n    listeners[_DYN_PUSH /* @min:%2epush */](theListener);\n  }\n  return theListener;\n}\nfunction _registerDelayedCfgListener(config, listeners, logger) {\n  arrForEach(listeners, function (listener) {\n    var unloadHdl = onConfigChange(config, listener.w, logger);\n    delete listener.w; // Clear the listener reference so it will get garbage collected.\n    // replace the remove function\n    listener.rm = function () {\n      unloadHdl.rm();\n    };\n  });\n}\n// Moved this outside of the closure to reduce the retained memory footprint\nfunction _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {\n  // Will get recalled if any referenced config values are changed\n  unloadContainer.add(configHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\n    var disableDbgExt = details.cfg.disableDbgExt;\n    if (disableDbgExt === true && debugListener) {\n      // Remove any previously loaded debug listener\n      notificationManager[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */](debugListener);\n      debugListener = null;\n    }\n    if (notificationManager && !debugListener && disableDbgExt !== true) {\n      debugListener = getDebugListener(details.cfg);\n      notificationManager[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](debugListener);\n    }\n  }));\n  return debugListener;\n}\n// Moved this outside of the closure to reduce the retained memory footprint\nfunction _createUnloadHook(unloadHook) {\n  return objDefine({\n    rm: function () {\n      unloadHook.rm();\n    }\n  }, \"toJSON\", {\n    v: function () {\n      return \"aicore::onCfgChange<\" + JSON.stringify(unloadHook) + \">\";\n    }\n  });\n}\n/**\r\n * @group Classes\r\n * @group Entrypoint\r\n */\nvar AppInsightsCore = /** @class */function () {\n  function AppInsightsCore() {\n    // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\n    var _configHandler;\n    var _isInitialized;\n    var _logger;\n    var _eventQueue;\n    var _notificationManager;\n    var _perfManager;\n    var _cfgPerfManager;\n    var _cookieManager;\n    var _pluginChain;\n    var _configExtensions;\n    var _channelConfig;\n    var _channels;\n    var _isUnloading;\n    var _telemetryInitializerPlugin;\n    var _internalLogsEventName;\n    var _evtNamespace;\n    var _unloadHandlers;\n    var _hookContainer;\n    var _debugListener;\n    var _traceCtx;\n    var _instrumentationKey;\n    var _cfgListeners;\n    var _extensions;\n    var _pluginVersionStringArr;\n    var _pluginVersionString;\n    var _activeStatus; // to indicate if ikey or endpoint url promised is resolved or not\n    var _endpoint;\n    var _initInMemoMaxSize; // max event count limit during wait for init promises to be resolved\n    var _isStatusSet; // track if active status is set in case of init timeout and init promises setting the status twice\n    var _initTimer;\n    /**\r\n     * Internal log poller\r\n     */\n    var _internalLogPoller;\n    var _internalLogPollerListening;\n    var _forceStopInternalLogPoller;\n    dynamicProto(AppInsightsCore, this, function (_self) {\n      // Set the default values (also called during teardown)\n      _initDefaults();\n      // Special internal method to allow the unit tests and DebugPlugin to hook embedded objects\n      _self[\"_getDbgPlgTargets\"] = function () {\n        return [_extensions, _eventQueue];\n      };\n      _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () {\n        return _isInitialized;\n      };\n      // since version 3.3.0\n      _self.activeStatus = function () {\n        return _activeStatus;\n      };\n      // since version 3.3.0\n      // internal\n      _self._setPendingStatus = function () {\n        _activeStatus = 3 /* eActiveStatus.PENDING */;\n      };\n      // Creating the self.initialize = ()\n      _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, extensions, logger, notificationManager) {\n        if (_isUnloading) {\n          throwError(strSdkUnloadingError);\n        }\n        // Make sure core is only initialized once\n        if (_self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\n          throwError(\"Core cannot be initialized more than once\");\n        }\n        _configHandler = createDynamicConfig(config, defaultConfig, logger || _self[_DYN_LOGGER /* @min:%2elogger */], false);\n        // Re-assigning the local config property so we don't have any references to the passed value and it can be garbage collected\n        config = _configHandler.cfg;\n        // This will be \"re-run\" if the referenced config properties are changed\n        _addUnloadHook(_configHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\n          var rootCfg = details.cfg;\n          var isPending = _activeStatus === 3 /* eActiveStatus.PENDING */;\n          if (isPending) {\n            // means waiting for previous promises to be resolved, won't apply new changes\n            return;\n          }\n          _initInMemoMaxSize = rootCfg.initInMemoMaxSize || maxInitQueueSize;\n          // app Insights core only handle ikey and endpointurl, aisku will handle cs\n          var ikey = rootCfg[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];\n          var endpointUrl = rootCfg.endpointUrl; // do not need to validate endpoint url, if it is null, default one will be set by sender\n          if (isNullOrUndefined(ikey)) {\n            _instrumentationKey = null;\n            // if new ikey is null, set status to be inactive, all new events will be saved in memory or dropped\n            _activeStatus = ActiveStatus[_DYN__INACTIVE /* @min:%2eINACTIVE */];\n            var msg = \"Please provide instrumentation key\";\n            if (!_isInitialized) {\n              // only throw error during initialization\n              throwError(msg);\n            } else {\n              _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, msg);\n              _releaseQueues();\n            }\n            return;\n          }\n          var promises = [];\n          if (isPromiseLike(ikey)) {\n            promises[_DYN_PUSH /* @min:%2epush */](ikey);\n            _instrumentationKey = null; // reset current local ikey variable (otherwise it will always be the previous ikeys if timeout is called before promise cb)\n          } else {\n            // string\n            _instrumentationKey = ikey;\n          }\n          if (isPromiseLike(endpointUrl)) {\n            promises[_DYN_PUSH /* @min:%2epush */](endpointUrl);\n            _endpoint = null; // reset current local endpoint variable (otherwise it will always be the previous urls if timeout is called before promise cb)\n          } else {\n            // string or null\n            _endpoint = endpointUrl;\n          }\n          // at least have one promise\n          if (promises[_DYN_LENGTH /* @min:%2elength */]) {\n            // reset to false for new dynamic changes\n            _isStatusSet = false;\n            _activeStatus = 3 /* eActiveStatus.PENDING */;\n            var initTimeout = isNotNullOrUndefined(rootCfg.initTimeOut) ? rootCfg.initTimeOut : maxInitTimeout; // rootCfg.initTimeOut could be 0\n            var allPromises = createAllSettledPromise(promises);\n            _initTimer = scheduleTimeout(function () {\n              // set _isStatusSet to true\n              // set active status\n              // release queues\n              _initTimer = null;\n              if (!_isStatusSet) {\n                _setStatus();\n              }\n            }, initTimeout);\n            doAwaitResponse(allPromises, function (response) {\n              try {\n                if (_isStatusSet) {\n                  // promises take too long to resolve, ignore them\n                  // active status should be set by timeout already\n                  return;\n                }\n                if (!response.rejected) {\n                  var values = response[_DYN_VALUE /* @min:%2evalue */];\n                  if (values && values[_DYN_LENGTH /* @min:%2elength */]) {\n                    // ikey\n                    var ikeyRes = values[0];\n                    _instrumentationKey = ikeyRes && ikeyRes[_DYN_VALUE /* @min:%2evalue */];\n                    // endpoint\n                    if (values[_DYN_LENGTH /* @min:%2elength */] > 1) {\n                      var endpointRes = values[1];\n                      _endpoint = endpointRes && endpointRes[_DYN_VALUE /* @min:%2evalue */];\n                    }\n                  }\n                  if (_instrumentationKey) {\n                    // if ikey is null, no need to trigger extra dynamic changes for extensions\n                    config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = _instrumentationKey; // set config.instrumentationKey for extensions to consume\n                    config.endpointUrl = _endpoint; // set config.endpointUrl for extensions to consume\n                  }\n                }\n                // set _isStatusSet to true\n                // set active status\n                // release queues\n                _setStatus();\n              } catch (e) {\n                if (!_isStatusSet) {\n                  _setStatus();\n                }\n              }\n            });\n          } else {\n            // means no promises\n            _setStatus();\n          }\n          //_instrumentationKey = details.cfg.instrumentationKey;\n          // Mark the extensionConfig and all first level keys as referenced\n          // This is so that calls to getExtCfg() will always return the same object\n          // Even when a user may \"re-assign\" the plugin properties (or it's unloaded/reloaded)\n          var extCfg = details.ref(details.cfg, STR_EXTENSION_CONFIG);\n          objForEachKey(extCfg, function (key) {\n            details.ref(extCfg, key);\n          });\n        }));\n        _notificationManager = notificationManager;\n        // Initialize the debug listener outside of the closure to reduce the retained memory footprint\n        _debugListener = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */](), _debugListener);\n        _initPerfManager();\n        _self[_DYN_LOGGER /* @min:%2elogger */] = logger;\n        var cfgExtensions = config[STR_EXTENSIONS /* @min:%2eextensions */];\n        // Extension validation\n        _configExtensions = [];\n        _configExtensions[_DYN_PUSH /* @min:%2epush */].apply(_configExtensions, __spreadArray(__spreadArray([], extensions, false), cfgExtensions, false));\n        _channelConfig = config[STR_CHANNELS /* @min:%2echannels */];\n        _initPluginChain(null);\n        if (!_channels || _channels[_DYN_LENGTH /* @min:%2elength */] === 0) {\n          throwError(\"No \" + STR_CHANNELS + \" available\");\n        }\n        if (_channelConfig && _channelConfig[_DYN_LENGTH /* @min:%2elength */] > 1) {\n          var teeController = _self[_DYN_GET_PLUGIN /* @min:%2egetPlugin */](\"TeeChannelController\");\n          if (!teeController || !teeController.plugin) {\n            _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"TeeChannel required\");\n          }\n        }\n        _registerDelayedCfgListener(config, _cfgListeners, _logger);\n        _cfgListeners = null;\n        _isInitialized = true;\n        if (_activeStatus === ActiveStatus.ACTIVE) {\n          _releaseQueues();\n        }\n      };\n      _self.getChannels = function () {\n        var controls = [];\n        if (_channels) {\n          arrForEach(_channels, function (channel) {\n            controls[_DYN_PUSH /* @min:%2epush */](channel);\n          });\n        }\n        return objFreeze(controls);\n      };\n      _self.track = function (telemetryItem) {\n        doPerf(_self[STR_GET_PERF_MGR /* @min:%2egetPerfMgr */](), function () {\n          return \"AppInsightsCore:track\";\n        }, function () {\n          if (telemetryItem === null) {\n            _notifyInvalidEvent(telemetryItem);\n            // throw error\n            throwError(\"Invalid telemetry item\");\n          }\n          // do basic validation before sending it through the pipeline\n          if (!telemetryItem[_DYN_NAME /* @min:%2ename */] && isNullOrUndefined(telemetryItem[_DYN_NAME /* @min:%2ename */])) {\n            _notifyInvalidEvent(telemetryItem);\n            throwError(\"telemetry name required\");\n          }\n          // setup default iKey if not passed in\n          telemetryItem[_DYN_I_KEY /* @min:%2eiKey */] = telemetryItem[_DYN_I_KEY /* @min:%2eiKey */] || _instrumentationKey;\n          // add default timestamp if not passed in\n          telemetryItem[_DYN_TIME /* @min:%2etime */] = telemetryItem[_DYN_TIME /* @min:%2etime */] || toISOString(new Date());\n          // Common Schema 4.0\n          telemetryItem.ver = telemetryItem.ver || \"4.0\";\n          if (!_isUnloading && _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]() && _activeStatus === ActiveStatus.ACTIVE) {\n            // Process the telemetry plugin chain\n            _createTelCtx()[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](telemetryItem);\n          } else if (_activeStatus !== ActiveStatus[_DYN__INACTIVE /* @min:%2eINACTIVE */]) {\n            // Queue events until all extensions are initialized\n            if (_eventQueue[_DYN_LENGTH /* @min:%2elength */] <= _initInMemoMaxSize) {\n              // set limit, if full, stop adding new events\n              _eventQueue[_DYN_PUSH /* @min:%2epush */](telemetryItem);\n            }\n          }\n        }, function () {\n          return {\n            item: telemetryItem\n          };\n        }, !telemetryItem.sync);\n      };\n      _self[_DYN_GET_PROCESS_TEL_CONT2 /* @min:%2egetProcessTelContext */] = _createTelCtx;\n      _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */] = function () {\n        if (!_notificationManager) {\n          _notificationManager = new NotificationManager(_configHandler.cfg);\n          // For backward compatibility only\n          _self[strNotificationManager] = _notificationManager;\n        }\n        return _notificationManager;\n      };\n      /**\r\n       * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.\r\n       * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be\r\n       * called.\r\n       * @param listener - An INotificationListener object.\r\n       */\n      _self[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {\n        _self.getNotifyMgr()[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](listener);\n      };\n      /**\r\n       * Removes all instances of the listener.\r\n       * @param listener - INotificationListener to remove.\r\n       */\n      _self[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {\n        if (_notificationManager) {\n          _notificationManager[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */](listener);\n        }\n      };\n      _self.getCookieMgr = function () {\n        if (!_cookieManager) {\n          _cookieManager = createCookieMgr(_configHandler.cfg, _self[_DYN_LOGGER /* @min:%2elogger */]);\n        }\n        return _cookieManager;\n      };\n      _self.setCookieMgr = function (cookieMgr) {\n        if (_cookieManager !== cookieMgr) {\n          runTargetUnload(_cookieManager, false);\n          _cookieManager = cookieMgr;\n        }\n      };\n      _self[STR_GET_PERF_MGR /* @min:%2egetPerfMgr */] = function () {\n        return _perfManager || _cfgPerfManager || getGblPerfMgr();\n      };\n      _self.setPerfMgr = function (perfMgr) {\n        _perfManager = perfMgr;\n      };\n      _self.eventCnt = function () {\n        return _eventQueue[_DYN_LENGTH /* @min:%2elength */];\n      };\n      _self.releaseQueue = function () {\n        if (_isInitialized && _eventQueue[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          var eventQueue = _eventQueue;\n          _eventQueue = [];\n          if (_activeStatus === 2 /* eActiveStatus.ACTIVE */) {\n            arrForEach(eventQueue, function (event) {\n              event[_DYN_I_KEY /* @min:%2eiKey */] = event[_DYN_I_KEY /* @min:%2eiKey */] || _instrumentationKey;\n              _createTelCtx()[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](event);\n            });\n          } else {\n            // new one for msg ikey\n            _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, \"core init status is not active\");\n          }\n        }\n      };\n      _self[_DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */] = function (eventName) {\n        _internalLogsEventName = eventName || null;\n        _forceStopInternalLogPoller = false;\n        _internalLogPoller && _internalLogPoller[_DYN_CANCEL /* @min:%2ecancel */]();\n        return _startLogPoller(true);\n      };\n      function _setStatus() {\n        _isStatusSet = true;\n        if (isNullOrUndefined(_instrumentationKey)) {\n          _activeStatus = ActiveStatus[_DYN__INACTIVE /* @min:%2eINACTIVE */];\n          _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 112 /* _eInternalMessageId.InitPromiseException */, \"ikey can't be resolved from promises\");\n        } else {\n          _activeStatus = ActiveStatus.ACTIVE;\n        }\n        _releaseQueues();\n      }\n      function _releaseQueues() {\n        if (_isInitialized) {\n          _self.releaseQueue();\n          _self[_DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */]();\n        }\n      }\n      function _startLogPoller(alwaysStart) {\n        if ((!_internalLogPoller || !_internalLogPoller[_DYN_ENABLED /* @min:%2eenabled */]) && !_forceStopInternalLogPoller) {\n          var shouldStart = alwaysStart || _logger && _logger.queue[_DYN_LENGTH /* @min:%2elength */] > 0;\n          if (shouldStart) {\n            if (!_internalLogPollerListening) {\n              _internalLogPollerListening = true;\n              // listen for any configuration changes so that changes to the\n              // interval will cause the timer to be re-initialized\n              _addUnloadHook(_configHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\n                var interval = details.cfg.diagnosticLogInterval;\n                if (!interval || !(interval > 0)) {\n                  interval = 10000;\n                }\n                var isRunning = false;\n                if (_internalLogPoller) {\n                  // It was already created so remember it's running and cancel\n                  isRunning = _internalLogPoller[_DYN_ENABLED /* @min:%2eenabled */];\n                  _internalLogPoller[_DYN_CANCEL /* @min:%2ecancel */]();\n                }\n                // Create / reconfigure\n                _internalLogPoller = createTimeout(_flushInternalLogs, interval);\n                _internalLogPoller.unref();\n                // Restart if previously running\n                _internalLogPoller[_DYN_ENABLED /* @min:%2eenabled */] = isRunning;\n              }));\n            }\n            _internalLogPoller[_DYN_ENABLED /* @min:%2eenabled */] = true;\n          }\n        }\n        return _internalLogPoller;\n      }\n      _self[_DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */] = function () {\n        _forceStopInternalLogPoller = true;\n        _internalLogPoller && _internalLogPoller[_DYN_CANCEL /* @min:%2ecancel */]();\n        _flushInternalLogs();\n      };\n      // Add addTelemetryInitializer\n      proxyFunctions(_self, function () {\n        return _telemetryInitializerPlugin;\n      }, [\"addTelemetryInitializer\"]);\n      _self[_DYN_UNLOAD /* @min:%2eunload */] = function (isAsync, unloadComplete, cbTimeout) {\n        var _a;\n        if (isAsync === void 0) {\n          isAsync = true;\n        }\n        if (!_isInitialized) {\n          // The SDK is not initialized\n          throwError(strSdkNotInitialized);\n        }\n        // Check if the SDK still unloading so throw\n        if (_isUnloading) {\n          // The SDK is already unloading\n          throwError(strSdkUnloadingError);\n        }\n        var unloadState = (_a = {\n          reason: 50 /* TelemetryUnloadReason.SdkUnload */\n        }, _a[_DYN_IS_ASYNC /* @min:isAsync */] = isAsync, _a.flushComplete = false, _a);\n        var result;\n        if (isAsync && !unloadComplete) {\n          result = createPromise(function (resolve) {\n            // Set the callback to the promise resolve callback\n            unloadComplete = resolve;\n          });\n        }\n        var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);\n        processUnloadCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {\n          _hookContainer.run(_self[_DYN_LOGGER /* @min:%2elogger */]);\n          // Run any \"unload\" functions for the _cookieManager, _notificationManager and _logger\n          doUnloadAll([_cookieManager, _notificationManager, _logger], isAsync, function () {\n            _initDefaults();\n            unloadComplete && unloadComplete(unloadState);\n          });\n        }, _self);\n        function _doUnload(flushComplete) {\n          unloadState.flushComplete = flushComplete;\n          _isUnloading = true;\n          // Run all of the unload handlers first (before unloading the plugins)\n          _unloadHandlers.run(processUnloadCtx, unloadState);\n          // Stop polling the internal logs\n          _self[_DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */]();\n          // Start unloading the components, from this point onwards the SDK should be considered to be in an unstable state\n          processUnloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\n        }\n        _flushInternalLogs();\n        if (!_flushChannels(isAsync, _doUnload, 6 /* SendRequestReason.SdkUnload */, cbTimeout)) {\n          _doUnload(false);\n        }\n        return result;\n      };\n      _self[_DYN_GET_PLUGIN /* @min:%2egetPlugin */] = _getPlugin;\n      _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {\n        if (!plugin) {\n          addCb && addCb(false);\n          _logOrThrowError(strValidationError);\n          return;\n        }\n        var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */]);\n        if (existingPlugin && !replaceExisting) {\n          addCb && addCb(false);\n          _logOrThrowError(\"Plugin [\" + plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"] is already loaded!\");\n          return;\n        }\n        var updateState = {\n          reason: 16 /* TelemetryUpdateReason.PluginAdded */\n        };\n        function _addPlugin(removed) {\n          _configExtensions[_DYN_PUSH /* @min:%2epush */](plugin);\n          updateState.added = [plugin];\n          // Re-Initialize the plugin chain\n          _initPluginChain(updateState);\n          addCb && addCb(true);\n        }\n        if (existingPlugin) {\n          var removedPlugins_1 = [existingPlugin.plugin];\n          var unloadState = {\n            reason: 2 /* TelemetryUnloadReason.PluginReplace */,\n            isAsync: !!isAsync\n          };\n          _removePlugins(removedPlugins_1, unloadState, function (removed) {\n            if (!removed) {\n              // Previous plugin was successfully removed or was not installed\n              addCb && addCb(false);\n            } else {\n              updateState.removed = removedPlugins_1;\n              updateState.reason |= 32 /* TelemetryUpdateReason.PluginRemoved */;\n              _addPlugin(true);\n            }\n          });\n        } else {\n          _addPlugin(false);\n        }\n      };\n      _self.updateCfg = function (newConfig, mergeExisting) {\n        if (mergeExisting === void 0) {\n          mergeExisting = true;\n        }\n        var updateState;\n        if (_self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\n          updateState = {\n            reason: 1 /* TelemetryUpdateReason.ConfigurationChanged */,\n            cfg: _configHandler.cfg,\n            oldCfg: deepExtend({}, _configHandler.cfg),\n            newConfig: deepExtend({}, newConfig),\n            merge: mergeExisting\n          };\n          newConfig = updateState.newConfig;\n          var cfg = _configHandler.cfg;\n          // replace the immutable (if initialized) values\n          // We don't currently allow updating the extensions and channels via the update config\n          // So overwriting any user provided values to reuse the existing values\n          newConfig[STR_EXTENSIONS /* @min:%2eextensions */] = cfg[STR_EXTENSIONS /* @min:%2eextensions */];\n          newConfig[STR_CHANNELS /* @min:%2echannels */] = cfg[STR_CHANNELS /* @min:%2echannels */];\n        }\n        // Explicitly blocking any previous config watchers so that they don't get called because\n        // of this bulk update (Probably not necessary)\n        _configHandler._block(function (details) {\n          // Lets assign the new values to the existing config either overwriting or re-assigning\n          var theConfig = details.cfg;\n          _deepMergeConfig(details, theConfig, newConfig, mergeExisting);\n          if (!mergeExisting) {\n            // Remove (unassign) the values \"missing\" from the newConfig and also not in the default config\n            objForEachKey(theConfig, function (key) {\n              if (!objHasOwn(newConfig, key)) {\n                // Set the value to undefined\n                details.set(theConfig, key, UNDEFINED_VALUE);\n              }\n            });\n          }\n          // Apply defaults to the new config\n          details[_DYN_SET_DF /* @min:%2esetDf */](theConfig, defaultConfig);\n        }, true);\n        // Now execute all of the listeners (synchronously) so they update their values immediately\n        _configHandler[_DYN_NOTIFY /* @min:%2enotify */]();\n        if (updateState) {\n          _doUpdate(updateState);\n        }\n      };\n      _self.evtNamespace = function () {\n        return _evtNamespace;\n      };\n      _self.flush = _flushChannels;\n      _self.getTraceCtx = function (createNew) {\n        if (!_traceCtx) {\n          _traceCtx = createDistributedTraceContext();\n        }\n        return _traceCtx;\n      };\n      _self.setTraceCtx = function (traceCtx) {\n        _traceCtx = traceCtx || null;\n      };\n      _self.addUnloadHook = _addUnloadHook;\n      // Create the addUnloadCb\n      proxyFunctionAs(_self, \"addUnloadCb\", function () {\n        return _unloadHandlers;\n      }, \"add\");\n      _self.onCfgChange = function (handler) {\n        var unloadHook;\n        if (!_isInitialized) {\n          unloadHook = _addDelayedCfgListener(_cfgListeners, handler);\n        } else {\n          unloadHook = onConfigChange(_configHandler.cfg, handler, _self[_DYN_LOGGER /* @min:%2elogger */]);\n        }\n        return _createUnloadHook(unloadHook);\n      };\n      _self.getWParam = function () {\n        return hasDocument() || !!_configHandler.cfg.enableWParam ? 0 : -1;\n      };\n      function _setPluginVersions() {\n        var thePlugins = {};\n        _pluginVersionStringArr = [];\n        var _addPluginVersions = function (plugins) {\n          if (plugins) {\n            arrForEach(plugins, function (plugin) {\n              if (plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] && plugin[_DYN_VERSION /* @min:%2eversion */] && !thePlugins[plugin.identifier]) {\n                var ver = plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"=\" + plugin[_DYN_VERSION /* @min:%2eversion */];\n                _pluginVersionStringArr[_DYN_PUSH /* @min:%2epush */](ver);\n                thePlugins[plugin.identifier] = plugin;\n              }\n            });\n          }\n        };\n        _addPluginVersions(_channels);\n        if (_channelConfig) {\n          arrForEach(_channelConfig, function (channels) {\n            _addPluginVersions(channels);\n          });\n        }\n        _addPluginVersions(_configExtensions);\n      }\n      function _initDefaults() {\n        _isInitialized = false;\n        // Use a default logger so initialization errors are not dropped on the floor with full logging\n        _configHandler = createDynamicConfig({}, defaultConfig, _self[_DYN_LOGGER /* @min:%2elogger */]);\n        // Set the logging level to critical so that any critical initialization failures are displayed on the console\n        _configHandler.cfg[_DYN_LOGGING_LEVEL_CONSOL4 /* @min:%2eloggingLevelConsole */] = 1 /* eLoggingSeverity.CRITICAL */;\n        // Define _self.config\n        objDefine(_self, \"config\", {\n          g: function () {\n            return _configHandler.cfg;\n          },\n          s: function (newValue) {\n            _self.updateCfg(newValue, false);\n          }\n        });\n        objDefine(_self, \"pluginVersionStringArr\", {\n          g: function () {\n            if (!_pluginVersionStringArr) {\n              _setPluginVersions();\n            }\n            return _pluginVersionStringArr;\n          }\n        });\n        objDefine(_self, \"pluginVersionString\", {\n          g: function () {\n            if (!_pluginVersionString) {\n              if (!_pluginVersionStringArr) {\n                _setPluginVersions();\n              }\n              _pluginVersionString = _pluginVersionStringArr.join(\";\");\n            }\n            return _pluginVersionString || STR_EMPTY;\n          }\n        });\n        objDefine(_self, \"logger\", {\n          g: function () {\n            if (!_logger) {\n              _logger = new DiagnosticLogger(_configHandler.cfg);\n              _configHandler[_DYN_LOGGER /* @min:%2elogger */] = _logger;\n            }\n            return _logger;\n          },\n          s: function (newLogger) {\n            _configHandler[_DYN_LOGGER /* @min:%2elogger */] = newLogger;\n            if (_logger !== newLogger) {\n              runTargetUnload(_logger, false);\n              _logger = newLogger;\n            }\n          }\n        });\n        _self[_DYN_LOGGER /* @min:%2elogger */] = new DiagnosticLogger(_configHandler.cfg);\n        _extensions = [];\n        var cfgExtensions = _self.config[STR_EXTENSIONS /* @min:%2eextensions */] || [];\n        cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH /* @min:%2elength */]);\n        arrAppend(cfgExtensions, _extensions);\n        _telemetryInitializerPlugin = new TelemetryInitializerPlugin();\n        _eventQueue = [];\n        runTargetUnload(_notificationManager, false);\n        _notificationManager = null;\n        _perfManager = null;\n        _cfgPerfManager = null;\n        runTargetUnload(_cookieManager, false);\n        _cookieManager = null;\n        _pluginChain = null;\n        _configExtensions = [];\n        _channelConfig = null;\n        _channels = null;\n        _isUnloading = false;\n        _internalLogsEventName = null;\n        _evtNamespace = createUniqueNamespace(\"AIBaseCore\", true);\n        _unloadHandlers = createUnloadHandlerContainer();\n        _traceCtx = null;\n        _instrumentationKey = null;\n        _hookContainer = createUnloadHookContainer();\n        _cfgListeners = [];\n        _pluginVersionString = null;\n        _pluginVersionStringArr = null;\n        _forceStopInternalLogPoller = false;\n        _internalLogPoller = null;\n        _internalLogPollerListening = false;\n        _activeStatus = 0 /* eActiveStatus.NONE */; // default is None\n        _endpoint = null;\n        _initInMemoMaxSize = null;\n        _isStatusSet = false;\n        _initTimer = null;\n      }\n      function _createTelCtx() {\n        var theCtx = createProcessTelemetryContext(_getPluginChain(), _configHandler.cfg, _self);\n        theCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](_startLogPoller);\n        return theCtx;\n      }\n      // Initialize or Re-initialize the plugins\n      function _initPluginChain(updateState) {\n        // Extension validation\n        var theExtensions = _validateExtensions(_self[_DYN_LOGGER /* @min:%2elogger */], ChannelControllerPriority, _configExtensions);\n        _pluginChain = null;\n        _pluginVersionString = null;\n        _pluginVersionStringArr = null;\n        // Get the primary channel queue and include as part of the normal extensions\n        _channels = (_channelConfig || [])[0] || [];\n        // Add any channels provided in the extensions and sort them\n        _channels = sortPlugins(arrAppend(_channels, theExtensions[STR_CHANNELS /* @min:%2echannels */]));\n        // Create an array of all extensions, including the _channels\n        var allExtensions = arrAppend(sortPlugins(theExtensions[STR_CORE /* @min:%2ecore */]), _channels);\n        // Required to allow plugins to call core.getPlugin() during their own initialization\n        _extensions = objFreeze(allExtensions);\n        // This has a side effect of adding the extensions passed during initialization\n        // into the config.extensions, so you can see all of the extensions loaded.\n        // This will also get updated by the addPlugin() and remove plugin code.\n        var cfgExtensions = _self.config[STR_EXTENSIONS /* @min:%2eextensions */] || [];\n        cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH /* @min:%2elength */]);\n        arrAppend(cfgExtensions, _extensions);\n        var rootCtx = _createTelCtx();\n        // Initializing the channels first\n        if (_channels && _channels[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          initializePlugins(rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](_channels), allExtensions);\n        }\n        // Now initialize the normal extensions (explicitly not including the _channels as this can cause duplicate initialization)\n        initializePlugins(rootCtx, allExtensions);\n        if (updateState) {\n          _doUpdate(updateState);\n        }\n      }\n      function _getPlugin(pluginIdentifier) {\n        var theExt = null;\n        var thePlugin = null;\n        var channelHosts = [];\n        arrForEach(_extensions, function (ext) {\n          if (ext[_DYN_IDENTIFIER /* @min:%2eidentifier */] === pluginIdentifier && ext !== _telemetryInitializerPlugin) {\n            thePlugin = ext;\n            return -1;\n          }\n          if (ext.getChannel) {\n            channelHosts[_DYN_PUSH /* @min:%2epush */](ext);\n          }\n        });\n        if (!thePlugin && channelHosts[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          arrForEach(channelHosts, function (host) {\n            thePlugin = host.getChannel(pluginIdentifier);\n            if (!thePlugin) {\n              return -1;\n            }\n          });\n        }\n        if (thePlugin) {\n          theExt = {\n            plugin: thePlugin,\n            setEnabled: function (enabled) {\n              _getPluginState(thePlugin)[STR_DISABLED] = !enabled;\n            },\n            isEnabled: function () {\n              var pluginState = _getPluginState(thePlugin);\n              return !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] && !pluginState[STR_DISABLED];\n            },\n            remove: function (isAsync, removeCb) {\n              var _a;\n              if (isAsync === void 0) {\n                isAsync = true;\n              }\n              var pluginsToRemove = [thePlugin];\n              var unloadState = (_a = {\n                reason: 1 /* TelemetryUnloadReason.PluginUnload */\n              }, _a[_DYN_IS_ASYNC /* @min:isAsync */] = isAsync, _a);\n              _removePlugins(pluginsToRemove, unloadState, function (removed) {\n                if (removed) {\n                  // Re-Initialize the plugin chain\n                  _initPluginChain({\n                    reason: 32 /* TelemetryUpdateReason.PluginRemoved */,\n                    removed: pluginsToRemove\n                  });\n                }\n                removeCb && removeCb(removed);\n              });\n            }\n          };\n        }\n        return theExt;\n      }\n      function _getPluginChain() {\n        if (!_pluginChain) {\n          // copy the collection of extensions\n          var extensions = (_extensions || []).slice();\n          // During add / remove this may get called again, so don't read if already present\n          if (arrIndexOf(extensions, _telemetryInitializerPlugin) === -1) {\n            extensions[_DYN_PUSH /* @min:%2epush */](_telemetryInitializerPlugin);\n          }\n          _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _configHandler.cfg, _self);\n        }\n        return _pluginChain;\n      }\n      function _removePlugins(thePlugins, unloadState, removeComplete) {\n        if (thePlugins && thePlugins[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          var unloadChain = createTelemetryProxyChain(thePlugins, _configHandler.cfg, _self);\n          var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);\n          unloadCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {\n            var removed = false;\n            // Remove the listed config extensions\n            var newConfigExtensions = [];\n            arrForEach(_configExtensions, function (plugin, idx) {\n              if (!_isPluginPresent(plugin, thePlugins)) {\n                newConfigExtensions[_DYN_PUSH /* @min:%2epush */](plugin);\n              } else {\n                removed = true;\n              }\n            });\n            _configExtensions = newConfigExtensions;\n            _pluginVersionString = null;\n            _pluginVersionStringArr = null;\n            // Re-Create the channel config\n            var newChannelConfig = [];\n            if (_channelConfig) {\n              arrForEach(_channelConfig, function (queue, idx) {\n                var newQueue = [];\n                arrForEach(queue, function (channel) {\n                  if (!_isPluginPresent(channel, thePlugins)) {\n                    newQueue[_DYN_PUSH /* @min:%2epush */](channel);\n                  } else {\n                    removed = true;\n                  }\n                });\n                newChannelConfig[_DYN_PUSH /* @min:%2epush */](newQueue);\n              });\n              _channelConfig = newChannelConfig;\n            }\n            removeComplete && removeComplete(removed);\n            _startLogPoller();\n          });\n          unloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\n        } else {\n          removeComplete(false);\n        }\n      }\n      function _flushInternalLogs() {\n        if (_logger && _logger.queue) {\n          var queue = _logger.queue.slice(0);\n          _logger.queue[_DYN_LENGTH /* @min:%2elength */] = 0;\n          arrForEach(queue, function (logMessage) {\n            var _a;\n            var item = (_a = {}, _a[_DYN_NAME /* @min:name */] = _internalLogsEventName ? _internalLogsEventName : \"InternalMessageId: \" + logMessage[_DYN_MESSAGE_ID /* @min:%2emessageId */], _a[_DYN_I_KEY /* @min:iKey */] = _instrumentationKey, _a[_DYN_TIME /* @min:time */] = toISOString(new Date()), _a.baseType = _InternalLogMessage.dataType, _a.baseData = {\n              message: logMessage[_DYN_MESSAGE /* @min:%2emessage */]\n            }, _a);\n            _self.track(item);\n          });\n        }\n      }\n      function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {\n        // Setting waiting to one so that we don't call the callBack until we finish iterating\n        var waiting = 1;\n        var doneIterating = false;\n        var cbTimer = null;\n        cbTimeout = cbTimeout || 5000;\n        function doCallback() {\n          waiting--;\n          if (doneIterating && waiting === 0) {\n            cbTimer && cbTimer[_DYN_CANCEL /* @min:%2ecancel */]();\n            cbTimer = null;\n            callBack && callBack(doneIterating);\n            callBack = null;\n          }\n        }\n        if (_channels && _channels[_DYN_LENGTH /* @min:%2elength */] > 0) {\n          var flushCtx = _createTelCtx()[_DYN_CREATE_NEW /* @min:%2ecreateNew */](_channels);\n          flushCtx.iterate(function (plugin) {\n            if (plugin.flush) {\n              waiting++;\n              var handled_1 = false;\n              // Not all channels will call this callback for every scenario\n              if (!plugin.flush(isAsync, function () {\n                handled_1 = true;\n                doCallback();\n              }, sendReason)) {\n                if (!handled_1) {\n                  // If any channel doesn't return true and it didn't call the callback, then we should assume that the callback\n                  // will never be called, so use a timeout to allow the channel(s) some time to \"finish\" before triggering any\n                  // followup function (such as unloading)\n                  if (isAsync && cbTimer == null) {\n                    cbTimer = scheduleTimeout(function () {\n                      cbTimer = null;\n                      doCallback();\n                    }, cbTimeout);\n                  } else {\n                    doCallback();\n                  }\n                }\n              }\n            }\n          });\n        }\n        doneIterating = true;\n        doCallback();\n        return true;\n      }\n      function _initPerfManager() {\n        // Save the previous config based performance manager creator to avoid creating new perf manager instances if unchanged\n        var prevCfgPerfMgr;\n        // Will get recalled if any referenced config values are changed\n        _addUnloadHook(_configHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\n          var enablePerfMgr = details.cfg.enablePerfMgr;\n          if (enablePerfMgr) {\n            var createPerfMgr = details.cfg[STR_CREATE_PERF_MGR /* @min:%2ecreatePerfMgr */];\n            if (prevCfgPerfMgr !== createPerfMgr) {\n              if (!createPerfMgr) {\n                createPerfMgr = _createPerfManager;\n              }\n              // Set the performance manager creation function if not defined\n              getSetValue(details.cfg, STR_CREATE_PERF_MGR, createPerfMgr);\n              prevCfgPerfMgr = createPerfMgr;\n              // Remove any existing config based performance manager\n              _cfgPerfManager = null;\n            }\n            // Only create the performance manager if it's not already created or manually set\n            if (!_perfManager && !_cfgPerfManager && isFunction(createPerfMgr)) {\n              // Create a new config based performance manager\n              _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]());\n            }\n          } else {\n            // Remove any existing config based performance manager\n            _cfgPerfManager = null;\n            // Clear the previous cached value so it can be GC'd\n            prevCfgPerfMgr = null;\n          }\n        }));\n      }\n      function _doUpdate(updateState) {\n        var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);\n        updateCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](_startLogPoller);\n        if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {\n          updateCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);\n        }\n      }\n      function _logOrThrowError(message) {\n        var logger = _self[_DYN_LOGGER /* @min:%2elogger */];\n        if (logger) {\n          // there should always be a logger\n          _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, message);\n          _startLogPoller();\n        } else {\n          throwError(message);\n        }\n      }\n      function _notifyInvalidEvent(telemetryItem) {\n        var manager = _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]();\n        if (manager) {\n          manager[STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */]([telemetryItem], 2 /* eEventsDiscardedReason.InvalidEvent */);\n        }\n      }\n      function _addUnloadHook(hooks) {\n        _hookContainer.add(hooks);\n      }\n    });\n  }\n  // Removed Stub for AppInsightsCore.prototype.initialize.\n  // Removed Stub for AppInsightsCore.prototype.getChannels.\n  // Removed Stub for AppInsightsCore.prototype.track.\n  // Removed Stub for AppInsightsCore.prototype.getProcessTelContext.\n  // Removed Stub for AppInsightsCore.prototype.getNotifyMgr.\n  // Removed Stub for AppInsightsCore.prototype.addNotificationListener.\n  // Removed Stub for AppInsightsCore.prototype.removeNotificationListener.\n  // Removed Stub for AppInsightsCore.prototype.getCookieMgr.\n  // Removed Stub for AppInsightsCore.prototype.setCookieMgr.\n  // Removed Stub for AppInsightsCore.prototype.getPerfMgr.\n  // Removed Stub for AppInsightsCore.prototype.setPerfMgr.\n  // Removed Stub for AppInsightsCore.prototype.eventCnt.\n  // Removed Stub for AppInsightsCore.prototype.pollInternalLogs.\n  // Removed Stub for AppInsightsCore.prototype.stopPollingInternalLogs.\n  // Removed Stub for AppInsightsCore.prototype.addTelemetryInitializer.\n  // Removed Stub for AppInsightsCore.prototype.unload.\n  // Removed Stub for AppInsightsCore.prototype.getPlugin.\n  // Removed Stub for AppInsightsCore.prototype.addPlugin.\n  // Removed Stub for AppInsightsCore.prototype.updateCfg.\n  // Removed Stub for AppInsightsCore.prototype.evtNamespace.\n  // Removed Stub for AppInsightsCore.prototype.addUnloadCb.\n  // Removed Stub for AppInsightsCore.prototype.flush.\n  // Removed Stub for AppInsightsCore.prototype.getTraceCtx.\n  // Removed Stub for AppInsightsCore.prototype.setTraceCtx.\n  // Removed Stub for AppInsightsCore.prototype.addUnloadHook.\n  // Removed Stub for AppInsightsCore.prototype.onCfgChange.\n  // Removed Stub for AppInsightsCore.prototype.activeStatus.\n  // Removed Stub for AppInsightsCore.prototype._setPendingStatus.\n  // Removed Stub for AppInsightsCore.prototype.releaseQueue.\n  // Removed Stub for AppInsightsCore.prototype._updateHook.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  AppInsightsCore.__ieDyn = 1;\n  return AppInsightsCore;\n}();\nexport { AppInsightsCore };","map":{"version":3,"names":["_a","__spreadArrayFn","__spreadArray","dynamicProto","createAllSettledPromise","createPromise","doAwaitResponse","arrAppend","arrForEach","arrIndexOf","createTimeout","deepExtend","hasDocument","isFunction","isNullOrUndefined","isPlainObject","isPromiseLike","objDeepFreeze","objDefine","objForEachKey","objFreeze","objHasOwn","scheduleTimeout","throwError","createDynamicConfig","onConfigChange","ActiveStatus","_DYN_ADD_NOTIFICATION_LIS1","_DYN_CANCEL","_DYN_CREATE_NEW","_DYN_ENABLED","_DYN_GET_NOTIFY_MGR","_DYN_GET_PLUGIN","_DYN_GET_PROCESS_TEL_CONT2","_DYN_IDENTIFIER","_DYN_INITIALIZE","_DYN_INSTRUMENTATION_KEY","_DYN_IS_ASYNC","_DYN_IS_INITIALIZED","_DYN_I_KEY","_DYN_LENGTH","_DYN_LOGGER","_DYN_LOGGING_LEVEL_CONSOL4","_DYN_MESSAGE","_DYN_MESSAGE_ID","_DYN_NAME","_DYN_NOTIFY","_DYN_ON_COMPLETE","_DYN_POLL_INTERNAL_LOGS","_DYN_PROCESS_NEXT","_DYN_PUSH","_DYN_REMOVE_NOTIFICATION_0","_DYN_SET_DF","_DYN_SPLICE","_DYN_STOP_POLLING_INTERNA3","_DYN_TEARDOWN","_DYN_TIME","_DYN_UNLOAD","_DYN_VALUE","_DYN_VERSION","_DYN_WATCH","_DYN__INACTIVE","doUnloadAll","runTargetUnload","ChannelControllerPriority","createCookieMgr","createUniqueNamespace","getDebugListener","DiagnosticLogger","_InternalLogMessage","_throwInternal","_warnToConsole","getSetValue","isNotNullOrUndefined","proxyFunctionAs","proxyFunctions","toISOString","STR_CHANNELS","STR_CORE","STR_CREATE_PERF_MGR","STR_DISABLED","STR_EMPTY","STR_EVENTS_DISCARDED","STR_EXTENSIONS","STR_EXTENSION_CONFIG","STR_GET_PERF_MGR","STR_PRIORITY","UNDEFINED_VALUE","NotificationManager","PerfManager","doPerf","getGblPerfMgr","createProcessTelemetryContext","createProcessTelemetryUnloadContext","createProcessTelemetryUpdateContext","createTelemetryProxyChain","_getPluginState","createDistributedTraceContext","initializePlugins","sortPlugins","TelemetryInitializerPlugin","createUnloadHandlerContainer","createUnloadHookContainer","strValidationError","strNotificationManager","strSdkUnloadingError","strSdkNotInitialized","maxInitQueueSize","maxInitTimeout","defaultConfig","cookieCfg","rdOnly","ref","v","loggingLevelConsole","diagnosticLogInterval","_createPerfManager","core","notificationMgr","_validateExtensions","logger","channelPriority","allExtensions","coreExtensions","channels","extPriorities","ext","extPriority","identifier","_isPluginPresent","thePlugin","plugins","exists","plugin","_deepMergeConfig","details","target","newValues","merge","key","value","set","_findWatcher","listeners","newWatcher","theListener","idx","listener","lp","w","i","l","_addDelayedCfgListener","rm","fnd","_registerDelayedCfgListener","config","unloadHdl","_initDebugListener","configHandler","unloadContainer","notificationManager","debugListener","add","disableDbgExt","cfg","_createUnloadHook","unloadHook","JSON","stringify","AppInsightsCore","_configHandler","_isInitialized","_logger","_eventQueue","_notificationManager","_perfManager","_cfgPerfManager","_cookieManager","_pluginChain","_configExtensions","_channelConfig","_channels","_isUnloading","_telemetryInitializerPlugin","_internalLogsEventName","_evtNamespace","_unloadHandlers","_hookContainer","_debugListener","_traceCtx","_instrumentationKey","_cfgListeners","_extensions","_pluginVersionStringArr","_pluginVersionString","_activeStatus","_endpoint","_initInMemoMaxSize","_isStatusSet","_initTimer","_internalLogPoller","_internalLogPollerListening","_forceStopInternalLogPoller","_self","_initDefaults","activeStatus","_setPendingStatus","extensions","_addUnloadHook","rootCfg","isPending","initInMemoMaxSize","ikey","endpointUrl","msg","_releaseQueues","promises","initTimeout","initTimeOut","allPromises","_setStatus","response","rejected","values","ikeyRes","endpointRes","e","extCfg","_initPerfManager","cfgExtensions","apply","_initPluginChain","teeController","ACTIVE","getChannels","controls","channel","track","telemetryItem","_notifyInvalidEvent","Date","ver","_createTelCtx","item","sync","getNotifyMgr","getCookieMgr","setCookieMgr","cookieMgr","setPerfMgr","perfMgr","eventCnt","releaseQueue","eventQueue","event","eventName","_startLogPoller","alwaysStart","shouldStart","queue","interval","isRunning","_flushInternalLogs","unref","isAsync","unloadComplete","cbTimeout","unloadState","reason","flushComplete","result","resolve","processUnloadCtx","_getPluginChain","run","_doUnload","_flushChannels","_getPlugin","addPlugin","replaceExisting","addCb","_logOrThrowError","existingPlugin","updateState","_addPlugin","removed","added","removedPlugins_1","_removePlugins","updateCfg","newConfig","mergeExisting","oldCfg","_block","theConfig","_doUpdate","evtNamespace","flush","getTraceCtx","createNew","setTraceCtx","traceCtx","addUnloadHook","onCfgChange","handler","getWParam","enableWParam","_setPluginVersions","thePlugins","_addPluginVersions","g","s","newValue","join","newLogger","splice","theCtx","theExtensions","rootCtx","pluginIdentifier","theExt","channelHosts","getChannel","host","setEnabled","enabled","isEnabled","pluginState","remove","removeCb","pluginsToRemove","slice","removeComplete","unloadChain","unloadCtx","newConfigExtensions","newChannelConfig","newQueue","logMessage","baseType","dataType","baseData","message","callBack","sendReason","waiting","doneIterating","cbTimer","doCallback","flushCtx","iterate","handled_1","prevCfgPerfMgr","enablePerfMgr","createPerfMgr","updateCtx","_updateHook","manager","hooks"],"sources":["/home/veeresh133/app/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/AppInsightsCore.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nvar _a;\r\nimport { __spreadArray } from \"tslib\";\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { createAllSettledPromise, createPromise, doAwaitResponse } from \"@nevware21/ts-async\";\r\nimport { arrAppend, arrForEach, arrIndexOf, createTimeout, deepExtend, hasDocument, isFunction, isNullOrUndefined, isPlainObject, isPromiseLike, objDeepFreeze, objDefine, objForEachKey, objFreeze, objHasOwn, scheduleTimeout, throwError } from \"@nevware21/ts-utils\";\r\nimport { createDynamicConfig, onConfigChange } from \"../Config/DynamicConfig\";\r\nimport { ActiveStatus } from \"../JavaScriptSDK.Enums/InitActiveStatusEnum\";\r\nimport { _DYN_ADD_NOTIFICATION_LIS1, _DYN_CANCEL, _DYN_CREATE_NEW, _DYN_ENABLED, _DYN_GET_NOTIFY_MGR, _DYN_GET_PLUGIN, _DYN_GET_PROCESS_TEL_CONT2, _DYN_IDENTIFIER, _DYN_INITIALIZE, _DYN_INSTRUMENTATION_KEY, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_I_KEY, _DYN_LENGTH, _DYN_LOGGER, _DYN_LOGGING_LEVEL_CONSOL4, _DYN_MESSAGE, _DYN_MESSAGE_ID, _DYN_NAME, _DYN_NOTIFY, _DYN_ON_COMPLETE, _DYN_POLL_INTERNAL_LOGS, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_REMOVE_NOTIFICATION_0, _DYN_SET_DF, _DYN_SPLICE, _DYN_STOP_POLLING_INTERNA3, _DYN_TEARDOWN, _DYN_TIME, _DYN_UNLOAD, _DYN_VALUE, _DYN_VERSION, _DYN_WATCH, _DYN__INACTIVE } from \"../__DynamicConstants\";\r\nimport { doUnloadAll, runTargetUnload } from \"./AsyncUtils\";\r\nimport { ChannelControllerPriority } from \"./Constants\";\r\nimport { createCookieMgr } from \"./CookieMgr\";\r\nimport { createUniqueNamespace } from \"./DataCacheHelper\";\r\nimport { getDebugListener } from \"./DbgExtensionUtils\";\r\nimport { DiagnosticLogger, _InternalLogMessage, _throwInternal, _warnToConsole } from \"./DiagnosticLogger\";\r\nimport { getSetValue, isNotNullOrUndefined, proxyFunctionAs, proxyFunctions, toISOString } from \"./HelperFuncs\";\r\nimport { STR_CHANNELS, STR_CORE, STR_CREATE_PERF_MGR, STR_DISABLED, STR_EMPTY, STR_EVENTS_DISCARDED, STR_EXTENSIONS, STR_EXTENSION_CONFIG, STR_GET_PERF_MGR, STR_PRIORITY, UNDEFINED_VALUE } from \"./InternalConstants\";\r\nimport { NotificationManager } from \"./NotificationManager\";\r\nimport { PerfManager, doPerf, getGblPerfMgr } from \"./PerfManager\";\r\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext, createTelemetryProxyChain } from \"./ProcessTelemetryContext\";\r\nimport { _getPluginState, createDistributedTraceContext, initializePlugins, sortPlugins } from \"./TelemetryHelpers\";\r\nimport { TelemetryInitializerPlugin } from \"./TelemetryInitializerPlugin\";\r\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\r\nimport { createUnloadHookContainer } from \"./UnloadHookContainer\";\r\nvar strValidationError = \"Plugins must provide initialize method\";\r\nvar strNotificationManager = \"_notificationManager\";\r\nvar strSdkUnloadingError = \"SDK is still unloading...\";\r\nvar strSdkNotInitialized = \"SDK is not initialized\";\r\nvar maxInitQueueSize = 100;\r\nvar maxInitTimeout = 50000;\r\n// const strPluginUnloadFailed = \"Failed to unload plugin\";\r\n/**\r\n * The default settings for the config.\r\n * WE MUST include all defaults here to ensure that the config is created with all of the properties\r\n * defined as dynamic.\r\n */\r\nvar defaultConfig = objDeepFreeze((_a = {\r\n        cookieCfg: {}\r\n    },\r\n    _a[STR_EXTENSIONS] = { rdOnly: true, ref: true, v: [] },\r\n    _a[STR_CHANNELS] = { rdOnly: true, ref: true, v: [] },\r\n    _a[STR_EXTENSION_CONFIG] = { ref: true, v: {} },\r\n    _a[STR_CREATE_PERF_MGR] = UNDEFINED_VALUE,\r\n    _a.loggingLevelConsole = 0 /* eLoggingSeverity.DISABLED */,\r\n    _a.diagnosticLogInterval = UNDEFINED_VALUE,\r\n    _a));\r\n/**\r\n * Helper to create the default performance manager\r\n * @param core\r\n * @param notificationMgr\r\n */\r\nfunction _createPerfManager(core, notificationMgr) {\r\n    return new PerfManager(notificationMgr);\r\n}\r\nfunction _validateExtensions(logger, channelPriority, allExtensions) {\r\n    var _a;\r\n    // Concat all available extensions\r\n    var coreExtensions = [];\r\n    var channels = [];\r\n    // Check if any two extensions have the same priority, then warn to console\r\n    // And extract the local extensions from the\r\n    var extPriorities = {};\r\n    // Extension validation\r\n    arrForEach(allExtensions, function (ext) {\r\n        // Check for ext.initialize\r\n        if (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE /* @min:%2einitialize */])) {\r\n            throwError(strValidationError);\r\n        }\r\n        var extPriority = ext[STR_PRIORITY /* @min:%2epriority */];\r\n        var identifier = ext[_DYN_IDENTIFIER /* @min:%2eidentifier */];\r\n        if (ext && extPriority) {\r\n            if (!isNullOrUndefined(extPriorities[extPriority])) {\r\n                _warnToConsole(logger, \"Two extensions have same priority #\" + extPriority + \" - \" + extPriorities[extPriority] + \", \" + identifier);\r\n            }\r\n            else {\r\n                // set a value\r\n                extPriorities[extPriority] = identifier;\r\n            }\r\n        }\r\n        // Split extensions to core and channels\r\n        if (!extPriority || extPriority < channelPriority) {\r\n            // Add to core extension that will be managed by AppInsightsCore\r\n            coreExtensions[_DYN_PUSH /* @min:%2epush */](ext);\r\n        }\r\n        else {\r\n            channels[_DYN_PUSH /* @min:%2epush */](ext);\r\n        }\r\n    });\r\n    return _a = {},\r\n        _a[STR_CORE /* @min:core */] = coreExtensions,\r\n        _a[STR_CHANNELS /* @min:channels */] = channels,\r\n        _a;\r\n}\r\nfunction _isPluginPresent(thePlugin, plugins) {\r\n    var exists = false;\r\n    arrForEach(plugins, function (plugin) {\r\n        if (plugin === thePlugin) {\r\n            exists = true;\r\n            return -1;\r\n        }\r\n    });\r\n    return exists;\r\n}\r\nfunction _deepMergeConfig(details, target, newValues, merge) {\r\n    // Lets assign the new values to the existing config\r\n    if (newValues) {\r\n        objForEachKey(newValues, function (key, value) {\r\n            if (merge) {\r\n                if (isPlainObject(value) && isPlainObject(target[key])) {\r\n                    // The target is an object and it has a value\r\n                    _deepMergeConfig(details, target[key], value, merge);\r\n                }\r\n            }\r\n            if (merge && isPlainObject(value) && isPlainObject(target[key])) {\r\n                // The target is an object and it has a value\r\n                _deepMergeConfig(details, target[key], value, merge);\r\n            }\r\n            else {\r\n                // Just Assign (replace) and/or make the property dynamic\r\n                details.set(target, key, value);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction _findWatcher(listeners, newWatcher) {\r\n    var theListener = null;\r\n    var idx = -1;\r\n    arrForEach(listeners, function (listener, lp) {\r\n        if (listener.w === newWatcher) {\r\n            theListener = listener;\r\n            idx = lp;\r\n            return -1;\r\n        }\r\n    });\r\n    return { i: idx, l: theListener };\r\n}\r\nfunction _addDelayedCfgListener(listeners, newWatcher) {\r\n    var theListener = _findWatcher(listeners, newWatcher).l;\r\n    if (!theListener) {\r\n        theListener = {\r\n            w: newWatcher,\r\n            rm: function () {\r\n                var fnd = _findWatcher(listeners, newWatcher);\r\n                if (fnd.i !== -1) {\r\n                    listeners[_DYN_SPLICE /* @min:%2esplice */](fnd.i, 1);\r\n                }\r\n            }\r\n        };\r\n        listeners[_DYN_PUSH /* @min:%2epush */](theListener);\r\n    }\r\n    return theListener;\r\n}\r\nfunction _registerDelayedCfgListener(config, listeners, logger) {\r\n    arrForEach(listeners, function (listener) {\r\n        var unloadHdl = onConfigChange(config, listener.w, logger);\r\n        delete listener.w; // Clear the listener reference so it will get garbage collected.\r\n        // replace the remove function\r\n        listener.rm = function () {\r\n            unloadHdl.rm();\r\n        };\r\n    });\r\n}\r\n// Moved this outside of the closure to reduce the retained memory footprint\r\nfunction _initDebugListener(configHandler, unloadContainer, notificationManager, debugListener) {\r\n    // Will get recalled if any referenced config values are changed\r\n    unloadContainer.add(configHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\r\n        var disableDbgExt = details.cfg.disableDbgExt;\r\n        if (disableDbgExt === true && debugListener) {\r\n            // Remove any previously loaded debug listener\r\n            notificationManager[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */](debugListener);\r\n            debugListener = null;\r\n        }\r\n        if (notificationManager && !debugListener && disableDbgExt !== true) {\r\n            debugListener = getDebugListener(details.cfg);\r\n            notificationManager[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](debugListener);\r\n        }\r\n    }));\r\n    return debugListener;\r\n}\r\n// Moved this outside of the closure to reduce the retained memory footprint\r\nfunction _createUnloadHook(unloadHook) {\r\n    return objDefine({\r\n        rm: function () {\r\n            unloadHook.rm();\r\n        }\r\n    }, \"toJSON\", { v: function () { return \"aicore::onCfgChange<\" + JSON.stringify(unloadHook) + \">\"; } });\r\n}\r\n/**\r\n * @group Classes\r\n * @group Entrypoint\r\n */\r\nvar AppInsightsCore = /** @class */ (function () {\r\n    function AppInsightsCore() {\r\n        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\r\n        var _configHandler;\r\n        var _isInitialized;\r\n        var _logger;\r\n        var _eventQueue;\r\n        var _notificationManager;\r\n        var _perfManager;\r\n        var _cfgPerfManager;\r\n        var _cookieManager;\r\n        var _pluginChain;\r\n        var _configExtensions;\r\n        var _channelConfig;\r\n        var _channels;\r\n        var _isUnloading;\r\n        var _telemetryInitializerPlugin;\r\n        var _internalLogsEventName;\r\n        var _evtNamespace;\r\n        var _unloadHandlers;\r\n        var _hookContainer;\r\n        var _debugListener;\r\n        var _traceCtx;\r\n        var _instrumentationKey;\r\n        var _cfgListeners;\r\n        var _extensions;\r\n        var _pluginVersionStringArr;\r\n        var _pluginVersionString;\r\n        var _activeStatus; // to indicate if ikey or endpoint url promised is resolved or not\r\n        var _endpoint;\r\n        var _initInMemoMaxSize; // max event count limit during wait for init promises to be resolved\r\n        var _isStatusSet; // track if active status is set in case of init timeout and init promises setting the status twice\r\n        var _initTimer;\r\n        /**\r\n         * Internal log poller\r\n         */\r\n        var _internalLogPoller;\r\n        var _internalLogPollerListening;\r\n        var _forceStopInternalLogPoller;\r\n        dynamicProto(AppInsightsCore, this, function (_self) {\r\n            // Set the default values (also called during teardown)\r\n            _initDefaults();\r\n            // Special internal method to allow the unit tests and DebugPlugin to hook embedded objects\r\n            _self[\"_getDbgPlgTargets\"] = function () {\r\n                return [_extensions, _eventQueue];\r\n            };\r\n            _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () { return _isInitialized; };\r\n            // since version 3.3.0\r\n            _self.activeStatus = function () { return _activeStatus; };\r\n            // since version 3.3.0\r\n            // internal\r\n            _self._setPendingStatus = function () {\r\n                _activeStatus = 3 /* eActiveStatus.PENDING */;\r\n            };\r\n            // Creating the self.initialize = ()\r\n            _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, extensions, logger, notificationManager) {\r\n                if (_isUnloading) {\r\n                    throwError(strSdkUnloadingError);\r\n                }\r\n                // Make sure core is only initialized once\r\n                if (_self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\r\n                    throwError(\"Core cannot be initialized more than once\");\r\n                }\r\n                _configHandler = createDynamicConfig(config, defaultConfig, logger || _self[_DYN_LOGGER /* @min:%2elogger */], false);\r\n                // Re-assigning the local config property so we don't have any references to the passed value and it can be garbage collected\r\n                config = _configHandler.cfg;\r\n                // This will be \"re-run\" if the referenced config properties are changed\r\n                _addUnloadHook(_configHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\r\n                    var rootCfg = details.cfg;\r\n                    var isPending = _activeStatus === 3 /* eActiveStatus.PENDING */;\r\n                    if (isPending) {\r\n                        // means waiting for previous promises to be resolved, won't apply new changes\r\n                        return;\r\n                    }\r\n                    _initInMemoMaxSize = rootCfg.initInMemoMaxSize || maxInitQueueSize;\r\n                    // app Insights core only handle ikey and endpointurl, aisku will handle cs\r\n                    var ikey = rootCfg[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */];\r\n                    var endpointUrl = rootCfg.endpointUrl; // do not need to validate endpoint url, if it is null, default one will be set by sender\r\n                    if (isNullOrUndefined(ikey)) {\r\n                        _instrumentationKey = null;\r\n                        // if new ikey is null, set status to be inactive, all new events will be saved in memory or dropped\r\n                        _activeStatus = ActiveStatus[_DYN__INACTIVE /* @min:%2eINACTIVE */];\r\n                        var msg = \"Please provide instrumentation key\";\r\n                        if (!_isInitialized) {\r\n                            // only throw error during initialization\r\n                            throwError(msg);\r\n                        }\r\n                        else {\r\n                            _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 100 /* _eInternalMessageId.InvalidInstrumentationKey */, msg);\r\n                            _releaseQueues();\r\n                        }\r\n                        return;\r\n                    }\r\n                    var promises = [];\r\n                    if (isPromiseLike(ikey)) {\r\n                        promises[_DYN_PUSH /* @min:%2epush */](ikey);\r\n                        _instrumentationKey = null; // reset current local ikey variable (otherwise it will always be the previous ikeys if timeout is called before promise cb)\r\n                    }\r\n                    else {\r\n                        // string\r\n                        _instrumentationKey = ikey;\r\n                    }\r\n                    if (isPromiseLike(endpointUrl)) {\r\n                        promises[_DYN_PUSH /* @min:%2epush */](endpointUrl);\r\n                        _endpoint = null; // reset current local endpoint variable (otherwise it will always be the previous urls if timeout is called before promise cb)\r\n                    }\r\n                    else {\r\n                        // string or null\r\n                        _endpoint = endpointUrl;\r\n                    }\r\n                    // at least have one promise\r\n                    if (promises[_DYN_LENGTH /* @min:%2elength */]) {\r\n                        // reset to false for new dynamic changes\r\n                        _isStatusSet = false;\r\n                        _activeStatus = 3 /* eActiveStatus.PENDING */;\r\n                        var initTimeout = isNotNullOrUndefined(rootCfg.initTimeOut) ? rootCfg.initTimeOut : maxInitTimeout; // rootCfg.initTimeOut could be 0\r\n                        var allPromises = createAllSettledPromise(promises);\r\n                        _initTimer = scheduleTimeout(function () {\r\n                            // set _isStatusSet to true\r\n                            // set active status\r\n                            // release queues\r\n                            _initTimer = null;\r\n                            if (!_isStatusSet) {\r\n                                _setStatus();\r\n                            }\r\n                        }, initTimeout);\r\n                        doAwaitResponse(allPromises, function (response) {\r\n                            try {\r\n                                if (_isStatusSet) {\r\n                                    // promises take too long to resolve, ignore them\r\n                                    // active status should be set by timeout already\r\n                                    return;\r\n                                }\r\n                                if (!response.rejected) {\r\n                                    var values = response[_DYN_VALUE /* @min:%2evalue */];\r\n                                    if (values && values[_DYN_LENGTH /* @min:%2elength */]) {\r\n                                        // ikey\r\n                                        var ikeyRes = values[0];\r\n                                        _instrumentationKey = ikeyRes && ikeyRes[_DYN_VALUE /* @min:%2evalue */];\r\n                                        // endpoint\r\n                                        if (values[_DYN_LENGTH /* @min:%2elength */] > 1) {\r\n                                            var endpointRes = values[1];\r\n                                            _endpoint = endpointRes && endpointRes[_DYN_VALUE /* @min:%2evalue */];\r\n                                        }\r\n                                    }\r\n                                    if (_instrumentationKey) {\r\n                                        // if ikey is null, no need to trigger extra dynamic changes for extensions\r\n                                        config[_DYN_INSTRUMENTATION_KEY /* @min:%2einstrumentationKey */] = _instrumentationKey; // set config.instrumentationKey for extensions to consume\r\n                                        config.endpointUrl = _endpoint; // set config.endpointUrl for extensions to consume\r\n                                    }\r\n                                }\r\n                                // set _isStatusSet to true\r\n                                // set active status\r\n                                // release queues\r\n                                _setStatus();\r\n                            }\r\n                            catch (e) {\r\n                                if (!_isStatusSet) {\r\n                                    _setStatus();\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        // means no promises\r\n                        _setStatus();\r\n                    }\r\n                    //_instrumentationKey = details.cfg.instrumentationKey;\r\n                    // Mark the extensionConfig and all first level keys as referenced\r\n                    // This is so that calls to getExtCfg() will always return the same object\r\n                    // Even when a user may \"re-assign\" the plugin properties (or it's unloaded/reloaded)\r\n                    var extCfg = details.ref(details.cfg, STR_EXTENSION_CONFIG);\r\n                    objForEachKey(extCfg, function (key) {\r\n                        details.ref(extCfg, key);\r\n                    });\r\n                }));\r\n                _notificationManager = notificationManager;\r\n                // Initialize the debug listener outside of the closure to reduce the retained memory footprint\r\n                _debugListener = _initDebugListener(_configHandler, _hookContainer, _notificationManager && _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */](), _debugListener);\r\n                _initPerfManager();\r\n                _self[_DYN_LOGGER /* @min:%2elogger */] = logger;\r\n                var cfgExtensions = config[STR_EXTENSIONS /* @min:%2eextensions */];\r\n                // Extension validation\r\n                _configExtensions = [];\r\n                _configExtensions[_DYN_PUSH /* @min:%2epush */].apply(_configExtensions, __spreadArray(__spreadArray([], extensions, false), cfgExtensions, false));\r\n                _channelConfig = config[STR_CHANNELS /* @min:%2echannels */];\r\n                _initPluginChain(null);\r\n                if (!_channels || _channels[_DYN_LENGTH /* @min:%2elength */] === 0) {\r\n                    throwError(\"No \" + STR_CHANNELS + \" available\");\r\n                }\r\n                if (_channelConfig && _channelConfig[_DYN_LENGTH /* @min:%2elength */] > 1) {\r\n                    var teeController = _self[_DYN_GET_PLUGIN /* @min:%2egetPlugin */](\"TeeChannelController\");\r\n                    if (!teeController || !teeController.plugin) {\r\n                        _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 28 /* _eInternalMessageId.SenderNotInitialized */, \"TeeChannel required\");\r\n                    }\r\n                }\r\n                _registerDelayedCfgListener(config, _cfgListeners, _logger);\r\n                _cfgListeners = null;\r\n                _isInitialized = true;\r\n                if (_activeStatus === ActiveStatus.ACTIVE) {\r\n                    _releaseQueues();\r\n                }\r\n            };\r\n            _self.getChannels = function () {\r\n                var controls = [];\r\n                if (_channels) {\r\n                    arrForEach(_channels, function (channel) {\r\n                        controls[_DYN_PUSH /* @min:%2epush */](channel);\r\n                    });\r\n                }\r\n                return objFreeze(controls);\r\n            };\r\n            _self.track = function (telemetryItem) {\r\n                doPerf(_self[STR_GET_PERF_MGR /* @min:%2egetPerfMgr */](), function () { return \"AppInsightsCore:track\"; }, function () {\r\n                    if (telemetryItem === null) {\r\n                        _notifyInvalidEvent(telemetryItem);\r\n                        // throw error\r\n                        throwError(\"Invalid telemetry item\");\r\n                    }\r\n                    // do basic validation before sending it through the pipeline\r\n                    if (!telemetryItem[_DYN_NAME /* @min:%2ename */] && isNullOrUndefined(telemetryItem[_DYN_NAME /* @min:%2ename */])) {\r\n                        _notifyInvalidEvent(telemetryItem);\r\n                        throwError(\"telemetry name required\");\r\n                    }\r\n                    // setup default iKey if not passed in\r\n                    telemetryItem[_DYN_I_KEY /* @min:%2eiKey */] = telemetryItem[_DYN_I_KEY /* @min:%2eiKey */] || _instrumentationKey;\r\n                    // add default timestamp if not passed in\r\n                    telemetryItem[_DYN_TIME /* @min:%2etime */] = telemetryItem[_DYN_TIME /* @min:%2etime */] || toISOString(new Date());\r\n                    // Common Schema 4.0\r\n                    telemetryItem.ver = telemetryItem.ver || \"4.0\";\r\n                    if (!_isUnloading && _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]() && _activeStatus === ActiveStatus.ACTIVE) {\r\n                        // Process the telemetry plugin chain\r\n                        _createTelCtx()[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](telemetryItem);\r\n                    }\r\n                    else if (_activeStatus !== ActiveStatus[_DYN__INACTIVE /* @min:%2eINACTIVE */]) {\r\n                        // Queue events until all extensions are initialized\r\n                        if (_eventQueue[_DYN_LENGTH /* @min:%2elength */] <= _initInMemoMaxSize) {\r\n                            // set limit, if full, stop adding new events\r\n                            _eventQueue[_DYN_PUSH /* @min:%2epush */](telemetryItem);\r\n                        }\r\n                    }\r\n                }, function () { return ({ item: telemetryItem }); }, !(telemetryItem.sync));\r\n            };\r\n            _self[_DYN_GET_PROCESS_TEL_CONT2 /* @min:%2egetProcessTelContext */] = _createTelCtx;\r\n            _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */] = function () {\r\n                if (!_notificationManager) {\r\n                    _notificationManager = new NotificationManager(_configHandler.cfg);\r\n                    // For backward compatibility only\r\n                    _self[strNotificationManager] = _notificationManager;\r\n                }\r\n                return _notificationManager;\r\n            };\r\n            /**\r\n             * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.\r\n             * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be\r\n             * called.\r\n             * @param listener - An INotificationListener object.\r\n             */\r\n            _self[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {\r\n                _self.getNotifyMgr()[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */](listener);\r\n            };\r\n            /**\r\n             * Removes all instances of the listener.\r\n             * @param listener - INotificationListener to remove.\r\n             */\r\n            _self[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {\r\n                if (_notificationManager) {\r\n                    _notificationManager[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */](listener);\r\n                }\r\n            };\r\n            _self.getCookieMgr = function () {\r\n                if (!_cookieManager) {\r\n                    _cookieManager = createCookieMgr(_configHandler.cfg, _self[_DYN_LOGGER /* @min:%2elogger */]);\r\n                }\r\n                return _cookieManager;\r\n            };\r\n            _self.setCookieMgr = function (cookieMgr) {\r\n                if (_cookieManager !== cookieMgr) {\r\n                    runTargetUnload(_cookieManager, false);\r\n                    _cookieManager = cookieMgr;\r\n                }\r\n            };\r\n            _self[STR_GET_PERF_MGR /* @min:%2egetPerfMgr */] = function () {\r\n                return _perfManager || _cfgPerfManager || getGblPerfMgr();\r\n            };\r\n            _self.setPerfMgr = function (perfMgr) {\r\n                _perfManager = perfMgr;\r\n            };\r\n            _self.eventCnt = function () {\r\n                return _eventQueue[_DYN_LENGTH /* @min:%2elength */];\r\n            };\r\n            _self.releaseQueue = function () {\r\n                if (_isInitialized && _eventQueue[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    var eventQueue = _eventQueue;\r\n                    _eventQueue = [];\r\n                    if (_activeStatus === 2 /* eActiveStatus.ACTIVE */) {\r\n                        arrForEach(eventQueue, function (event) {\r\n                            event[_DYN_I_KEY /* @min:%2eiKey */] = event[_DYN_I_KEY /* @min:%2eiKey */] || _instrumentationKey;\r\n                            _createTelCtx()[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](event);\r\n                        });\r\n                    }\r\n                    else {\r\n                        // new one for msg ikey\r\n                        _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 20 /* _eInternalMessageId.FailedToSendQueuedTelemetry */, \"core init status is not active\");\r\n                    }\r\n                }\r\n            };\r\n            _self[_DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */] = function (eventName) {\r\n                _internalLogsEventName = eventName || null;\r\n                _forceStopInternalLogPoller = false;\r\n                _internalLogPoller && _internalLogPoller[_DYN_CANCEL /* @min:%2ecancel */]();\r\n                return _startLogPoller(true);\r\n            };\r\n            function _setStatus() {\r\n                _isStatusSet = true;\r\n                if (isNullOrUndefined(_instrumentationKey)) {\r\n                    _activeStatus = ActiveStatus[_DYN__INACTIVE /* @min:%2eINACTIVE */];\r\n                    _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 112 /* _eInternalMessageId.InitPromiseException */, \"ikey can't be resolved from promises\");\r\n                }\r\n                else {\r\n                    _activeStatus = ActiveStatus.ACTIVE;\r\n                }\r\n                _releaseQueues();\r\n            }\r\n            function _releaseQueues() {\r\n                if (_isInitialized) {\r\n                    _self.releaseQueue();\r\n                    _self[_DYN_POLL_INTERNAL_LOGS /* @min:%2epollInternalLogs */]();\r\n                }\r\n            }\r\n            function _startLogPoller(alwaysStart) {\r\n                if ((!_internalLogPoller || !_internalLogPoller[_DYN_ENABLED /* @min:%2eenabled */]) && !_forceStopInternalLogPoller) {\r\n                    var shouldStart = alwaysStart || (_logger && _logger.queue[_DYN_LENGTH /* @min:%2elength */] > 0);\r\n                    if (shouldStart) {\r\n                        if (!_internalLogPollerListening) {\r\n                            _internalLogPollerListening = true;\r\n                            // listen for any configuration changes so that changes to the\r\n                            // interval will cause the timer to be re-initialized\r\n                            _addUnloadHook(_configHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\r\n                                var interval = details.cfg.diagnosticLogInterval;\r\n                                if (!interval || !(interval > 0)) {\r\n                                    interval = 10000;\r\n                                }\r\n                                var isRunning = false;\r\n                                if (_internalLogPoller) {\r\n                                    // It was already created so remember it's running and cancel\r\n                                    isRunning = _internalLogPoller[_DYN_ENABLED /* @min:%2eenabled */];\r\n                                    _internalLogPoller[_DYN_CANCEL /* @min:%2ecancel */]();\r\n                                }\r\n                                // Create / reconfigure\r\n                                _internalLogPoller = createTimeout(_flushInternalLogs, interval);\r\n                                _internalLogPoller.unref();\r\n                                // Restart if previously running\r\n                                _internalLogPoller[_DYN_ENABLED /* @min:%2eenabled */] = isRunning;\r\n                            }));\r\n                        }\r\n                        _internalLogPoller[_DYN_ENABLED /* @min:%2eenabled */] = true;\r\n                    }\r\n                }\r\n                return _internalLogPoller;\r\n            }\r\n            _self[_DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */] = function () {\r\n                _forceStopInternalLogPoller = true;\r\n                _internalLogPoller && _internalLogPoller[_DYN_CANCEL /* @min:%2ecancel */]();\r\n                _flushInternalLogs();\r\n            };\r\n            // Add addTelemetryInitializer\r\n            proxyFunctions(_self, function () { return _telemetryInitializerPlugin; }, [\"addTelemetryInitializer\"]);\r\n            _self[_DYN_UNLOAD /* @min:%2eunload */] = function (isAsync, unloadComplete, cbTimeout) {\r\n                var _a;\r\n                if (isAsync === void 0) { isAsync = true; }\r\n                if (!_isInitialized) {\r\n                    // The SDK is not initialized\r\n                    throwError(strSdkNotInitialized);\r\n                }\r\n                // Check if the SDK still unloading so throw\r\n                if (_isUnloading) {\r\n                    // The SDK is already unloading\r\n                    throwError(strSdkUnloadingError);\r\n                }\r\n                var unloadState = (_a = {\r\n                        reason: 50 /* TelemetryUnloadReason.SdkUnload */\r\n                    },\r\n                    _a[_DYN_IS_ASYNC /* @min:isAsync */] = isAsync,\r\n                    _a.flushComplete = false,\r\n                    _a);\r\n                var result;\r\n                if (isAsync && !unloadComplete) {\r\n                    result = createPromise(function (resolve) {\r\n                        // Set the callback to the promise resolve callback\r\n                        unloadComplete = resolve;\r\n                    });\r\n                }\r\n                var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);\r\n                processUnloadCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {\r\n                    _hookContainer.run(_self[_DYN_LOGGER /* @min:%2elogger */]);\r\n                    // Run any \"unload\" functions for the _cookieManager, _notificationManager and _logger\r\n                    doUnloadAll([_cookieManager, _notificationManager, _logger], isAsync, function () {\r\n                        _initDefaults();\r\n                        unloadComplete && unloadComplete(unloadState);\r\n                    });\r\n                }, _self);\r\n                function _doUnload(flushComplete) {\r\n                    unloadState.flushComplete = flushComplete;\r\n                    _isUnloading = true;\r\n                    // Run all of the unload handlers first (before unloading the plugins)\r\n                    _unloadHandlers.run(processUnloadCtx, unloadState);\r\n                    // Stop polling the internal logs\r\n                    _self[_DYN_STOP_POLLING_INTERNA3 /* @min:%2estopPollingInternalLogs */]();\r\n                    // Start unloading the components, from this point onwards the SDK should be considered to be in an unstable state\r\n                    processUnloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\r\n                }\r\n                _flushInternalLogs();\r\n                if (!_flushChannels(isAsync, _doUnload, 6 /* SendRequestReason.SdkUnload */, cbTimeout)) {\r\n                    _doUnload(false);\r\n                }\r\n                return result;\r\n            };\r\n            _self[_DYN_GET_PLUGIN /* @min:%2egetPlugin */] = _getPlugin;\r\n            _self.addPlugin = function (plugin, replaceExisting, isAsync, addCb) {\r\n                if (!plugin) {\r\n                    addCb && addCb(false);\r\n                    _logOrThrowError(strValidationError);\r\n                    return;\r\n                }\r\n                var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */]);\r\n                if (existingPlugin && !replaceExisting) {\r\n                    addCb && addCb(false);\r\n                    _logOrThrowError(\"Plugin [\" + plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"] is already loaded!\");\r\n                    return;\r\n                }\r\n                var updateState = {\r\n                    reason: 16 /* TelemetryUpdateReason.PluginAdded */\r\n                };\r\n                function _addPlugin(removed) {\r\n                    _configExtensions[_DYN_PUSH /* @min:%2epush */](plugin);\r\n                    updateState.added = [plugin];\r\n                    // Re-Initialize the plugin chain\r\n                    _initPluginChain(updateState);\r\n                    addCb && addCb(true);\r\n                }\r\n                if (existingPlugin) {\r\n                    var removedPlugins_1 = [existingPlugin.plugin];\r\n                    var unloadState = {\r\n                        reason: 2 /* TelemetryUnloadReason.PluginReplace */,\r\n                        isAsync: !!isAsync\r\n                    };\r\n                    _removePlugins(removedPlugins_1, unloadState, function (removed) {\r\n                        if (!removed) {\r\n                            // Previous plugin was successfully removed or was not installed\r\n                            addCb && addCb(false);\r\n                        }\r\n                        else {\r\n                            updateState.removed = removedPlugins_1;\r\n                            updateState.reason |= 32 /* TelemetryUpdateReason.PluginRemoved */;\r\n                            _addPlugin(true);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    _addPlugin(false);\r\n                }\r\n            };\r\n            _self.updateCfg = function (newConfig, mergeExisting) {\r\n                if (mergeExisting === void 0) { mergeExisting = true; }\r\n                var updateState;\r\n                if (_self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]()) {\r\n                    updateState = {\r\n                        reason: 1 /* TelemetryUpdateReason.ConfigurationChanged */,\r\n                        cfg: _configHandler.cfg,\r\n                        oldCfg: deepExtend({}, _configHandler.cfg),\r\n                        newConfig: deepExtend({}, newConfig),\r\n                        merge: mergeExisting\r\n                    };\r\n                    newConfig = updateState.newConfig;\r\n                    var cfg = _configHandler.cfg;\r\n                    // replace the immutable (if initialized) values\r\n                    // We don't currently allow updating the extensions and channels via the update config\r\n                    // So overwriting any user provided values to reuse the existing values\r\n                    newConfig[STR_EXTENSIONS /* @min:%2eextensions */] = cfg[STR_EXTENSIONS /* @min:%2eextensions */];\r\n                    newConfig[STR_CHANNELS /* @min:%2echannels */] = cfg[STR_CHANNELS /* @min:%2echannels */];\r\n                }\r\n                // Explicitly blocking any previous config watchers so that they don't get called because\r\n                // of this bulk update (Probably not necessary)\r\n                _configHandler._block(function (details) {\r\n                    // Lets assign the new values to the existing config either overwriting or re-assigning\r\n                    var theConfig = details.cfg;\r\n                    _deepMergeConfig(details, theConfig, newConfig, mergeExisting);\r\n                    if (!mergeExisting) {\r\n                        // Remove (unassign) the values \"missing\" from the newConfig and also not in the default config\r\n                        objForEachKey(theConfig, function (key) {\r\n                            if (!objHasOwn(newConfig, key)) {\r\n                                // Set the value to undefined\r\n                                details.set(theConfig, key, UNDEFINED_VALUE);\r\n                            }\r\n                        });\r\n                    }\r\n                    // Apply defaults to the new config\r\n                    details[_DYN_SET_DF /* @min:%2esetDf */](theConfig, defaultConfig);\r\n                }, true);\r\n                // Now execute all of the listeners (synchronously) so they update their values immediately\r\n                _configHandler[_DYN_NOTIFY /* @min:%2enotify */]();\r\n                if (updateState) {\r\n                    _doUpdate(updateState);\r\n                }\r\n            };\r\n            _self.evtNamespace = function () {\r\n                return _evtNamespace;\r\n            };\r\n            _self.flush = _flushChannels;\r\n            _self.getTraceCtx = function (createNew) {\r\n                if (!_traceCtx) {\r\n                    _traceCtx = createDistributedTraceContext();\r\n                }\r\n                return _traceCtx;\r\n            };\r\n            _self.setTraceCtx = function (traceCtx) {\r\n                _traceCtx = traceCtx || null;\r\n            };\r\n            _self.addUnloadHook = _addUnloadHook;\r\n            // Create the addUnloadCb\r\n            proxyFunctionAs(_self, \"addUnloadCb\", function () { return _unloadHandlers; }, \"add\");\r\n            _self.onCfgChange = function (handler) {\r\n                var unloadHook;\r\n                if (!_isInitialized) {\r\n                    unloadHook = _addDelayedCfgListener(_cfgListeners, handler);\r\n                }\r\n                else {\r\n                    unloadHook = onConfigChange(_configHandler.cfg, handler, _self[_DYN_LOGGER /* @min:%2elogger */]);\r\n                }\r\n                return _createUnloadHook(unloadHook);\r\n            };\r\n            _self.getWParam = function () {\r\n                return (hasDocument() || !!_configHandler.cfg.enableWParam) ? 0 : -1;\r\n            };\r\n            function _setPluginVersions() {\r\n                var thePlugins = {};\r\n                _pluginVersionStringArr = [];\r\n                var _addPluginVersions = function (plugins) {\r\n                    if (plugins) {\r\n                        arrForEach(plugins, function (plugin) {\r\n                            if (plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] && plugin[_DYN_VERSION /* @min:%2eversion */] && !thePlugins[plugin.identifier]) {\r\n                                var ver = plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"=\" + plugin[_DYN_VERSION /* @min:%2eversion */];\r\n                                _pluginVersionStringArr[_DYN_PUSH /* @min:%2epush */](ver);\r\n                                thePlugins[plugin.identifier] = plugin;\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n                _addPluginVersions(_channels);\r\n                if (_channelConfig) {\r\n                    arrForEach(_channelConfig, function (channels) {\r\n                        _addPluginVersions(channels);\r\n                    });\r\n                }\r\n                _addPluginVersions(_configExtensions);\r\n            }\r\n            function _initDefaults() {\r\n                _isInitialized = false;\r\n                // Use a default logger so initialization errors are not dropped on the floor with full logging\r\n                _configHandler = createDynamicConfig({}, defaultConfig, _self[_DYN_LOGGER /* @min:%2elogger */]);\r\n                // Set the logging level to critical so that any critical initialization failures are displayed on the console\r\n                _configHandler.cfg[_DYN_LOGGING_LEVEL_CONSOL4 /* @min:%2eloggingLevelConsole */] = 1 /* eLoggingSeverity.CRITICAL */;\r\n                // Define _self.config\r\n                objDefine(_self, \"config\", {\r\n                    g: function () { return _configHandler.cfg; },\r\n                    s: function (newValue) {\r\n                        _self.updateCfg(newValue, false);\r\n                    }\r\n                });\r\n                objDefine(_self, \"pluginVersionStringArr\", {\r\n                    g: function () {\r\n                        if (!_pluginVersionStringArr) {\r\n                            _setPluginVersions();\r\n                        }\r\n                        return _pluginVersionStringArr;\r\n                    }\r\n                });\r\n                objDefine(_self, \"pluginVersionString\", {\r\n                    g: function () {\r\n                        if (!_pluginVersionString) {\r\n                            if (!_pluginVersionStringArr) {\r\n                                _setPluginVersions();\r\n                            }\r\n                            _pluginVersionString = _pluginVersionStringArr.join(\";\");\r\n                        }\r\n                        return _pluginVersionString || STR_EMPTY;\r\n                    }\r\n                });\r\n                objDefine(_self, \"logger\", {\r\n                    g: function () {\r\n                        if (!_logger) {\r\n                            _logger = new DiagnosticLogger(_configHandler.cfg);\r\n                            _configHandler[_DYN_LOGGER /* @min:%2elogger */] = _logger;\r\n                        }\r\n                        return _logger;\r\n                    },\r\n                    s: function (newLogger) {\r\n                        _configHandler[_DYN_LOGGER /* @min:%2elogger */] = newLogger;\r\n                        if (_logger !== newLogger) {\r\n                            runTargetUnload(_logger, false);\r\n                            _logger = newLogger;\r\n                        }\r\n                    }\r\n                });\r\n                _self[_DYN_LOGGER /* @min:%2elogger */] = new DiagnosticLogger(_configHandler.cfg);\r\n                _extensions = [];\r\n                var cfgExtensions = _self.config[STR_EXTENSIONS /* @min:%2eextensions */] || [];\r\n                cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH /* @min:%2elength */]);\r\n                arrAppend(cfgExtensions, _extensions);\r\n                _telemetryInitializerPlugin = new TelemetryInitializerPlugin();\r\n                _eventQueue = [];\r\n                runTargetUnload(_notificationManager, false);\r\n                _notificationManager = null;\r\n                _perfManager = null;\r\n                _cfgPerfManager = null;\r\n                runTargetUnload(_cookieManager, false);\r\n                _cookieManager = null;\r\n                _pluginChain = null;\r\n                _configExtensions = [];\r\n                _channelConfig = null;\r\n                _channels = null;\r\n                _isUnloading = false;\r\n                _internalLogsEventName = null;\r\n                _evtNamespace = createUniqueNamespace(\"AIBaseCore\", true);\r\n                _unloadHandlers = createUnloadHandlerContainer();\r\n                _traceCtx = null;\r\n                _instrumentationKey = null;\r\n                _hookContainer = createUnloadHookContainer();\r\n                _cfgListeners = [];\r\n                _pluginVersionString = null;\r\n                _pluginVersionStringArr = null;\r\n                _forceStopInternalLogPoller = false;\r\n                _internalLogPoller = null;\r\n                _internalLogPollerListening = false;\r\n                _activeStatus = 0 /* eActiveStatus.NONE */; // default is None\r\n                _endpoint = null;\r\n                _initInMemoMaxSize = null;\r\n                _isStatusSet = false;\r\n                _initTimer = null;\r\n            }\r\n            function _createTelCtx() {\r\n                var theCtx = createProcessTelemetryContext(_getPluginChain(), _configHandler.cfg, _self);\r\n                theCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](_startLogPoller);\r\n                return theCtx;\r\n            }\r\n            // Initialize or Re-initialize the plugins\r\n            function _initPluginChain(updateState) {\r\n                // Extension validation\r\n                var theExtensions = _validateExtensions(_self[_DYN_LOGGER /* @min:%2elogger */], ChannelControllerPriority, _configExtensions);\r\n                _pluginChain = null;\r\n                _pluginVersionString = null;\r\n                _pluginVersionStringArr = null;\r\n                // Get the primary channel queue and include as part of the normal extensions\r\n                _channels = (_channelConfig || [])[0] || [];\r\n                // Add any channels provided in the extensions and sort them\r\n                _channels = sortPlugins(arrAppend(_channels, theExtensions[STR_CHANNELS /* @min:%2echannels */]));\r\n                // Create an array of all extensions, including the _channels\r\n                var allExtensions = arrAppend(sortPlugins(theExtensions[STR_CORE /* @min:%2ecore */]), _channels);\r\n                // Required to allow plugins to call core.getPlugin() during their own initialization\r\n                _extensions = objFreeze(allExtensions);\r\n                // This has a side effect of adding the extensions passed during initialization\r\n                // into the config.extensions, so you can see all of the extensions loaded.\r\n                // This will also get updated by the addPlugin() and remove plugin code.\r\n                var cfgExtensions = _self.config[STR_EXTENSIONS /* @min:%2eextensions */] || [];\r\n                cfgExtensions.splice(0, cfgExtensions[_DYN_LENGTH /* @min:%2elength */]);\r\n                arrAppend(cfgExtensions, _extensions);\r\n                var rootCtx = _createTelCtx();\r\n                // Initializing the channels first\r\n                if (_channels && _channels[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    initializePlugins(rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](_channels), allExtensions);\r\n                }\r\n                // Now initialize the normal extensions (explicitly not including the _channels as this can cause duplicate initialization)\r\n                initializePlugins(rootCtx, allExtensions);\r\n                if (updateState) {\r\n                    _doUpdate(updateState);\r\n                }\r\n            }\r\n            function _getPlugin(pluginIdentifier) {\r\n                var theExt = null;\r\n                var thePlugin = null;\r\n                var channelHosts = [];\r\n                arrForEach(_extensions, function (ext) {\r\n                    if (ext[_DYN_IDENTIFIER /* @min:%2eidentifier */] === pluginIdentifier && ext !== _telemetryInitializerPlugin) {\r\n                        thePlugin = ext;\r\n                        return -1;\r\n                    }\r\n                    if (ext.getChannel) {\r\n                        channelHosts[_DYN_PUSH /* @min:%2epush */](ext);\r\n                    }\r\n                });\r\n                if (!thePlugin && channelHosts[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    arrForEach(channelHosts, function (host) {\r\n                        thePlugin = host.getChannel(pluginIdentifier);\r\n                        if (!thePlugin) {\r\n                            return -1;\r\n                        }\r\n                    });\r\n                }\r\n                if (thePlugin) {\r\n                    theExt = {\r\n                        plugin: thePlugin,\r\n                        setEnabled: function (enabled) {\r\n                            _getPluginState(thePlugin)[STR_DISABLED] = !enabled;\r\n                        },\r\n                        isEnabled: function () {\r\n                            var pluginState = _getPluginState(thePlugin);\r\n                            return !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] && !pluginState[STR_DISABLED];\r\n                        },\r\n                        remove: function (isAsync, removeCb) {\r\n                            var _a;\r\n                            if (isAsync === void 0) { isAsync = true; }\r\n                            var pluginsToRemove = [thePlugin];\r\n                            var unloadState = (_a = {\r\n                                    reason: 1 /* TelemetryUnloadReason.PluginUnload */\r\n                                },\r\n                                _a[_DYN_IS_ASYNC /* @min:isAsync */] = isAsync,\r\n                                _a);\r\n                            _removePlugins(pluginsToRemove, unloadState, function (removed) {\r\n                                if (removed) {\r\n                                    // Re-Initialize the plugin chain\r\n                                    _initPluginChain({\r\n                                        reason: 32 /* TelemetryUpdateReason.PluginRemoved */,\r\n                                        removed: pluginsToRemove\r\n                                    });\r\n                                }\r\n                                removeCb && removeCb(removed);\r\n                            });\r\n                        }\r\n                    };\r\n                }\r\n                return theExt;\r\n            }\r\n            function _getPluginChain() {\r\n                if (!_pluginChain) {\r\n                    // copy the collection of extensions\r\n                    var extensions = (_extensions || []).slice();\r\n                    // During add / remove this may get called again, so don't read if already present\r\n                    if (arrIndexOf(extensions, _telemetryInitializerPlugin) === -1) {\r\n                        extensions[_DYN_PUSH /* @min:%2epush */](_telemetryInitializerPlugin);\r\n                    }\r\n                    _pluginChain = createTelemetryProxyChain(sortPlugins(extensions), _configHandler.cfg, _self);\r\n                }\r\n                return _pluginChain;\r\n            }\r\n            function _removePlugins(thePlugins, unloadState, removeComplete) {\r\n                if (thePlugins && thePlugins[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    var unloadChain = createTelemetryProxyChain(thePlugins, _configHandler.cfg, _self);\r\n                    var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);\r\n                    unloadCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](function () {\r\n                        var removed = false;\r\n                        // Remove the listed config extensions\r\n                        var newConfigExtensions = [];\r\n                        arrForEach(_configExtensions, function (plugin, idx) {\r\n                            if (!_isPluginPresent(plugin, thePlugins)) {\r\n                                newConfigExtensions[_DYN_PUSH /* @min:%2epush */](plugin);\r\n                            }\r\n                            else {\r\n                                removed = true;\r\n                            }\r\n                        });\r\n                        _configExtensions = newConfigExtensions;\r\n                        _pluginVersionString = null;\r\n                        _pluginVersionStringArr = null;\r\n                        // Re-Create the channel config\r\n                        var newChannelConfig = [];\r\n                        if (_channelConfig) {\r\n                            arrForEach(_channelConfig, function (queue, idx) {\r\n                                var newQueue = [];\r\n                                arrForEach(queue, function (channel) {\r\n                                    if (!_isPluginPresent(channel, thePlugins)) {\r\n                                        newQueue[_DYN_PUSH /* @min:%2epush */](channel);\r\n                                    }\r\n                                    else {\r\n                                        removed = true;\r\n                                    }\r\n                                });\r\n                                newChannelConfig[_DYN_PUSH /* @min:%2epush */](newQueue);\r\n                            });\r\n                            _channelConfig = newChannelConfig;\r\n                        }\r\n                        removeComplete && removeComplete(removed);\r\n                        _startLogPoller();\r\n                    });\r\n                    unloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\r\n                }\r\n                else {\r\n                    removeComplete(false);\r\n                }\r\n            }\r\n            function _flushInternalLogs() {\r\n                if (_logger && _logger.queue) {\r\n                    var queue = _logger.queue.slice(0);\r\n                    _logger.queue[_DYN_LENGTH /* @min:%2elength */] = 0;\r\n                    arrForEach(queue, function (logMessage) {\r\n                        var _a;\r\n                        var item = (_a = {},\r\n                            _a[_DYN_NAME /* @min:name */] = _internalLogsEventName ? _internalLogsEventName : \"InternalMessageId: \" + logMessage[_DYN_MESSAGE_ID /* @min:%2emessageId */],\r\n                            _a[_DYN_I_KEY /* @min:iKey */] = _instrumentationKey,\r\n                            _a[_DYN_TIME /* @min:time */] = toISOString(new Date()),\r\n                            _a.baseType = _InternalLogMessage.dataType,\r\n                            _a.baseData = { message: logMessage[_DYN_MESSAGE /* @min:%2emessage */] },\r\n                            _a);\r\n                        _self.track(item);\r\n                    });\r\n                }\r\n            }\r\n            function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {\r\n                // Setting waiting to one so that we don't call the callBack until we finish iterating\r\n                var waiting = 1;\r\n                var doneIterating = false;\r\n                var cbTimer = null;\r\n                cbTimeout = cbTimeout || 5000;\r\n                function doCallback() {\r\n                    waiting--;\r\n                    if (doneIterating && waiting === 0) {\r\n                        cbTimer && cbTimer[_DYN_CANCEL /* @min:%2ecancel */]();\r\n                        cbTimer = null;\r\n                        callBack && callBack(doneIterating);\r\n                        callBack = null;\r\n                    }\r\n                }\r\n                if (_channels && _channels[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                    var flushCtx = _createTelCtx()[_DYN_CREATE_NEW /* @min:%2ecreateNew */](_channels);\r\n                    flushCtx.iterate(function (plugin) {\r\n                        if (plugin.flush) {\r\n                            waiting++;\r\n                            var handled_1 = false;\r\n                            // Not all channels will call this callback for every scenario\r\n                            if (!plugin.flush(isAsync, function () {\r\n                                handled_1 = true;\r\n                                doCallback();\r\n                            }, sendReason)) {\r\n                                if (!handled_1) {\r\n                                    // If any channel doesn't return true and it didn't call the callback, then we should assume that the callback\r\n                                    // will never be called, so use a timeout to allow the channel(s) some time to \"finish\" before triggering any\r\n                                    // followup function (such as unloading)\r\n                                    if (isAsync && cbTimer == null) {\r\n                                        cbTimer = scheduleTimeout(function () {\r\n                                            cbTimer = null;\r\n                                            doCallback();\r\n                                        }, cbTimeout);\r\n                                    }\r\n                                    else {\r\n                                        doCallback();\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                doneIterating = true;\r\n                doCallback();\r\n                return true;\r\n            }\r\n            function _initPerfManager() {\r\n                // Save the previous config based performance manager creator to avoid creating new perf manager instances if unchanged\r\n                var prevCfgPerfMgr;\r\n                // Will get recalled if any referenced config values are changed\r\n                _addUnloadHook(_configHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\r\n                    var enablePerfMgr = details.cfg.enablePerfMgr;\r\n                    if (enablePerfMgr) {\r\n                        var createPerfMgr = details.cfg[STR_CREATE_PERF_MGR /* @min:%2ecreatePerfMgr */];\r\n                        if (prevCfgPerfMgr !== createPerfMgr) {\r\n                            if (!createPerfMgr) {\r\n                                createPerfMgr = _createPerfManager;\r\n                            }\r\n                            // Set the performance manager creation function if not defined\r\n                            getSetValue(details.cfg, STR_CREATE_PERF_MGR, createPerfMgr);\r\n                            prevCfgPerfMgr = createPerfMgr;\r\n                            // Remove any existing config based performance manager\r\n                            _cfgPerfManager = null;\r\n                        }\r\n                        // Only create the performance manager if it's not already created or manually set\r\n                        if (!_perfManager && !_cfgPerfManager && isFunction(createPerfMgr)) {\r\n                            // Create a new config based performance manager\r\n                            _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]());\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Remove any existing config based performance manager\r\n                        _cfgPerfManager = null;\r\n                        // Clear the previous cached value so it can be GC'd\r\n                        prevCfgPerfMgr = null;\r\n                    }\r\n                }));\r\n            }\r\n            function _doUpdate(updateState) {\r\n                var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);\r\n                updateCtx[_DYN_ON_COMPLETE /* @min:%2eonComplete */](_startLogPoller);\r\n                if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {\r\n                    updateCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);\r\n                }\r\n            }\r\n            function _logOrThrowError(message) {\r\n                var logger = _self[_DYN_LOGGER /* @min:%2elogger */];\r\n                if (logger) {\r\n                    // there should always be a logger\r\n                    _throwInternal(logger, 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, message);\r\n                    _startLogPoller();\r\n                }\r\n                else {\r\n                    throwError(message);\r\n                }\r\n            }\r\n            function _notifyInvalidEvent(telemetryItem) {\r\n                var manager = _self[_DYN_GET_NOTIFY_MGR /* @min:%2egetNotifyMgr */]();\r\n                if (manager) {\r\n                    manager[STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */]([telemetryItem], 2 /* eEventsDiscardedReason.InvalidEvent */);\r\n                }\r\n            }\r\n            function _addUnloadHook(hooks) {\r\n                _hookContainer.add(hooks);\r\n            }\r\n        });\r\n    }\r\n    AppInsightsCore.prototype.initialize = function (config, extensions, logger, notificationManager) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    AppInsightsCore.prototype.getChannels = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    AppInsightsCore.prototype.track = function (telemetryItem) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    AppInsightsCore.prototype.getProcessTelContext = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    AppInsightsCore.prototype.getNotifyMgr = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Adds a notification listener. The SDK calls methods on the listener when an appropriate notification is raised.\r\n     * The added plugins must raise notifications. If the plugins do not implement the notifications, then no methods will be\r\n     * called.\r\n     * @param listener - An INotificationListener object.\r\n     */\r\n    AppInsightsCore.prototype.addNotificationListener = function (listener) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Removes all instances of the listener.\r\n     * @param listener - INotificationListener to remove.\r\n     */\r\n    AppInsightsCore.prototype.removeNotificationListener = function (listener) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Get the current cookie manager for this instance\r\n     */\r\n    AppInsightsCore.prototype.getCookieMgr = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Set the current cookie manager for this instance\r\n     * @param cookieMgr - The manager, if set to null/undefined will cause the default to be created\r\n     */\r\n    AppInsightsCore.prototype.setCookieMgr = function (cookieMgr) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    AppInsightsCore.prototype.getPerfMgr = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    AppInsightsCore.prototype.setPerfMgr = function (perfMgr) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    AppInsightsCore.prototype.eventCnt = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return 0;\r\n    };\r\n    /**\r\n     * Enable the timer that checks the logger.queue for log messages to be flushed.\r\n     * Note: Since 3.0.1 and 2.8.13 this is no longer an interval timer but is a normal\r\n     * timer that is only started when this function is called and then subsequently\r\n     * only _if_ there are any logger.queue messages to be sent.\r\n     */\r\n    AppInsightsCore.prototype.pollInternalLogs = function (eventName) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Stop the timer that log messages from logger.queue when available\r\n     */\r\n    AppInsightsCore.prototype.stopPollingInternalLogs = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add a telemetry processor to decorate or drop telemetry events.\r\n     * @param telemetryInitializer - The Telemetry Initializer function\r\n     * @returns - A ITelemetryInitializerHandler to enable the initializer to be removed\r\n     */\r\n    AppInsightsCore.prototype.addTelemetryInitializer = function (telemetryInitializer) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Unload and Tear down the SDK and any initialized plugins, after calling this the SDK will be considered\r\n     * to be un-initialized and non-operational, re-initializing the SDK should only be attempted if the previous\r\n     * unload call return `true` stating that all plugins reported that they also unloaded, the recommended\r\n     * approach is to create a new instance and initialize that instance.\r\n     * This is due to possible unexpected side effects caused by plugins not supporting unload / teardown, unable\r\n     * to successfully remove any global references or they may just be completing the unload process asynchronously.\r\n     * If you pass isAsync as `true` (also the default) and DO NOT pass a callback function then an [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * will be returned which will resolve once the unload is complete. The actual implementation of the `IPromise`\r\n     * will be a native Promise (if supported) or the default as supplied by [ts-async library](https://github.com/nevware21/ts-async)\r\n     * @param isAsync - Can the unload be performed asynchronously (default)\r\n     * @param unloadComplete - An optional callback that will be called once the unload has completed\r\n     * @param cbTimeout - An optional timeout to wait for any flush operations to complete before proceeding with the\r\n     * unload. Defaults to 5 seconds.\r\n     * @return Nothing or if occurring asynchronously a [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * which will be resolved once the unload is complete, the [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * will only be returned when no callback is provided and isAsync is true\r\n     */\r\n    AppInsightsCore.prototype.unload = function (isAsync, unloadComplete, cbTimeout) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    AppInsightsCore.prototype.getPlugin = function (pluginIdentifier) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Add a new plugin to the installation\r\n     * @param plugin - The new plugin to add\r\n     * @param replaceExisting - should any existing plugin be replaced, default is false\r\n     * @param doAsync - Should the add be performed asynchronously\r\n     * @param addCb - [Optional] callback to call after the plugin has been added\r\n     */\r\n    AppInsightsCore.prototype.addPlugin = function (plugin, replaceExisting, doAsync, addCb) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Update the configuration used and broadcast the changes to all loaded plugins\r\n     * @param newConfig - The new configuration is apply\r\n     * @param mergeExisting - Should the new configuration merge with the existing or just replace it. Default is to true.\r\n     */\r\n    AppInsightsCore.prototype.updateCfg = function (newConfig, mergeExisting) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Returns the unique event namespace that should be used\r\n     */\r\n    AppInsightsCore.prototype.evtNamespace = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Add an unload handler that will be called when the SDK is being unloaded\r\n     * @param handler - the handler\r\n     */\r\n    AppInsightsCore.prototype.addUnloadCb = function (handler) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Flush and send any batched / cached data immediately\r\n     * @param async - send data asynchronously when true (defaults to true)\r\n     * @param callBack - if specified, notify caller when send is complete, the channel should return true to indicate to the caller that it will be called.\r\n     * If the caller doesn't return true the caller should assume that it may never be called.\r\n     * @param sendReason - specify the reason that you are calling \"flush\" defaults to ManualFlush (1) if not specified\r\n     * @returns - true if the callback will be return after the flush is complete otherwise the caller should assume that any provided callback will never be called\r\n     */\r\n    AppInsightsCore.prototype.flush = function (isAsync, callBack, sendReason) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Gets the current distributed trace context for this instance if available\r\n     * @param createNew - Optional flag to create a new instance if one doesn't currently exist, defaults to true\r\n     */\r\n    AppInsightsCore.prototype.getTraceCtx = function (createNew) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Sets the current distributed trace context for this instance if available\r\n     */\r\n    AppInsightsCore.prototype.setTraceCtx = function (newTracectx) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add this hook so that it is automatically removed during unloading\r\n     * @param hooks - The single hook or an array of IInstrumentHook objects\r\n     */\r\n    AppInsightsCore.prototype.addUnloadHook = function (hooks) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Watches and tracks changes for accesses to the current config, and if the accessed config changes the\r\n     * handler will be recalled.\r\n     * @param handler\r\n     * @returns A watcher handler instance that can be used to remove itself when being unloaded\r\n     */\r\n    AppInsightsCore.prototype.onCfgChange = function (handler) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Watches and tracks status of initialization process\r\n     * @returns ActiveStatus\r\n     * @since 3.3.0\r\n     * If returned status is active, it means initialization process is completed.\r\n     * If returned status is pending, it means the initialization process is waiting for promieses to be resolved.\r\n     * If returned status is inactive, it means ikey is invalid or can 't get ikey or enpoint url from promsises.\r\n     */\r\n    AppInsightsCore.prototype.activeStatus = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    /**\r\n     * Set Active Status to pending, which will block the incoming changes until internal promises are resolved\r\n     * @internal Internal use\r\n     * @since 3.3.0\r\n     */\r\n    AppInsightsCore.prototype._setPendingStatus = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return null;\r\n    };\r\n    AppInsightsCore.prototype.releaseQueue = function () {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Hook for Core extensions to allow them to update their own configuration before updating all of the plugins.\r\n     * @param updateCtx - The plugin update context\r\n     * @param updateState - The Update State\r\n     * @returns boolean - True means the extension class will call updateState otherwise the Core will\r\n     */\r\n    AppInsightsCore.prototype._updateHook = function (updateCtx, updateState) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return false;\r\n    };\r\n    return AppInsightsCore;\r\n}());\r\nexport { AppInsightsCore };\r\n//# sourceMappingURL=AppInsightsCore.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}