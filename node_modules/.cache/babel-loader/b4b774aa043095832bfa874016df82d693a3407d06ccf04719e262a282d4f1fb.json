{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nimport { arrForEach, dumpObj, isArray, isFunction, isNullOrUndefined, isUndefined, objForEachKey, objFreeze, objKeys } from \"@nevware21/ts-utils\";\nimport { _applyDefaultValue } from \"../Config/ConfigDefaults\";\nimport { createDynamicConfig } from \"../Config/DynamicConfig\";\nimport { _DYN_CREATE_NEW, _DYN_DIAG_LOG, _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_IDENTIFIER, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_LOGGER, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_SET_DF, _DYN_SET_NEXT_PLUGIN, _DYN_TEARDOWN, _DYN_UNLOAD, _DYN_UPDATE } from \"../__DynamicConstants\";\nimport { _throwInternal, safeGetLogger } from \"./DiagnosticLogger\";\nimport { proxyFunctions } from \"./HelperFuncs\";\nimport { STR_CORE, STR_DISABLED, STR_EMPTY, STR_EXTENSION_CONFIG, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\nimport { doPerf } from \"./PerfManager\";\nimport { _getPluginState } from \"./TelemetryHelpers\";\nvar strTelemetryPluginChain = \"TelemetryPluginChain\";\nvar strHasRunFlags = \"_hasRun\";\nvar strGetTelCtx = \"_getTelCtx\";\nvar _chainId = 0;\nfunction _getNextProxyStart(proxy, core, startAt) {\n  while (proxy) {\n    if (proxy[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]() === startAt) {\n      return proxy;\n    }\n    proxy = proxy[_DYN_GET_NEXT /* @min:%2egetNext */]();\n  }\n  // This wasn't found in the existing chain so create an isolated one with just this plugin\n  return createTelemetryProxyChain([startAt], core.config || {}, core);\n}\n/**\r\n * @ignore\r\n * @param telemetryChain\r\n * @param dynamicHandler\r\n * @param core\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n * @returns\r\n */\nfunction _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {\n  // We have a special case where we want to start execution from this specific plugin\n  // or we simply reuse the existing telemetry plugin chain (normal execution case)\n  var _nextProxy = null; // By Default set as no next plugin\n  var _onComplete = [];\n  if (!dynamicHandler) {\n    dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER /* @min:%2elogger */]);\n  }\n  if (startAt !== null) {\n    // There is no next element (null) vs not defined (undefined) so use the full chain\n    _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;\n  }\n  var context = {\n    _next: _moveNext,\n    ctx: {\n      core: function () {\n        return core;\n      },\n      diagLog: function () {\n        return safeGetLogger(core, dynamicHandler.cfg);\n      },\n      getCfg: function () {\n        return dynamicHandler.cfg;\n      },\n      getExtCfg: _resolveExtCfg,\n      getConfig: _getConfig,\n      hasNext: function () {\n        return !!_nextProxy;\n      },\n      getNext: function () {\n        return _nextProxy;\n      },\n      setNext: function (nextPlugin) {\n        _nextProxy = nextPlugin;\n      },\n      iterate: _iterateChain,\n      onComplete: _addOnComplete\n    }\n  };\n  function _addOnComplete(onComplete, that) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n    if (onComplete) {\n      _onComplete[_DYN_PUSH /* @min:%2epush */]({\n        func: onComplete,\n        self: !isUndefined(that) ? that : context.ctx,\n        args: args\n      });\n    }\n  }\n  function _moveNext() {\n    var nextProxy = _nextProxy;\n    // Automatically move to the next plugin\n    _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT /* @min:%2egetNext */]() : null;\n    if (!nextProxy) {\n      var onComplete = _onComplete;\n      if (onComplete && onComplete[_DYN_LENGTH /* @min:%2elength */] > 0) {\n        arrForEach(onComplete, function (completeDetails) {\n          try {\n            completeDetails.func.call(completeDetails.self, completeDetails.args);\n          } catch (e) {\n            _throwInternal(core[_DYN_LOGGER /* @min:%2elogger */], 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, \"Unexpected Exception during onComplete - \" + dumpObj(e));\n          }\n        });\n        _onComplete = [];\n      }\n    }\n    return nextProxy;\n  }\n  function _getExtCfg(identifier, createIfMissing) {\n    var idCfg = null;\n    var cfg = dynamicHandler.cfg;\n    if (cfg && identifier) {\n      var extCfg = cfg[STR_EXTENSION_CONFIG /* @min:%2eextensionConfig */];\n      if (!extCfg && createIfMissing) {\n        extCfg = {};\n      }\n      // Always set the value so that the property always exists\n      cfg[STR_EXTENSION_CONFIG] = extCfg; // Note: it is valid for the \"value\" to be undefined\n      // Calling `ref()` has a side effect of causing the referenced property to become dynamic  (if not already)\n      extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG);\n      if (extCfg) {\n        idCfg = extCfg[identifier];\n        if (!idCfg && createIfMissing) {\n          idCfg = {};\n        }\n        // Always set the value so that the property always exists\n        extCfg[identifier] = idCfg; // Note: it is valid for the \"value\" to be undefined\n        // Calling `ref()` has a side effect of causing the referenced property to become dynamic  (if not already)\n        idCfg = dynamicHandler.ref(extCfg, identifier);\n      }\n    }\n    return idCfg;\n  }\n  function _resolveExtCfg(identifier, defaultValues) {\n    var newConfig = _getExtCfg(identifier, true);\n    if (defaultValues) {\n      // Enumerate over the defaultValues and if not already populated attempt to\n      // find a value from the root config or use the default value\n      objForEachKey(defaultValues, function (field, defaultValue) {\n        // for each unspecified field, set the default value\n        if (isNullOrUndefined(newConfig[field])) {\n          var cfgValue = dynamicHandler.cfg[field];\n          if (cfgValue || !isNullOrUndefined(cfgValue)) {\n            newConfig[field] = cfgValue;\n          }\n        }\n        _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);\n      });\n    }\n    return dynamicHandler[_DYN_SET_DF /* @min:%2esetDf */](newConfig, defaultValues);\n  }\n  function _getConfig(identifier, field, defaultValue) {\n    if (defaultValue === void 0) {\n      defaultValue = false;\n    }\n    var theValue;\n    var extConfig = _getExtCfg(identifier, false);\n    var rootConfig = dynamicHandler.cfg;\n    if (extConfig && (extConfig[field] || !isNullOrUndefined(extConfig[field]))) {\n      theValue = extConfig[field];\n    } else if (rootConfig[field] || !isNullOrUndefined(rootConfig[field])) {\n      theValue = rootConfig[field];\n    }\n    return theValue || !isNullOrUndefined(theValue) ? theValue : defaultValue;\n  }\n  function _iterateChain(cb) {\n    // Keep processing until we reach the end of the chain\n    var nextPlugin;\n    while (!!(nextPlugin = context._next())) {\n      var plugin = nextPlugin[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]();\n      if (plugin) {\n        // callback with the current on\n        cb(plugin);\n      }\n    }\n  }\n  return context;\n}\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\nexport function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {\n  var config = createDynamicConfig(cfg);\n  var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\n  var context = internalContext.ctx;\n  function _processNext(env) {\n    var nextPlugin = internalContext._next();\n    if (nextPlugin) {\n      // Run the next plugin which will call \"processNext()\"\n      nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, context);\n    }\n    return !nextPlugin;\n  }\n  function _createNew(plugins, startAt) {\n    if (plugins === void 0) {\n      plugins = null;\n    }\n    if (isArray(plugins)) {\n      plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);\n    }\n    return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), config.cfg, core, startAt);\n  }\n  context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\n  context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\n  return context;\n}\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain for handling the unloading of the chain\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\nexport function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {\n  var config = createDynamicConfig(core.config);\n  var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\n  var context = internalContext.ctx;\n  function _processNext(unloadState) {\n    var nextPlugin = internalContext._next();\n    nextPlugin && nextPlugin[_DYN_UNLOAD /* @min:%2eunload */](context, unloadState);\n    return !nextPlugin;\n  }\n  function _createNew(plugins, startAt) {\n    if (plugins === void 0) {\n      plugins = null;\n    }\n    if (isArray(plugins)) {\n      plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);\n    }\n    return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);\n  }\n  context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\n  context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\n  return context;\n}\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain for updating the configuration\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\nexport function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {\n  var config = createDynamicConfig(core.config);\n  var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\n  var context = internalContext.ctx;\n  function _processNext(updateState) {\n    return context.iterate(function (plugin) {\n      if (isFunction(plugin[_DYN_UPDATE /* @min:%2eupdate */])) {\n        plugin[_DYN_UPDATE /* @min:%2eupdate */](context, updateState);\n      }\n    });\n  }\n  function _createNew(plugins, startAt) {\n    if (plugins === void 0) {\n      plugins = null;\n    }\n    if (isArray(plugins)) {\n      plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);\n    }\n    return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);\n  }\n  context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\n  context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\n  return context;\n}\n/**\r\n * Creates an execution chain from the array of plugins\r\n * @param plugins - The array of plugins that will be executed in this order\r\n * @param defItemCtx - The default execution context to use when no telemetry context is passed to processTelemetry(), this\r\n * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error\r\n * reporting (hasRun) when errors occur.\r\n */\nexport function createTelemetryProxyChain(plugins, config, core, startAt) {\n  var firstProxy = null;\n  var add = startAt ? false : true;\n  if (isArray(plugins) && plugins[_DYN_LENGTH /* @min:%2elength */] > 0) {\n    // Create the proxies and wire up the next plugin chain\n    var lastProxy_1 = null;\n    arrForEach(plugins, function (thePlugin) {\n      if (!add && startAt === thePlugin) {\n        add = true;\n      }\n      if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\n        // Only add plugins that are processors\n        var newProxy = createTelemetryPluginProxy(thePlugin, config, core);\n        if (!firstProxy) {\n          firstProxy = newProxy;\n        }\n        if (lastProxy_1) {\n          // Set this new proxy as the next for the previous one\n          lastProxy_1._setNext(newProxy);\n        }\n        lastProxy_1 = newProxy;\n      }\n    });\n  }\n  if (startAt && !firstProxy) {\n    // Special case where the \"startAt\" was not in the original list of plugins\n    return createTelemetryProxyChain([startAt], config, core);\n  }\n  return firstProxy;\n}\n/**\r\n * Create the processing telemetry proxy instance, the proxy is used to abstract the current plugin to allow monitoring and\r\n * execution plugins while passing around the dynamic execution state (IProcessTelemetryContext), the proxy instance no longer\r\n * contains any execution state and can be reused between requests (this was not the case for 2.7.2 and earlier with the\r\n * TelemetryPluginChain class).\r\n * @param plugin - The plugin instance to proxy\r\n * @param config - The default execution context to use when no telemetry context is passed to processTelemetry(), this\r\n * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error\r\n * reporting (hasRun) when errors occur.\r\n * @returns\r\n */\nexport function createTelemetryPluginProxy(plugin, config, core) {\n  var nextProxy = null;\n  var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]);\n  var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */]);\n  var chainId;\n  if (plugin) {\n    chainId = plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"-\" + plugin[STR_PRIORITY /* @min:%2epriority */] + \"-\" + _chainId++;\n  } else {\n    chainId = \"Unknown-0-\" + _chainId++;\n  }\n  var proxyChain = {\n    getPlugin: function () {\n      return plugin;\n    },\n    getNext: function () {\n      return nextProxy;\n    },\n    processTelemetry: _processTelemetry,\n    unload: _unloadPlugin,\n    update: _updatePlugin,\n    _id: chainId,\n    _setNext: function (nextPlugin) {\n      nextProxy = nextPlugin;\n    }\n  };\n  function _getTelCtx() {\n    var itemCtx;\n    // Looks like a plugin didn't pass the (optional) context, so create a new one\n    if (plugin && isFunction(plugin[strGetTelCtx])) {\n      // This plugin extends from the BaseTelemetryPlugin so lets use it\n      itemCtx = plugin[strGetTelCtx]();\n    }\n    if (!itemCtx) {\n      // Create a temporary one\n      itemCtx = createProcessTelemetryContext(proxyChain, config, core);\n    }\n    return itemCtx;\n  }\n  function _processChain(itemCtx, processPluginFn, name, details, isAsync) {\n    var hasRun = false;\n    var identifier = plugin ? plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] : strTelemetryPluginChain;\n    var hasRunContext = itemCtx[strHasRunFlags];\n    if (!hasRunContext) {\n      // Assign and populate\n      hasRunContext = itemCtx[strHasRunFlags] = {};\n    }\n    // Ensure that we keep the context in sync\n    itemCtx.setNext(nextProxy);\n    if (plugin) {\n      doPerf(itemCtx[STR_CORE /* @min:%2ecore */](), function () {\n        return identifier + \":\" + name;\n      }, function () {\n        // Mark this component as having run\n        hasRunContext[chainId] = true;\n        try {\n          // Set a flag on the next plugin so we know if it was attempted to be executed\n          var nextId = nextProxy ? nextProxy._id : STR_EMPTY;\n          if (nextId) {\n            hasRunContext[nextId] = false;\n          }\n          hasRun = processPluginFn(itemCtx);\n        } catch (error) {\n          var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;\n          if (hasNextRun) {\n            // The next plugin after us has already run so set this one as complete\n            hasRun = true;\n          }\n          if (!nextProxy || !hasNextRun) {\n            // Either we have no next plugin or the current one did not attempt to call the next plugin\n            // Which means the current one is the root of the failure so log/report this failure\n            _throwInternal(itemCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 73 /* _eInternalMessageId.PluginException */, \"Plugin [\" + identifier + \"] failed during \" + name + \" - \" + dumpObj(error) + \", run flags: \" + dumpObj(hasRunContext));\n          }\n        }\n      }, details, isAsync);\n    }\n    return hasRun;\n  }\n  function _processTelemetry(env, itemCtx) {\n    itemCtx = itemCtx || _getTelCtx();\n    function _callProcessTelemetry(itemCtx) {\n      if (!plugin || !hasProcessTelemetry) {\n        return false;\n      }\n      var pluginState = _getPluginState(plugin);\n      if (pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] || pluginState[STR_DISABLED]) {\n        return false;\n      }\n      // Ensure that we keep the context in sync (for processNext()), just in case a plugin\n      // doesn't calls processTelemetry() instead of itemContext.processNext() or some\n      // other form of error occurred\n      if (hasSetNext) {\n        // Backward compatibility setting the next plugin on the instance\n        plugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](nextProxy);\n      }\n      plugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, itemCtx);\n      // Process Telemetry is expected to call itemCtx.processNext() or nextPlugin.processTelemetry()\n      return true;\n    }\n    if (!_processChain(itemCtx, _callProcessTelemetry, \"processTelemetry\", function () {\n      return {\n        item: env\n      };\n    }, !env.sync)) {\n      // The underlying plugin is either not defined, not enabled or does not have a processTelemetry implementation\n      // so we still want the next plugin to be executed.\n      itemCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);\n    }\n  }\n  function _unloadPlugin(unloadCtx, unloadState) {\n    function _callTeardown() {\n      // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().\n      var hasRun = false;\n      if (plugin) {\n        var pluginState = _getPluginState(plugin);\n        var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE /* @min:%2ecore */];\n        // Only teardown the plugin if it was initialized by the current core (i.e. It's not a shared plugin)\n        if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */]) {\n          // Handle plugins that don't extend from the BaseTelemetryPlugin\n          pluginState[STR_CORE /* @min:%2ecore */] = null;\n          pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] = true;\n          pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = false;\n          if (plugin[_DYN_TEARDOWN /* @min:%2eteardown */] && plugin[_DYN_TEARDOWN /* @min:%2eteardown */](unloadCtx, unloadState) === true) {\n            // plugin told us that it was going to (or has) call unloadCtx.processNext()\n            hasRun = true;\n          }\n        }\n      }\n      return hasRun;\n    }\n    if (!_processChain(unloadCtx, _callTeardown, \"unload\", function () {}, unloadState[_DYN_IS_ASYNC /* @min:%2eisAsync */])) {\n      // Only called if we hasRun was not true\n      unloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\n    }\n  }\n  function _updatePlugin(updateCtx, updateState) {\n    function _callUpdate() {\n      // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().\n      var hasRun = false;\n      if (plugin) {\n        var pluginState = _getPluginState(plugin);\n        var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE /* @min:%2ecore */];\n        // Only update the plugin if it was initialized by the current core (i.e. It's not a shared plugin)\n        if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */]) {\n          if (plugin[_DYN_UPDATE /* @min:%2eupdate */] && plugin[_DYN_UPDATE /* @min:%2eupdate */](updateCtx, updateState) === true) {\n            // plugin told us that it was going to (or has) call unloadCtx.processNext()\n            hasRun = true;\n          }\n        }\n      }\n      return hasRun;\n    }\n    if (!_processChain(updateCtx, _callUpdate, \"update\", function () {}, false)) {\n      // Only called if we hasRun was not true\n      updateCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);\n    }\n  }\n  return objFreeze(proxyChain);\n}\n/**\r\n * This class will be removed!\r\n * @deprecated use createProcessTelemetryContext() instead\r\n */\nvar ProcessTelemetryContext = /** @class */function () {\n  /**\r\n   * Creates a new Telemetry Item context with the current config, core and plugin execution chain\r\n   * @param plugins - The plugin instances that will be executed\r\n   * @param config - The current config\r\n   * @param core - The current core instance\r\n   */\n  function ProcessTelemetryContext(pluginChain, config, core, startAt) {\n    var _self = this;\n    var context = createProcessTelemetryContext(pluginChain, config, core, startAt);\n    // Proxy all functions of the context to this object\n    proxyFunctions(_self, context, objKeys(context));\n  }\n  return ProcessTelemetryContext;\n}();\nexport { ProcessTelemetryContext };","map":{"version":3,"names":["arrForEach","dumpObj","isArray","isFunction","isNullOrUndefined","isUndefined","objForEachKey","objFreeze","objKeys","_applyDefaultValue","createDynamicConfig","_DYN_CREATE_NEW","_DYN_DIAG_LOG","_DYN_GET_NEXT","_DYN_GET_PLUGIN","_DYN_IDENTIFIER","_DYN_IS_ASYNC","_DYN_IS_INITIALIZED","_DYN_LENGTH","_DYN_LOGGER","_DYN_PROCESS_NEXT","_DYN_PUSH","_DYN_SET_DF","_DYN_SET_NEXT_PLUGIN","_DYN_TEARDOWN","_DYN_UNLOAD","_DYN_UPDATE","_throwInternal","safeGetLogger","proxyFunctions","STR_CORE","STR_DISABLED","STR_EMPTY","STR_EXTENSION_CONFIG","STR_PRIORITY","STR_PROCESS_TELEMETRY","doPerf","_getPluginState","strTelemetryPluginChain","strHasRunFlags","strGetTelCtx","_chainId","_getNextProxyStart","proxy","core","startAt","createTelemetryProxyChain","config","_createInternalContext","telemetryChain","dynamicHandler","_nextProxy","_onComplete","context","_next","_moveNext","ctx","diagLog","cfg","getCfg","getExtCfg","_resolveExtCfg","getConfig","_getConfig","hasNext","getNext","setNext","nextPlugin","iterate","_iterateChain","onComplete","_addOnComplete","that","args","_i","arguments","length","func","self","nextProxy","completeDetails","call","e","_getExtCfg","identifier","createIfMissing","idCfg","extCfg","ref","defaultValues","newConfig","field","defaultValue","cfgValue","theValue","extConfig","rootConfig","cb","plugin","createProcessTelemetryContext","internalContext","_processNext","env","_createNew","plugins","createProcessTelemetryUnloadContext","unloadState","createProcessTelemetryUpdateContext","updateState","firstProxy","add","lastProxy_1","thePlugin","newProxy","createTelemetryPluginProxy","_setNext","hasProcessTelemetry","hasSetNext","chainId","proxyChain","getPlugin","processTelemetry","_processTelemetry","unload","_unloadPlugin","update","_updatePlugin","_id","_getTelCtx","itemCtx","_processChain","processPluginFn","name","details","isAsync","hasRun","hasRunContext","nextId","error","hasNextRun","_callProcessTelemetry","pluginState","item","sync","unloadCtx","_callTeardown","pluginCore","updateCtx","_callUpdate","ProcessTelemetryContext","pluginChain","_self"],"sources":["/home/veeresh133/app/api-call/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/ProcessTelemetryContext.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nimport { arrForEach, dumpObj, isArray, isFunction, isNullOrUndefined, isUndefined, objForEachKey, objFreeze, objKeys } from \"@nevware21/ts-utils\";\r\nimport { _applyDefaultValue } from \"../Config/ConfigDefaults\";\r\nimport { createDynamicConfig } from \"../Config/DynamicConfig\";\r\nimport { _DYN_CREATE_NEW, _DYN_DIAG_LOG, _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_IDENTIFIER, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_LOGGER, _DYN_PROCESS_NEXT, _DYN_PUSH, _DYN_SET_DF, _DYN_SET_NEXT_PLUGIN, _DYN_TEARDOWN, _DYN_UNLOAD, _DYN_UPDATE } from \"../__DynamicConstants\";\r\nimport { _throwInternal, safeGetLogger } from \"./DiagnosticLogger\";\r\nimport { proxyFunctions } from \"./HelperFuncs\";\r\nimport { STR_CORE, STR_DISABLED, STR_EMPTY, STR_EXTENSION_CONFIG, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\r\nimport { doPerf } from \"./PerfManager\";\r\nimport { _getPluginState } from \"./TelemetryHelpers\";\r\nvar strTelemetryPluginChain = \"TelemetryPluginChain\";\r\nvar strHasRunFlags = \"_hasRun\";\r\nvar strGetTelCtx = \"_getTelCtx\";\r\nvar _chainId = 0;\r\nfunction _getNextProxyStart(proxy, core, startAt) {\r\n    while (proxy) {\r\n        if (proxy[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]() === startAt) {\r\n            return proxy;\r\n        }\r\n        proxy = proxy[_DYN_GET_NEXT /* @min:%2egetNext */]();\r\n    }\r\n    // This wasn't found in the existing chain so create an isolated one with just this plugin\r\n    return createTelemetryProxyChain([startAt], core.config || {}, core);\r\n}\r\n/**\r\n * @ignore\r\n * @param telemetryChain\r\n * @param dynamicHandler\r\n * @param core\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n * @returns\r\n */\r\nfunction _createInternalContext(telemetryChain, dynamicHandler, core, startAt) {\r\n    // We have a special case where we want to start execution from this specific plugin\r\n    // or we simply reuse the existing telemetry plugin chain (normal execution case)\r\n    var _nextProxy = null; // By Default set as no next plugin\r\n    var _onComplete = [];\r\n    if (!dynamicHandler) {\r\n        dynamicHandler = createDynamicConfig({}, null, core[_DYN_LOGGER /* @min:%2elogger */]);\r\n    }\r\n    if (startAt !== null) {\r\n        // There is no next element (null) vs not defined (undefined) so use the full chain\r\n        _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;\r\n    }\r\n    var context = {\r\n        _next: _moveNext,\r\n        ctx: {\r\n            core: function () {\r\n                return core;\r\n            },\r\n            diagLog: function () {\r\n                return safeGetLogger(core, dynamicHandler.cfg);\r\n            },\r\n            getCfg: function () {\r\n                return dynamicHandler.cfg;\r\n            },\r\n            getExtCfg: _resolveExtCfg,\r\n            getConfig: _getConfig,\r\n            hasNext: function () {\r\n                return !!_nextProxy;\r\n            },\r\n            getNext: function () {\r\n                return _nextProxy;\r\n            },\r\n            setNext: function (nextPlugin) {\r\n                _nextProxy = nextPlugin;\r\n            },\r\n            iterate: _iterateChain,\r\n            onComplete: _addOnComplete\r\n        }\r\n    };\r\n    function _addOnComplete(onComplete, that) {\r\n        var args = [];\r\n        for (var _i = 2; _i < arguments.length; _i++) {\r\n            args[_i - 2] = arguments[_i];\r\n        }\r\n        if (onComplete) {\r\n            _onComplete[_DYN_PUSH /* @min:%2epush */]({\r\n                func: onComplete,\r\n                self: !isUndefined(that) ? that : context.ctx,\r\n                args: args\r\n            });\r\n        }\r\n    }\r\n    function _moveNext() {\r\n        var nextProxy = _nextProxy;\r\n        // Automatically move to the next plugin\r\n        _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT /* @min:%2egetNext */]() : null;\r\n        if (!nextProxy) {\r\n            var onComplete = _onComplete;\r\n            if (onComplete && onComplete[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n                arrForEach(onComplete, function (completeDetails) {\r\n                    try {\r\n                        completeDetails.func.call(completeDetails.self, completeDetails.args);\r\n                    }\r\n                    catch (e) {\r\n                        _throwInternal(core[_DYN_LOGGER /* @min:%2elogger */], 2 /* eLoggingSeverity.WARNING */, 73 /* _eInternalMessageId.PluginException */, \"Unexpected Exception during onComplete - \" + dumpObj(e));\r\n                    }\r\n                });\r\n                _onComplete = [];\r\n            }\r\n        }\r\n        return nextProxy;\r\n    }\r\n    function _getExtCfg(identifier, createIfMissing) {\r\n        var idCfg = null;\r\n        var cfg = dynamicHandler.cfg;\r\n        if (cfg && identifier) {\r\n            var extCfg = cfg[STR_EXTENSION_CONFIG /* @min:%2eextensionConfig */];\r\n            if (!extCfg && createIfMissing) {\r\n                extCfg = {};\r\n            }\r\n            // Always set the value so that the property always exists\r\n            cfg[STR_EXTENSION_CONFIG] = extCfg; // Note: it is valid for the \"value\" to be undefined\r\n            // Calling `ref()` has a side effect of causing the referenced property to become dynamic  (if not already)\r\n            extCfg = dynamicHandler.ref(cfg, STR_EXTENSION_CONFIG);\r\n            if (extCfg) {\r\n                idCfg = extCfg[identifier];\r\n                if (!idCfg && createIfMissing) {\r\n                    idCfg = {};\r\n                }\r\n                // Always set the value so that the property always exists\r\n                extCfg[identifier] = idCfg; // Note: it is valid for the \"value\" to be undefined\r\n                // Calling `ref()` has a side effect of causing the referenced property to become dynamic  (if not already)\r\n                idCfg = dynamicHandler.ref(extCfg, identifier);\r\n            }\r\n        }\r\n        return idCfg;\r\n    }\r\n    function _resolveExtCfg(identifier, defaultValues) {\r\n        var newConfig = _getExtCfg(identifier, true);\r\n        if (defaultValues) {\r\n            // Enumerate over the defaultValues and if not already populated attempt to\r\n            // find a value from the root config or use the default value\r\n            objForEachKey(defaultValues, function (field, defaultValue) {\r\n                // for each unspecified field, set the default value\r\n                if (isNullOrUndefined(newConfig[field])) {\r\n                    var cfgValue = dynamicHandler.cfg[field];\r\n                    if (cfgValue || !isNullOrUndefined(cfgValue)) {\r\n                        newConfig[field] = cfgValue;\r\n                    }\r\n                }\r\n                _applyDefaultValue(dynamicHandler, newConfig, field, defaultValue);\r\n            });\r\n        }\r\n        return dynamicHandler[_DYN_SET_DF /* @min:%2esetDf */](newConfig, defaultValues);\r\n    }\r\n    function _getConfig(identifier, field, defaultValue) {\r\n        if (defaultValue === void 0) { defaultValue = false; }\r\n        var theValue;\r\n        var extConfig = _getExtCfg(identifier, false);\r\n        var rootConfig = dynamicHandler.cfg;\r\n        if (extConfig && (extConfig[field] || !isNullOrUndefined(extConfig[field]))) {\r\n            theValue = extConfig[field];\r\n        }\r\n        else if (rootConfig[field] || !isNullOrUndefined(rootConfig[field])) {\r\n            theValue = rootConfig[field];\r\n        }\r\n        return (theValue || !isNullOrUndefined(theValue)) ? theValue : defaultValue;\r\n    }\r\n    function _iterateChain(cb) {\r\n        // Keep processing until we reach the end of the chain\r\n        var nextPlugin;\r\n        while (!!(nextPlugin = context._next())) {\r\n            var plugin = nextPlugin[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]();\r\n            if (plugin) {\r\n                // callback with the current on\r\n                cb(plugin);\r\n            }\r\n        }\r\n    }\r\n    return context;\r\n}\r\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\r\nexport function createProcessTelemetryContext(telemetryChain, cfg, core, startAt) {\r\n    var config = createDynamicConfig(cfg);\r\n    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\r\n    var context = internalContext.ctx;\r\n    function _processNext(env) {\r\n        var nextPlugin = internalContext._next();\r\n        if (nextPlugin) {\r\n            // Run the next plugin which will call \"processNext()\"\r\n            nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, context);\r\n        }\r\n        return !nextPlugin;\r\n    }\r\n    function _createNew(plugins, startAt) {\r\n        if (plugins === void 0) { plugins = null; }\r\n        if (isArray(plugins)) {\r\n            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);\r\n        }\r\n        return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), config.cfg, core, startAt);\r\n    }\r\n    context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\r\n    context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\r\n    return context;\r\n}\r\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain for handling the unloading of the chain\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\r\nexport function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {\r\n    var config = createDynamicConfig(core.config);\r\n    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\r\n    var context = internalContext.ctx;\r\n    function _processNext(unloadState) {\r\n        var nextPlugin = internalContext._next();\r\n        nextPlugin && nextPlugin[_DYN_UNLOAD /* @min:%2eunload */](context, unloadState);\r\n        return !nextPlugin;\r\n    }\r\n    function _createNew(plugins, startAt) {\r\n        if (plugins === void 0) { plugins = null; }\r\n        if (isArray(plugins)) {\r\n            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);\r\n        }\r\n        return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);\r\n    }\r\n    context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\r\n    context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\r\n    return context;\r\n}\r\n/**\r\n * Creates a new Telemetry Item context with the current config, core and plugin execution chain for updating the configuration\r\n * @param plugins - The plugin instances that will be executed\r\n * @param config - The current config\r\n * @param core - The current core instance\r\n * @param startAt - Identifies the next plugin to execute, if null there is no \"next\" plugin and if undefined it should assume the start of the chain\r\n */\r\nexport function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {\r\n    var config = createDynamicConfig(core.config);\r\n    var internalContext = _createInternalContext(telemetryChain, config, core, startAt);\r\n    var context = internalContext.ctx;\r\n    function _processNext(updateState) {\r\n        return context.iterate(function (plugin) {\r\n            if (isFunction(plugin[_DYN_UPDATE /* @min:%2eupdate */])) {\r\n                plugin[_DYN_UPDATE /* @min:%2eupdate */](context, updateState);\r\n            }\r\n        });\r\n    }\r\n    function _createNew(plugins, startAt) {\r\n        if (plugins === void 0) { plugins = null; }\r\n        if (isArray(plugins)) {\r\n            plugins = createTelemetryProxyChain(plugins, config.cfg, core, startAt);\r\n        }\r\n        return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT /* @min:%2egetNext */](), core, startAt);\r\n    }\r\n    context[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = _processNext;\r\n    context[_DYN_CREATE_NEW /* @min:%2ecreateNew */] = _createNew;\r\n    return context;\r\n}\r\n/**\r\n * Creates an execution chain from the array of plugins\r\n * @param plugins - The array of plugins that will be executed in this order\r\n * @param defItemCtx - The default execution context to use when no telemetry context is passed to processTelemetry(), this\r\n * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error\r\n * reporting (hasRun) when errors occur.\r\n */\r\nexport function createTelemetryProxyChain(plugins, config, core, startAt) {\r\n    var firstProxy = null;\r\n    var add = startAt ? false : true;\r\n    if (isArray(plugins) && plugins[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n        // Create the proxies and wire up the next plugin chain\r\n        var lastProxy_1 = null;\r\n        arrForEach(plugins, function (thePlugin) {\r\n            if (!add && startAt === thePlugin) {\r\n                add = true;\r\n            }\r\n            if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\r\n                // Only add plugins that are processors\r\n                var newProxy = createTelemetryPluginProxy(thePlugin, config, core);\r\n                if (!firstProxy) {\r\n                    firstProxy = newProxy;\r\n                }\r\n                if (lastProxy_1) {\r\n                    // Set this new proxy as the next for the previous one\r\n                    lastProxy_1._setNext(newProxy);\r\n                }\r\n                lastProxy_1 = newProxy;\r\n            }\r\n        });\r\n    }\r\n    if (startAt && !firstProxy) {\r\n        // Special case where the \"startAt\" was not in the original list of plugins\r\n        return createTelemetryProxyChain([startAt], config, core);\r\n    }\r\n    return firstProxy;\r\n}\r\n/**\r\n * Create the processing telemetry proxy instance, the proxy is used to abstract the current plugin to allow monitoring and\r\n * execution plugins while passing around the dynamic execution state (IProcessTelemetryContext), the proxy instance no longer\r\n * contains any execution state and can be reused between requests (this was not the case for 2.7.2 and earlier with the\r\n * TelemetryPluginChain class).\r\n * @param plugin - The plugin instance to proxy\r\n * @param config - The default execution context to use when no telemetry context is passed to processTelemetry(), this\r\n * should be for legacy plugins only. Currently, only used for passing the current core instance and to provide better error\r\n * reporting (hasRun) when errors occur.\r\n * @returns\r\n */\r\nexport function createTelemetryPluginProxy(plugin, config, core) {\r\n    var nextProxy = null;\r\n    var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]);\r\n    var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */]);\r\n    var chainId;\r\n    if (plugin) {\r\n        chainId = plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] + \"-\" + plugin[STR_PRIORITY /* @min:%2epriority */] + \"-\" + _chainId++;\r\n    }\r\n    else {\r\n        chainId = \"Unknown-0-\" + _chainId++;\r\n    }\r\n    var proxyChain = {\r\n        getPlugin: function () {\r\n            return plugin;\r\n        },\r\n        getNext: function () {\r\n            return nextProxy;\r\n        },\r\n        processTelemetry: _processTelemetry,\r\n        unload: _unloadPlugin,\r\n        update: _updatePlugin,\r\n        _id: chainId,\r\n        _setNext: function (nextPlugin) {\r\n            nextProxy = nextPlugin;\r\n        }\r\n    };\r\n    function _getTelCtx() {\r\n        var itemCtx;\r\n        // Looks like a plugin didn't pass the (optional) context, so create a new one\r\n        if (plugin && isFunction(plugin[strGetTelCtx])) {\r\n            // This plugin extends from the BaseTelemetryPlugin so lets use it\r\n            itemCtx = plugin[strGetTelCtx]();\r\n        }\r\n        if (!itemCtx) {\r\n            // Create a temporary one\r\n            itemCtx = createProcessTelemetryContext(proxyChain, config, core);\r\n        }\r\n        return itemCtx;\r\n    }\r\n    function _processChain(itemCtx, processPluginFn, name, details, isAsync) {\r\n        var hasRun = false;\r\n        var identifier = plugin ? plugin[_DYN_IDENTIFIER /* @min:%2eidentifier */] : strTelemetryPluginChain;\r\n        var hasRunContext = itemCtx[strHasRunFlags];\r\n        if (!hasRunContext) {\r\n            // Assign and populate\r\n            hasRunContext = itemCtx[strHasRunFlags] = {};\r\n        }\r\n        // Ensure that we keep the context in sync\r\n        itemCtx.setNext(nextProxy);\r\n        if (plugin) {\r\n            doPerf(itemCtx[STR_CORE /* @min:%2ecore */](), function () { return identifier + \":\" + name; }, function () {\r\n                // Mark this component as having run\r\n                hasRunContext[chainId] = true;\r\n                try {\r\n                    // Set a flag on the next plugin so we know if it was attempted to be executed\r\n                    var nextId = nextProxy ? nextProxy._id : STR_EMPTY;\r\n                    if (nextId) {\r\n                        hasRunContext[nextId] = false;\r\n                    }\r\n                    hasRun = processPluginFn(itemCtx);\r\n                }\r\n                catch (error) {\r\n                    var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;\r\n                    if (hasNextRun) {\r\n                        // The next plugin after us has already run so set this one as complete\r\n                        hasRun = true;\r\n                    }\r\n                    if (!nextProxy || !hasNextRun) {\r\n                        // Either we have no next plugin or the current one did not attempt to call the next plugin\r\n                        // Which means the current one is the root of the failure so log/report this failure\r\n                        _throwInternal(itemCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */](), 1 /* eLoggingSeverity.CRITICAL */, 73 /* _eInternalMessageId.PluginException */, \"Plugin [\" + identifier + \"] failed during \" + name + \" - \" + dumpObj(error) + \", run flags: \" + dumpObj(hasRunContext));\r\n                    }\r\n                }\r\n            }, details, isAsync);\r\n        }\r\n        return hasRun;\r\n    }\r\n    function _processTelemetry(env, itemCtx) {\r\n        itemCtx = itemCtx || _getTelCtx();\r\n        function _callProcessTelemetry(itemCtx) {\r\n            if (!plugin || !hasProcessTelemetry) {\r\n                return false;\r\n            }\r\n            var pluginState = _getPluginState(plugin);\r\n            if (pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] || pluginState[STR_DISABLED]) {\r\n                return false;\r\n            }\r\n            // Ensure that we keep the context in sync (for processNext()), just in case a plugin\r\n            // doesn't calls processTelemetry() instead of itemContext.processNext() or some\r\n            // other form of error occurred\r\n            if (hasSetNext) {\r\n                // Backward compatibility setting the next plugin on the instance\r\n                plugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](nextProxy);\r\n            }\r\n            plugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, itemCtx);\r\n            // Process Telemetry is expected to call itemCtx.processNext() or nextPlugin.processTelemetry()\r\n            return true;\r\n        }\r\n        if (!_processChain(itemCtx, _callProcessTelemetry, \"processTelemetry\", function () { return ({ item: env }); }, !(env.sync))) {\r\n            // The underlying plugin is either not defined, not enabled or does not have a processTelemetry implementation\r\n            // so we still want the next plugin to be executed.\r\n            itemCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);\r\n        }\r\n    }\r\n    function _unloadPlugin(unloadCtx, unloadState) {\r\n        function _callTeardown() {\r\n            // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().\r\n            var hasRun = false;\r\n            if (plugin) {\r\n                var pluginState = _getPluginState(plugin);\r\n                var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE /* @min:%2ecore */];\r\n                // Only teardown the plugin if it was initialized by the current core (i.e. It's not a shared plugin)\r\n                if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */]) {\r\n                    // Handle plugins that don't extend from the BaseTelemetryPlugin\r\n                    pluginState[STR_CORE /* @min:%2ecore */] = null;\r\n                    pluginState[_DYN_TEARDOWN /* @min:%2eteardown */] = true;\r\n                    pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = false;\r\n                    if (plugin[_DYN_TEARDOWN /* @min:%2eteardown */] && plugin[_DYN_TEARDOWN /* @min:%2eteardown */](unloadCtx, unloadState) === true) {\r\n                        // plugin told us that it was going to (or has) call unloadCtx.processNext()\r\n                        hasRun = true;\r\n                    }\r\n                }\r\n            }\r\n            return hasRun;\r\n        }\r\n        if (!_processChain(unloadCtx, _callTeardown, \"unload\", function () { }, unloadState[_DYN_IS_ASYNC /* @min:%2eisAsync */])) {\r\n            // Only called if we hasRun was not true\r\n            unloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](unloadState);\r\n        }\r\n    }\r\n    function _updatePlugin(updateCtx, updateState) {\r\n        function _callUpdate() {\r\n            // Setting default of hasRun as false so the proxyProcessFn() is called as teardown() doesn't have to exist or call unloadNext().\r\n            var hasRun = false;\r\n            if (plugin) {\r\n                var pluginState = _getPluginState(plugin);\r\n                var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE /* @min:%2ecore */];\r\n                // Only update the plugin if it was initialized by the current core (i.e. It's not a shared plugin)\r\n                if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN /* @min:%2eteardown */]) {\r\n                    if (plugin[_DYN_UPDATE /* @min:%2eupdate */] && plugin[_DYN_UPDATE /* @min:%2eupdate */](updateCtx, updateState) === true) {\r\n                        // plugin told us that it was going to (or has) call unloadCtx.processNext()\r\n                        hasRun = true;\r\n                    }\r\n                }\r\n            }\r\n            return hasRun;\r\n        }\r\n        if (!_processChain(updateCtx, _callUpdate, \"update\", function () { }, false)) {\r\n            // Only called if we hasRun was not true\r\n            updateCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](updateState);\r\n        }\r\n    }\r\n    return objFreeze(proxyChain);\r\n}\r\n/**\r\n * This class will be removed!\r\n * @deprecated use createProcessTelemetryContext() instead\r\n */\r\nvar ProcessTelemetryContext = /** @class */ (function () {\r\n    /**\r\n     * Creates a new Telemetry Item context with the current config, core and plugin execution chain\r\n     * @param plugins - The plugin instances that will be executed\r\n     * @param config - The current config\r\n     * @param core - The current core instance\r\n     */\r\n    function ProcessTelemetryContext(pluginChain, config, core, startAt) {\r\n        var _self = this;\r\n        var context = createProcessTelemetryContext(pluginChain, config, core, startAt);\r\n        // Proxy all functions of the context to this object\r\n        proxyFunctions(_self, context, objKeys(context));\r\n    }\r\n    return ProcessTelemetryContext;\r\n}());\r\nexport { ProcessTelemetryContext };\r\n//# sourceMappingURL=ProcessTelemetryContext.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}