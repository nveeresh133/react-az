{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nimport { arrForEach, isFunction } from \"@nevware21/ts-utils\";\nimport { _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_INITIALIZE, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_SPAN_ID, _DYN_TEARDOWN, _DYN_TRACE_FLAGS, _DYN_TRACE_ID, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\nimport { createElmNodeData } from \"./DataCacheHelper\";\nimport { STR_CORE, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\nimport { isValidSpanId, isValidTraceId } from \"./W3cTraceParent\";\nvar pluginStateData = createElmNodeData(\"plugin\");\nexport function _getPluginState(plugin) {\n  return pluginStateData.get(plugin, \"state\", {}, true);\n}\n/**\r\n * Initialize the queue of plugins\r\n * @param plugins - The array of plugins to initialize and setting of the next plugin\r\n * @param config - The current config for the instance\r\n * @param core - THe current core instance\r\n * @param extensions - The extensions\r\n */\nexport function initializePlugins(processContext, extensions) {\n  // Set the next plugin and identified the uninitialized plugins\n  var initPlugins = [];\n  var lastPlugin = null;\n  var proxy = processContext[_DYN_GET_NEXT /* @min:%2egetNext */]();\n  var pluginState;\n  while (proxy) {\n    var thePlugin = proxy[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]();\n    if (thePlugin) {\n      if (lastPlugin && lastPlugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] && thePlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]) {\n        // Set this plugin as the next for the previous one\n        lastPlugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](thePlugin);\n      }\n      pluginState = _getPluginState(thePlugin);\n      var isInitialized = !!pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */];\n      if (thePlugin[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]) {\n        isInitialized = thePlugin[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]();\n      }\n      if (!isInitialized) {\n        initPlugins[_DYN_PUSH /* @min:%2epush */](thePlugin);\n      }\n      lastPlugin = thePlugin;\n      proxy = proxy[_DYN_GET_NEXT /* @min:%2egetNext */]();\n    }\n  }\n  // Now initialize the plugins\n  arrForEach(initPlugins, function (thePlugin) {\n    var core = processContext[STR_CORE /* @min:%2ecore */]();\n    thePlugin[_DYN_INITIALIZE /* @min:%2einitialize */](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT /* @min:%2egetNext */]());\n    pluginState = _getPluginState(thePlugin);\n    // Only add the core to the state if the plugin didn't set it (doesn't extend from BaseTelemetryPlugin)\n    if (!thePlugin[STR_CORE] && !pluginState[STR_CORE]) {\n      pluginState[STR_CORE] = core;\n    }\n    pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = true;\n    delete pluginState[_DYN_TEARDOWN /* @min:%2eteardown */];\n  });\n}\nexport function sortPlugins(plugins) {\n  // Sort by priority\n  return plugins.sort(function (extA, extB) {\n    var result = 0;\n    if (extB) {\n      var bHasProcess = extB[STR_PROCESS_TELEMETRY];\n      if (extA[STR_PROCESS_TELEMETRY]) {\n        result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;\n      } else if (bHasProcess) {\n        result = -1;\n      }\n    } else {\n      result = extA ? 1 : -1;\n    }\n    return result;\n  });\n  // sort complete\n}\n/**\r\n * Teardown / Unload helper to perform teardown/unloading operations for the provided components synchronously or asynchronously, this will call any\r\n * _doTeardown() or _doUnload() functions on the provided components to allow them to finish removal.\r\n * @param components - The components you want to unload\r\n * @param unloadCtx - This is the context that should be used during unloading.\r\n * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.\r\n * @param asyncCallback - An optional callback that the plugin must call if it returns true to inform the caller that it has completed any async unload/teardown operations.\r\n * @returns boolean - true if the plugin has or will call asyncCallback, this allows the plugin to perform any asynchronous operations.\r\n */\nexport function unloadComponents(components, unloadCtx, unloadState, asyncCallback) {\n  var idx = 0;\n  function _doUnload() {\n    while (idx < components[_DYN_LENGTH /* @min:%2elength */]) {\n      var component = components[idx++];\n      if (component) {\n        var func = component._doUnload || component[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */];\n        if (isFunction(func)) {\n          if (func.call(component, unloadCtx, unloadState, _doUnload) === true) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return _doUnload();\n}\n/**\r\n * Creates a IDistributedTraceContext which optionally also \"sets\" the value on a parent\r\n * @param parentCtx - An optional parent distributed trace instance\r\n * @returns A new IDistributedTraceContext instance that uses an internal temporary object\r\n */\nexport function createDistributedTraceContext(parentCtx) {\n  var trace = {};\n  return {\n    getName: function () {\n      return trace[_DYN_NAME /* @min:%2ename */];\n    },\n    setName: function (newValue) {\n      parentCtx && parentCtx.setName(newValue);\n      trace[_DYN_NAME /* @min:%2ename */] = newValue;\n    },\n    getTraceId: function () {\n      return trace[_DYN_TRACE_ID /* @min:%2etraceId */];\n    },\n    setTraceId: function (newValue) {\n      parentCtx && parentCtx.setTraceId(newValue);\n      if (isValidTraceId(newValue)) {\n        trace[_DYN_TRACE_ID /* @min:%2etraceId */] = newValue;\n      }\n    },\n    getSpanId: function () {\n      return trace[_DYN_SPAN_ID /* @min:%2espanId */];\n    },\n    setSpanId: function (newValue) {\n      parentCtx && parentCtx.setSpanId(newValue);\n      if (isValidSpanId(newValue)) {\n        trace[_DYN_SPAN_ID /* @min:%2espanId */] = newValue;\n      }\n    },\n    getTraceFlags: function () {\n      return trace[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */];\n    },\n    setTraceFlags: function (newTraceFlags) {\n      parentCtx && parentCtx.setTraceFlags(newTraceFlags);\n      trace[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */] = newTraceFlags;\n    }\n  };\n}","map":{"version":3,"names":["arrForEach","isFunction","_DYN_GET_NEXT","_DYN_GET_PLUGIN","_DYN_INITIALIZE","_DYN_IS_INITIALIZED","_DYN_LENGTH","_DYN_NAME","_DYN_PUSH","_DYN_SET_NEXT_PLUGIN","_DYN_SPAN_ID","_DYN_TEARDOWN","_DYN_TRACE_FLAGS","_DYN_TRACE_ID","_DYN__DO_TEARDOWN","createElmNodeData","STR_CORE","STR_PRIORITY","STR_PROCESS_TELEMETRY","isValidSpanId","isValidTraceId","pluginStateData","_getPluginState","plugin","get","initializePlugins","processContext","extensions","initPlugins","lastPlugin","proxy","pluginState","thePlugin","isInitialized","core","getCfg","sortPlugins","plugins","sort","extA","extB","result","bHasProcess","unloadComponents","components","unloadCtx","unloadState","asyncCallback","idx","_doUnload","component","func","call","createDistributedTraceContext","parentCtx","trace","getName","setName","newValue","getTraceId","setTraceId","getSpanId","setSpanId","getTraceFlags","setTraceFlags","newTraceFlags"],"sources":["/home/veeresh133/app/api-call/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/TelemetryHelpers.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nimport { arrForEach, isFunction } from \"@nevware21/ts-utils\";\r\nimport { _DYN_GET_NEXT, _DYN_GET_PLUGIN, _DYN_INITIALIZE, _DYN_IS_INITIALIZED, _DYN_LENGTH, _DYN_NAME, _DYN_PUSH, _DYN_SET_NEXT_PLUGIN, _DYN_SPAN_ID, _DYN_TEARDOWN, _DYN_TRACE_FLAGS, _DYN_TRACE_ID, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\r\nimport { createElmNodeData } from \"./DataCacheHelper\";\r\nimport { STR_CORE, STR_PRIORITY, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\r\nimport { isValidSpanId, isValidTraceId } from \"./W3cTraceParent\";\r\nvar pluginStateData = createElmNodeData(\"plugin\");\r\nexport function _getPluginState(plugin) {\r\n    return pluginStateData.get(plugin, \"state\", {}, true);\r\n}\r\n/**\r\n * Initialize the queue of plugins\r\n * @param plugins - The array of plugins to initialize and setting of the next plugin\r\n * @param config - The current config for the instance\r\n * @param core - THe current core instance\r\n * @param extensions - The extensions\r\n */\r\nexport function initializePlugins(processContext, extensions) {\r\n    // Set the next plugin and identified the uninitialized plugins\r\n    var initPlugins = [];\r\n    var lastPlugin = null;\r\n    var proxy = processContext[_DYN_GET_NEXT /* @min:%2egetNext */]();\r\n    var pluginState;\r\n    while (proxy) {\r\n        var thePlugin = proxy[_DYN_GET_PLUGIN /* @min:%2egetPlugin */]();\r\n        if (thePlugin) {\r\n            if (lastPlugin && lastPlugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] && thePlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */]) {\r\n                // Set this plugin as the next for the previous one\r\n                lastPlugin[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */](thePlugin);\r\n            }\r\n            pluginState = _getPluginState(thePlugin);\r\n            var isInitialized = !!pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */];\r\n            if (thePlugin[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]) {\r\n                isInitialized = thePlugin[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */]();\r\n            }\r\n            if (!isInitialized) {\r\n                initPlugins[_DYN_PUSH /* @min:%2epush */](thePlugin);\r\n            }\r\n            lastPlugin = thePlugin;\r\n            proxy = proxy[_DYN_GET_NEXT /* @min:%2egetNext */]();\r\n        }\r\n    }\r\n    // Now initialize the plugins\r\n    arrForEach(initPlugins, function (thePlugin) {\r\n        var core = processContext[STR_CORE /* @min:%2ecore */]();\r\n        thePlugin[_DYN_INITIALIZE /* @min:%2einitialize */](processContext.getCfg(), core, extensions, processContext[_DYN_GET_NEXT /* @min:%2egetNext */]());\r\n        pluginState = _getPluginState(thePlugin);\r\n        // Only add the core to the state if the plugin didn't set it (doesn't extend from BaseTelemetryPlugin)\r\n        if (!thePlugin[STR_CORE] && !pluginState[STR_CORE]) {\r\n            pluginState[STR_CORE] = core;\r\n        }\r\n        pluginState[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = true;\r\n        delete pluginState[_DYN_TEARDOWN /* @min:%2eteardown */];\r\n    });\r\n}\r\nexport function sortPlugins(plugins) {\r\n    // Sort by priority\r\n    return plugins.sort(function (extA, extB) {\r\n        var result = 0;\r\n        if (extB) {\r\n            var bHasProcess = extB[STR_PROCESS_TELEMETRY];\r\n            if (extA[STR_PROCESS_TELEMETRY]) {\r\n                result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;\r\n            }\r\n            else if (bHasProcess) {\r\n                result = -1;\r\n            }\r\n        }\r\n        else {\r\n            result = extA ? 1 : -1;\r\n        }\r\n        return result;\r\n    });\r\n    // sort complete\r\n}\r\n/**\r\n * Teardown / Unload helper to perform teardown/unloading operations for the provided components synchronously or asynchronously, this will call any\r\n * _doTeardown() or _doUnload() functions on the provided components to allow them to finish removal.\r\n * @param components - The components you want to unload\r\n * @param unloadCtx - This is the context that should be used during unloading.\r\n * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.\r\n * @param asyncCallback - An optional callback that the plugin must call if it returns true to inform the caller that it has completed any async unload/teardown operations.\r\n * @returns boolean - true if the plugin has or will call asyncCallback, this allows the plugin to perform any asynchronous operations.\r\n */\r\nexport function unloadComponents(components, unloadCtx, unloadState, asyncCallback) {\r\n    var idx = 0;\r\n    function _doUnload() {\r\n        while (idx < components[_DYN_LENGTH /* @min:%2elength */]) {\r\n            var component = components[idx++];\r\n            if (component) {\r\n                var func = component._doUnload || component[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */];\r\n                if (isFunction(func)) {\r\n                    if (func.call(component, unloadCtx, unloadState, _doUnload) === true) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return _doUnload();\r\n}\r\n/**\r\n * Creates a IDistributedTraceContext which optionally also \"sets\" the value on a parent\r\n * @param parentCtx - An optional parent distributed trace instance\r\n * @returns A new IDistributedTraceContext instance that uses an internal temporary object\r\n */\r\nexport function createDistributedTraceContext(parentCtx) {\r\n    var trace = {};\r\n    return {\r\n        getName: function () {\r\n            return trace[_DYN_NAME /* @min:%2ename */];\r\n        },\r\n        setName: function (newValue) {\r\n            parentCtx && parentCtx.setName(newValue);\r\n            trace[_DYN_NAME /* @min:%2ename */] = newValue;\r\n        },\r\n        getTraceId: function () {\r\n            return trace[_DYN_TRACE_ID /* @min:%2etraceId */];\r\n        },\r\n        setTraceId: function (newValue) {\r\n            parentCtx && parentCtx.setTraceId(newValue);\r\n            if (isValidTraceId(newValue)) {\r\n                trace[_DYN_TRACE_ID /* @min:%2etraceId */] = newValue;\r\n            }\r\n        },\r\n        getSpanId: function () {\r\n            return trace[_DYN_SPAN_ID /* @min:%2espanId */];\r\n        },\r\n        setSpanId: function (newValue) {\r\n            parentCtx && parentCtx.setSpanId(newValue);\r\n            if (isValidSpanId(newValue)) {\r\n                trace[_DYN_SPAN_ID /* @min:%2espanId */] = newValue;\r\n            }\r\n        },\r\n        getTraceFlags: function () {\r\n            return trace[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */];\r\n        },\r\n        setTraceFlags: function (newTraceFlags) {\r\n            parentCtx && parentCtx.setTraceFlags(newTraceFlags);\r\n            trace[_DYN_TRACE_FLAGS /* @min:%2etraceFlags */] = newTraceFlags;\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=TelemetryHelpers.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}