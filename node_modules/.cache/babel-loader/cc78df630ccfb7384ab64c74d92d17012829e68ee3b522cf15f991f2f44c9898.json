{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nvar _a;\nimport { getGlobal, objCreate, objHasOwnProperty, throwTypeError } from \"@nevware21/ts-utils\";\n;\nvar UNDEFINED = \"undefined\";\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar Constructor = 'constructor';\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar Prototype = 'prototype';\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar strFunction = 'function';\n/**\r\n * Used to define the name of the instance function lookup table\r\n * @ignore\r\n */\nvar DynInstFuncTable = '_dynInstFuncs';\n/**\r\n * Name used to tag the dynamic prototype function\r\n * @ignore\r\n */\nvar DynProxyTag = '_isDynProxy';\n/**\r\n * Name added to a prototype to define the dynamic prototype \"class\" name used to lookup the function table\r\n * @ignore\r\n */\nvar DynClassName = '_dynClass';\n/**\r\n * Prefix added to the classname to avoid any name clashes with other instance level properties\r\n * @ignore\r\n */\nvar DynClassNamePrefix = '_dynCls$';\n/**\r\n * A tag which is used to check if we have already to attempted to set the instance function if one is not present\r\n * @ignore\r\n */\nvar DynInstChkTag = '_dynInstChk';\n/**\r\n * A tag which is used to check if we are allows to try and set an instance function is one is not present. Using the same\r\n * tag name as the function level but a different const name for readability only.\r\n */\nvar DynAllowInstChkTag = DynInstChkTag;\n/**\r\n * The global (imported) instances where the global performance options are stored\r\n */\nvar DynProtoDefaultOptions = '_dfOpts';\n/**\r\n * Value used as the name of a class when it cannot be determined\r\n * @ignore\r\n */\nvar UnknownValue = '_unknown_';\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar str__Proto = \"__proto__\";\n/**\r\n * The polyfill version of __proto__ so that it doesn't cause issues for anyone not expecting it to exist\r\n */\nvar DynProtoBaseProto = \"_dyn\" + str__Proto;\n/**\r\n * Runtime Global holder for dynamicProto settings\r\n */\nvar DynProtoGlobalSettings = \"__dynProto$Gbl\";\n/**\r\n * Track the current prototype for IE8 as you can't look back to get the prototype\r\n */\nvar DynProtoCurrent = \"_dynInstProto\";\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar strUseBaseInst = 'useBaseInst';\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\nvar strSetInstFuncs = 'setInstFuncs';\nvar Obj = Object;\n/**\r\n * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)\r\n * @ignore\r\n */\nvar _objGetPrototypeOf = Obj[\"getPrototypeOf\"];\n/**\r\n * Pre-lookup to check for the existence of this function\r\n */\nvar _objGetOwnProps = Obj[\"getOwnPropertyNames\"];\n// Since 1.1.7 moving these to the runtime global to work around mixed version and module issues\n// See Issue https://github.com/microsoft/DynamicProto-JS/issues/57 for details\nvar _gbl = getGlobal();\nvar _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {\n  o: (_a = {}, _a[strSetInstFuncs] = true, _a[strUseBaseInst] = true, _a),\n  n: 1000 // Start new global index @ 1000 so we \"fix\" some cases when mixed with 1.1.6 or earlier\n});\n/**\r\n * Helper used to check whether the target is an Object prototype or Array prototype\r\n * @ignore\r\n */\nfunction _isObjectOrArrayPrototype(target) {\n  return target && (target === Obj[Prototype] || target === Array[Prototype]);\n}\n/**\r\n * Helper used to check whether the target is an Object prototype, Array prototype or Function prototype\r\n * @ignore\r\n */\nfunction _isObjectArrayOrFunctionPrototype(target) {\n  return _isObjectOrArrayPrototype(target) || target === Function[Prototype];\n}\n/**\r\n * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.\r\n * @ignore\r\n */\nfunction _getObjProto(target) {\n  var newProto;\n  if (target) {\n    // This method doesn't exist in older browsers (e.g. IE8)\n    if (_objGetPrototypeOf) {\n      return _objGetPrototypeOf(target);\n    }\n    var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);\n    // Using the pre-calculated value as IE8 doesn't support looking up the prototype of a prototype and thus fails for more than 1 base class\n    newProto = target[DynProtoBaseProto] || curProto;\n    if (!objHasOwnProperty(target, DynProtoBaseProto)) {\n      // As this prototype doesn't have this property then this is from an inherited class so newProto is the base to return so save it\n      // so we can look it up value (which for a multiple hierarchy dynamicProto will be the base class)\n      delete target[DynProtoCurrent]; // Delete any current value allocated to this instance so we pick up the value from prototype hierarchy\n      newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];\n      target[DynProtoCurrent] = curProto;\n    }\n  }\n  return newProto;\n}\n/**\r\n * Helper to get the properties of an object, including none enumerable ones as functions on a prototype in ES6\r\n * are not enumerable.\r\n * @param target\r\n */\nfunction _forEachProp(target, func) {\n  var props = [];\n  if (_objGetOwnProps) {\n    props = _objGetOwnProps(target);\n  } else {\n    for (var name_1 in target) {\n      if (typeof name_1 === \"string\" && objHasOwnProperty(target, name_1)) {\n        props.push(name_1);\n      }\n    }\n  }\n  if (props && props.length > 0) {\n    for (var lp = 0; lp < props.length; lp++) {\n      func(props[lp]);\n    }\n  }\n}\n/**\r\n * Helper function to check whether the provided function name is a potential candidate for dynamic\r\n * callback and prototype generation.\r\n * @param target The target object, may be a prototype or class object\r\n * @param funcName The function name\r\n * @param skipOwn Skips the check for own property\r\n * @ignore\r\n */\nfunction _isDynamicCandidate(target, funcName, skipOwn) {\n  return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype;\n}\n/**\r\n * Helper to throw a TypeError exception\r\n * @param message the message\r\n * @ignore\r\n */\nfunction _throwTypeError(message) {\n  throwTypeError(\"DynamicProto: \" + message);\n}\n/**\r\n * Returns a collection of the instance functions that are defined directly on the thisTarget object, it does\r\n * not return any inherited functions\r\n * @param thisTarget The object to get the instance functions from\r\n * @ignore\r\n */\nfunction _getInstanceFuncs(thisTarget) {\n  // Get the base proto\n  var instFuncs = objCreate(null);\n  // Save any existing instance functions\n  _forEachProp(thisTarget, function (name) {\n    // Don't include any dynamic prototype instances - as we only want the real functions\n    if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {\n      // Create an instance callback for passing the base function to the caller\n      instFuncs[name] = thisTarget[name];\n    }\n  });\n  return instFuncs;\n}\n/**\r\n * Returns whether the value is included in the array\r\n * @param values The array of values\r\n * @param value  The value\r\n */\nfunction _hasVisited(values, value) {\n  for (var lp = values.length - 1; lp >= 0; lp--) {\n    if (values[lp] === value) {\n      return true;\n    }\n  }\n  return false;\n}\n/**\r\n * Returns an object that contains callback functions for all \"base/super\" functions, this is used to \"save\"\r\n * enabling calling super.xxx() functions without requiring that the base \"class\" has defined a prototype references\r\n * @param target The current instance\r\n * @ignore\r\n */\nfunction _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {\n  function _instFuncProxy(target, funcHost, funcName) {\n    var theFunc = funcHost[funcName];\n    if (theFunc[DynProxyTag] && useBaseInst) {\n      // grab and reuse the hosted looking function (if available) otherwise the original passed function\n      var instFuncTable = target[DynInstFuncTable] || {};\n      if (instFuncTable[DynAllowInstChkTag] !== false) {\n        theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;\n      }\n    }\n    return function () {\n      // eslint-disable-next-line prefer-rest-params\n      return theFunc.apply(target, arguments);\n    };\n  }\n  // Start creating a new baseFuncs by creating proxies for the instance functions (as they may get replaced)\n  var baseFuncs = objCreate(null);\n  _forEachProp(instFuncs, function (name) {\n    // Create an instance callback for passing the base function to the caller\n    baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);\n  });\n  // Get the base prototype functions\n  var baseProto = _getObjProto(classProto);\n  var visited = [];\n  // Don't include base object functions for Object, Array or Function\n  while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {\n    // look for prototype functions\n    _forEachProp(baseProto, function (name) {\n      // Don't include any dynamic prototype instances - as we only want the real functions\n      // For IE 7/8 the prototype lookup doesn't provide the full chain so we need to bypass the \n      // hasOwnProperty check we get all of the methods, main difference is that IE7/8 doesn't return\n      // the Object prototype methods while bypassing the check\n      if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {\n        // Create an instance callback for passing the base function to the caller\n        baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);\n      }\n    });\n    // We need to find all possible functions that might be overloaded by walking the entire prototype chain\n    // This avoids the caller from needing to check whether it's direct base class implements the function or not\n    // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\n    visited.push(baseProto);\n    baseProto = _getObjProto(baseProto);\n  }\n  return baseFuncs;\n}\nfunction _getInstFunc(target, funcName, proto, currentDynProtoProxy) {\n  var instFunc = null;\n  // We need to check whether the class name is defined directly on this prototype otherwise\n  // it will walk the proto chain and return any parent proto classname.\n  if (target && objHasOwnProperty(proto, DynClassName)) {\n    var instFuncTable = target[DynInstFuncTable] || objCreate(null);\n    instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];\n    if (!instFunc) {\n      // Avoid stack overflow from recursive calling the same function\n      _throwTypeError(\"Missing [\" + funcName + \"] \" + strFunction);\n    }\n    // We have the instance function, lets check it we can speed up further calls\n    // by adding the instance function back directly on the instance (avoiding the dynamic func lookup)\n    if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {\n      // If the instance already has an instance function we can't replace it\n      var canAddInst = !objHasOwnProperty(target, funcName);\n      // Get current prototype\n      var objProto = _getObjProto(target);\n      var visited = [];\n      // Lookup the function starting at the top (instance level prototype) and traverse down, if the first matching function\n      // if nothing is found or if the first hit is a dynamic proto instance then we can safely add an instance shortcut\n      while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {\n        var protoFunc = objProto[funcName];\n        if (protoFunc) {\n          canAddInst = protoFunc === currentDynProtoProxy;\n          break;\n        }\n        // We need to find all possible initial functions to ensure that we don't bypass a valid override function\n        visited.push(objProto);\n        objProto = _getObjProto(objProto);\n      }\n      try {\n        if (canAddInst) {\n          // This instance doesn't have an instance func and the class hierarchy does have a higher level prototype version\n          // so it's safe to directly assign for any subsequent calls (for better performance)\n          target[funcName] = instFunc;\n        }\n        // Block further attempts to set the instance function for any\n        instFunc[DynInstChkTag] = 1;\n      } catch (e) {\n        // Don't crash if the object is readonly or the runtime doesn't allow changing this\n        // And set a flag so we don't try again for any function\n        instFuncTable[DynAllowInstChkTag] = false;\n      }\n    }\n  }\n  return instFunc;\n}\nfunction _getProtoFunc(funcName, proto, currentDynProtoProxy) {\n  var protoFunc = proto[funcName];\n  // Check that the prototype function is not a self reference -- try to avoid stack overflow!\n  if (protoFunc === currentDynProtoProxy) {\n    // It is so lookup the base prototype\n    protoFunc = _getObjProto(proto)[funcName];\n  }\n  if (typeof protoFunc !== strFunction) {\n    _throwTypeError(\"[\" + funcName + \"] is not a \" + strFunction);\n  }\n  return protoFunc;\n}\n/**\r\n * Add the required dynamic prototype methods to the the class prototype\r\n * @param proto - The class prototype\r\n * @param className - The instance classname\r\n * @param target - The target instance\r\n * @param baseInstFuncs - The base instance functions\r\n * @param setInstanceFunc - Flag to allow prototype function to reset the instance function if one does not exist\r\n * @ignore\r\n */\nfunction _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {\n  function _createDynamicPrototype(proto, funcName) {\n    var dynProtoProxy = function () {\n      // Use the instance or prototype function\n      var instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);\n      // eslint-disable-next-line prefer-rest-params\n      return instFunc.apply(this, arguments);\n    };\n    // Tag this function as a proxy to support replacing dynamic proxy elements (primary use case is for unit testing\n    // via which can dynamically replace the prototype function reference)\n    dynProtoProxy[DynProxyTag] = 1;\n    return dynProtoProxy;\n  }\n  if (!_isObjectOrArrayPrototype(proto)) {\n    var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);\n    if (!_isObjectOrArrayPrototype(instFuncTable)) {\n      var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || objCreate(null); // fetch and assign if as it may not exist yet\n      // Set whether we are allow to lookup instances, if someone has set to false then do not re-enable\n      if (instFuncTable[DynAllowInstChkTag] !== false) {\n        instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;\n      }\n      if (!_isObjectOrArrayPrototype(instFuncs_1)) {\n        _forEachProp(target, function (name) {\n          // Only add overridden functions\n          if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name]) {\n            // Save the instance Function to the lookup table and remove it from the instance as it's not a dynamic proto function\n            instFuncs_1[name] = target[name];\n            delete target[name];\n            // Add a dynamic proto if one doesn't exist or if a prototype function exists and it's not a dynamic one\n            if (!objHasOwnProperty(proto, name) || proto[name] && !proto[name][DynProxyTag]) {\n              proto[name] = _createDynamicPrototype(proto, name);\n            }\n          }\n        });\n      }\n    }\n  }\n}\n/**\r\n * Checks whether the passed prototype object appears to be correct by walking the prototype hierarchy of the instance\r\n * @param classProto The class prototype instance\r\n * @param thisTarget The current instance that will be checked whether the passed prototype instance is in the hierarchy\r\n * @ignore\r\n */\nfunction _checkPrototype(classProto, thisTarget) {\n  // This method doesn't existing in older browsers (e.g. IE8)\n  if (_objGetPrototypeOf) {\n    // As this is primarily a coding time check, don't bother checking if running in IE8 or lower\n    var visited = [];\n    var thisProto = _getObjProto(thisTarget);\n    while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {\n      if (thisProto === classProto) {\n        return true;\n      }\n      // This avoids the caller from needing to check whether it's direct base class implements the function or not\n      // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\n      visited.push(thisProto);\n      thisProto = _getObjProto(thisProto);\n    }\n    return false;\n  }\n  // If objGetPrototypeOf doesn't exist then just assume everything is ok.\n  return true;\n}\n/**\r\n * Gets the current prototype name using the ES6 name if available otherwise falling back to a use unknown as the name.\r\n * It's not critical for this to return a name, it's used to decorate the generated unique name for easier debugging only.\r\n * @param target\r\n * @param unknownValue\r\n * @ignore\r\n */\nfunction _getObjName(target, unknownValue) {\n  if (objHasOwnProperty(target, Prototype)) {\n    // Look like a prototype\n    return target.name || unknownValue || UnknownValue;\n  }\n  return ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;\n}\n/**\r\n * Helper function when creating dynamic (inline) functions for classes, this helper performs the following tasks :-\r\n * - Saves references to all defined base class functions\r\n * - Calls the delegateFunc with the current target (this) and a base object reference that can be used to call all \"super\" functions.\r\n * - Will populate the class prototype for all overridden functions to support class extension that call the prototype instance.\r\n * Callers should use this helper when declaring all function within the constructor of a class, as mentioned above the delegateFunc is\r\n * passed both the target \"this\" and an object that can be used to call any base (super) functions, using this based object in place of\r\n * super.XXX() (which gets expanded to _super.prototype.XXX()) provides a better minification outcome and also ensures the correct \"this\"\r\n * context is maintained as TypeScript creates incorrect references using super.XXXX() for dynamically defined functions i.e. Functions\r\n * defined in the constructor or some other function (rather than declared as complete typescript functions).\r\n * ### Usage\r\n * ```typescript\r\n * import dynamicProto from \"@microsoft/dynamicproto-js\";\r\n * class ExampleClass extends BaseClass {\r\n *     constructor() {\r\n *         dynamicProto(ExampleClass, this, (_self, base) => {\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.newFunc = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     ...\r\n *                 }\r\n *             }\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.myFunction = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     // Call the base version of the function that we are overriding\r\n *                     base.myFunction();\r\n *                 }\r\n *                 ...\r\n *             }\r\n *             _self.initialize = () => {\r\n *                 ...\r\n *             }\r\n *             // Warnings: While the following will work as _self is simply a reference to\r\n *             // this, if anyone overrides myFunction() the overridden will be called first\r\n *             // as the normal JavaScript method resolution will occur and the defined\r\n *             // _self.initialize() function is actually gets removed from the instance and\r\n *             // a proxy prototype version is created to reference the created method.\r\n *             _self.initialize();\r\n *         });\r\n *     }\r\n * }\r\n * ```\r\n * @typeparam DPType This is the generic type of the class, used to keep intellisense valid\r\n * @typeparam DPCls The type that contains the prototype of the current class\r\n * @param theClass - This is the current class instance which contains the prototype for the current class\r\n * @param target - The current \"this\" (target) reference, when the class has been extended this.prototype will not be the 'theClass' value.\r\n * @param delegateFunc - The callback function (closure) that will create the dynamic function\r\n * @param options - Additional options to configure how the dynamic prototype operates\r\n */\nexport default function dynamicProto(theClass, target, delegateFunc, options) {\n  // Make sure that the passed theClass argument looks correct\n  if (!objHasOwnProperty(theClass, Prototype)) {\n    _throwTypeError(\"theClass is an invalid class definition.\");\n  }\n  // Quick check to make sure that the passed theClass argument looks correct (this is a common copy/paste error)\n  var classProto = theClass[Prototype];\n  if (!_checkPrototype(classProto, target)) {\n    _throwTypeError(\"[\" + _getObjName(theClass) + \"] not in hierarchy of [\" + _getObjName(target) + \"]\");\n  }\n  var className = null;\n  if (objHasOwnProperty(classProto, DynClassName)) {\n    // Only grab the class name if it's defined on this prototype (i.e. don't walk the prototype chain)\n    className = classProto[DynClassName];\n  } else {\n    // As not all browser support name on the prototype creating a unique dynamic one if we have not already\n    // assigned one, so we can use a simple string as the lookup rather than an object for the dynamic instance\n    // function table lookup.\n    className = DynClassNamePrefix + _getObjName(theClass, \"_\") + \"$\" + _gblInst.n;\n    _gblInst.n++;\n    classProto[DynClassName] = className;\n  }\n  var perfOptions = dynamicProto[DynProtoDefaultOptions];\n  var useBaseInst = !!perfOptions[strUseBaseInst];\n  if (useBaseInst && options && options[strUseBaseInst] !== undefined) {\n    useBaseInst = !!options[strUseBaseInst];\n  }\n  // Get the current instance functions\n  var instFuncs = _getInstanceFuncs(target);\n  // Get all of the functions for any base instance (before they are potentially overridden)\n  var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);\n  // Execute the delegate passing in both the current target \"this\" and \"base\" function references\n  // Note casting the same type as we don't actually have the base class here and this will provide some intellisense support\n  delegateFunc(target, baseFuncs);\n  // Don't allow setting instance functions for older IE instances\n  var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];\n  if (setInstanceFunc && options) {\n    setInstanceFunc = !!options[strSetInstFuncs];\n  }\n  // Populate the Prototype for any overridden instance functions\n  _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);\n}\n/**\r\n * Exposes the default global options to allow global configuration, if the global values are disabled these will override\r\n * any passed values. This is primarily exposed to support unit-testing without the need for individual classes to expose\r\n * their internal usage of dynamic proto.\r\n */\ndynamicProto[DynProtoDefaultOptions] = _gblInst.o;","map":{"version":3,"names":["getGlobal","objCreate","objHasOwnProperty","throwTypeError","UNDEFINED","Constructor","Prototype","strFunction","DynInstFuncTable","DynProxyTag","DynClassName","DynClassNamePrefix","DynInstChkTag","DynAllowInstChkTag","DynProtoDefaultOptions","UnknownValue","str__Proto","DynProtoBaseProto","DynProtoGlobalSettings","DynProtoCurrent","strUseBaseInst","strSetInstFuncs","Obj","Object","_objGetPrototypeOf","_objGetOwnProps","_gbl","_gblInst","o","_a","n","_isObjectOrArrayPrototype","target","Array","_isObjectArrayOrFunctionPrototype","Function","_getObjProto","newProto","curProto","_forEachProp","func","props","name_1","push","length","lp","_isDynamicCandidate","funcName","skipOwn","_throwTypeError","message","_getInstanceFuncs","thisTarget","instFuncs","name","_hasVisited","values","value","_getBaseFuncs","classProto","useBaseInst","_instFuncProxy","funcHost","theFunc","instFuncTable","apply","arguments","baseFuncs","baseProto","visited","_getInstFunc","proto","currentDynProtoProxy","instFunc","canAddInst","objProto","protoFunc","e","_getProtoFunc","_populatePrototype","className","baseInstFuncs","setInstanceFunc","_createDynamicPrototype","dynProtoProxy","instFuncs_1","_checkPrototype","thisProto","_getObjName","unknownValue","dynamicProto","theClass","delegateFunc","options","perfOptions","undefined"],"sources":["/home/veeresh133/app/test-error-react/react-az/node_modules/@microsoft/dynamicproto-js/src/DynamicProto.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\r\nimport { getGlobal, objCreate, objHasOwnProperty, throwTypeError } from \"@nevware21/ts-utils\";\r\n\r\ninterface DynamicGlobalSettings {\r\n    /**\r\n     * Stores the global options which will also be exposed on the runtime global\r\n     */\r\n    o: IDynamicProtoOpts,\r\n\r\n    /**\r\n     * Internal Global used to generate a unique dynamic class name, every new class will increase this value\r\n     * @ignore\r\n     */ \r\n    n: number\r\n};\r\n\r\nconst UNDEFINED = \"undefined\";\r\n\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */ \r\nconst Constructor = 'constructor';\r\n\r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */ \r\nconst Prototype = 'prototype';\r\n \r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nconst strFunction = 'function';\r\n\r\n/**\r\n * Used to define the name of the instance function lookup table\r\n * @ignore\r\n */ \r\nconst DynInstFuncTable = '_dynInstFuncs';\r\n \r\n/**\r\n * Name used to tag the dynamic prototype function\r\n * @ignore\r\n */ \r\nconst DynProxyTag = '_isDynProxy';\r\n \r\n/**\r\n * Name added to a prototype to define the dynamic prototype \"class\" name used to lookup the function table\r\n * @ignore\r\n */ \r\nconst DynClassName = '_dynClass';\r\n \r\n/**\r\n * Prefix added to the classname to avoid any name clashes with other instance level properties\r\n * @ignore\r\n */ \r\nconst DynClassNamePrefix = '_dynCls$';\r\n \r\n/**\r\n * A tag which is used to check if we have already to attempted to set the instance function if one is not present\r\n * @ignore\r\n */\r\nconst DynInstChkTag = '_dynInstChk';\r\n \r\n/**\r\n * A tag which is used to check if we are allows to try and set an instance function is one is not present. Using the same \r\n * tag name as the function level but a different const name for readability only.\r\n */\r\nconst DynAllowInstChkTag = DynInstChkTag;\r\n \r\n/**\r\n * The global (imported) instances where the global performance options are stored\r\n */\r\nconst DynProtoDefaultOptions = '_dfOpts';\r\n \r\n/**\r\n * Value used as the name of a class when it cannot be determined\r\n * @ignore\r\n */ \r\nconst UnknownValue = '_unknown_';\r\n \r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nconst str__Proto = \"__proto__\";\r\n \r\n/**\r\n * The polyfill version of __proto__ so that it doesn't cause issues for anyone not expecting it to exist\r\n */\r\nconst DynProtoBaseProto = \"_dyn\" + str__Proto;\r\n\r\n/**\r\n * Runtime Global holder for dynamicProto settings\r\n */\r\nconst DynProtoGlobalSettings = \"__dynProto$Gbl\";\r\n\r\n/**\r\n * Track the current prototype for IE8 as you can't look back to get the prototype\r\n */\r\nconst DynProtoCurrent = \"_dynInstProto\";\r\n  \r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nconst strUseBaseInst = 'useBaseInst';\r\n \r\n/**\r\n * Constant string defined to support minimization\r\n * @ignore\r\n */\r\nconst strSetInstFuncs = 'setInstFuncs';\r\n \r\nconst Obj = Object;\r\n\r\n/**\r\n * Pre-lookup to check if we are running on a modern browser (i.e. not IE8)\r\n * @ignore\r\n */\r\nlet _objGetPrototypeOf = Obj[\"getPrototypeOf\"];\r\n\r\n/**\r\n * Pre-lookup to check for the existence of this function\r\n */\r\nlet _objGetOwnProps = Obj[\"getOwnPropertyNames\"];\r\n\r\n// Since 1.1.7 moving these to the runtime global to work around mixed version and module issues\r\n// See Issue https://github.com/microsoft/DynamicProto-JS/issues/57 for details\r\nlet _gbl = getGlobal();\r\nlet _gblInst: DynamicGlobalSettings = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {\r\n    o: {\r\n        [strSetInstFuncs]: true,\r\n        [strUseBaseInst]: true\r\n    },\r\n    n: 1000                // Start new global index @ 1000 so we \"fix\" some cases when mixed with 1.1.6 or earlier\r\n});\r\n\r\n/**\r\n * Helper used to check whether the target is an Object prototype or Array prototype\r\n * @ignore\r\n */ \r\nfunction _isObjectOrArrayPrototype(target:any) {\r\n    return target && (target === Obj[Prototype] || target === Array[Prototype]);\r\n}\r\n\r\n/**\r\n * Helper used to check whether the target is an Object prototype, Array prototype or Function prototype\r\n * @ignore\r\n */ \r\nfunction _isObjectArrayOrFunctionPrototype(target:any) {\r\n    return _isObjectOrArrayPrototype(target) || target === Function[Prototype];\r\n}\r\n\r\n/**\r\n * Helper used to get the prototype of the target object as getPrototypeOf is not available in an ES3 environment.\r\n * @ignore\r\n */ \r\nfunction _getObjProto(target:any) {\r\n    let newProto;\r\n\r\n    if (target) {\r\n        // This method doesn't exist in older browsers (e.g. IE8)\r\n        if (_objGetPrototypeOf) {\r\n            return _objGetPrototypeOf(target);\r\n        }\r\n\r\n        let curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);\r\n\r\n        // Using the pre-calculated value as IE8 doesn't support looking up the prototype of a prototype and thus fails for more than 1 base class\r\n        newProto = target[DynProtoBaseProto] || curProto;\r\n        if (!objHasOwnProperty(target, DynProtoBaseProto)) {\r\n            // As this prototype doesn't have this property then this is from an inherited class so newProto is the base to return so save it\r\n            // so we can look it up value (which for a multiple hierarchy dynamicProto will be the base class)\r\n            delete target[DynProtoCurrent];     // Delete any current value allocated to this instance so we pick up the value from prototype hierarchy\r\n            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];\r\n            target[DynProtoCurrent] = curProto;\r\n        }\r\n    }\r\n\r\n    return newProto;\r\n}\r\n\r\n/**\r\n * Helper to get the properties of an object, including none enumerable ones as functions on a prototype in ES6\r\n * are not enumerable.\r\n * @param target \r\n */\r\nfunction _forEachProp(target: any, func: (name: string) => void) {\r\n    let props: string[] = [];\r\n    if (_objGetOwnProps) {\r\n        props = _objGetOwnProps(target);\r\n    } else {\r\n        for (let name in target) {\r\n            if (typeof name === \"string\" && objHasOwnProperty(target, name)) {\r\n                props.push(name);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (props && props.length > 0) {\r\n        for (let lp = 0; lp < props.length; lp++) {\r\n            func(props[lp]);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function to check whether the provided function name is a potential candidate for dynamic\r\n * callback and prototype generation.\r\n * @param target The target object, may be a prototype or class object\r\n * @param funcName The function name\r\n * @param skipOwn Skips the check for own property\r\n * @ignore\r\n */\r\nfunction _isDynamicCandidate(target:any, funcName:string, skipOwn:boolean) {\r\n    return (funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || objHasOwnProperty(target, funcName)) && funcName !== str__Proto && funcName !== Prototype);\r\n}\r\n\r\n/**\r\n * Helper to throw a TypeError exception\r\n * @param message the message\r\n * @ignore\r\n */\r\nfunction _throwTypeError(message:string) {\r\n    throwTypeError(\"DynamicProto: \" + message);\r\n}\r\n\r\n/**\r\n * Returns a collection of the instance functions that are defined directly on the thisTarget object, it does \r\n * not return any inherited functions\r\n * @param thisTarget The object to get the instance functions from\r\n * @ignore\r\n */\r\nfunction _getInstanceFuncs(thisTarget:any): any {\r\n    // Get the base proto\r\n    var instFuncs = objCreate(null);\r\n\r\n    // Save any existing instance functions\r\n    _forEachProp(thisTarget, (name) => {\r\n        // Don't include any dynamic prototype instances - as we only want the real functions\r\n        if (!instFuncs[name] && _isDynamicCandidate(thisTarget, name, false)) {\r\n            // Create an instance callback for passing the base function to the caller\r\n            instFuncs[name] = thisTarget[name];\r\n        }\r\n    });\r\n\r\n    return instFuncs;\r\n}\r\n\r\n/**\r\n * Returns whether the value is included in the array\r\n * @param values The array of values\r\n * @param value  The value\r\n */\r\nfunction _hasVisited(values:any[], value:any) {\r\n    for (let lp = values.length - 1; lp >= 0; lp--) {\r\n        if (values[lp] === value) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Returns an object that contains callback functions for all \"base/super\" functions, this is used to \"save\"\r\n * enabling calling super.xxx() functions without requiring that the base \"class\" has defined a prototype references\r\n * @param target The current instance\r\n * @ignore\r\n */\r\nfunction _getBaseFuncs(classProto:any, thisTarget:any, instFuncs:any, useBaseInst:boolean): any {\r\n    function _instFuncProxy(target:any, funcHost: any,  funcName: string) {\r\n        let theFunc = funcHost[funcName];\r\n        if (theFunc[DynProxyTag] && useBaseInst) {\r\n            // grab and reuse the hosted looking function (if available) otherwise the original passed function\r\n            let instFuncTable = target[DynInstFuncTable] || {};\r\n            if (instFuncTable[DynAllowInstChkTag] !== false) {\r\n                theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;\r\n            }\r\n        }\r\n\r\n        return function() {\r\n            // eslint-disable-next-line prefer-rest-params\r\n            return theFunc.apply(target, arguments);\r\n        };\r\n    }\r\n\r\n    // Start creating a new baseFuncs by creating proxies for the instance functions (as they may get replaced)\r\n    var baseFuncs = objCreate(null);\r\n    _forEachProp(instFuncs, (name) => {\r\n        // Create an instance callback for passing the base function to the caller\r\n        baseFuncs[name] = _instFuncProxy(thisTarget, instFuncs, name);\r\n    });\r\n    \r\n    // Get the base prototype functions\r\n    var baseProto = _getObjProto(classProto);\r\n    let visited:any[] = [];\r\n\r\n    // Don't include base object functions for Object, Array or Function\r\n    while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {\r\n        // look for prototype functions\r\n        _forEachProp(baseProto, (name) => {\r\n            // Don't include any dynamic prototype instances - as we only want the real functions\r\n            // For IE 7/8 the prototype lookup doesn't provide the full chain so we need to bypass the \r\n            // hasOwnProperty check we get all of the methods, main difference is that IE7/8 doesn't return\r\n            // the Object prototype methods while bypassing the check\r\n            if (!baseFuncs[name] && _isDynamicCandidate(baseProto, name, !_objGetPrototypeOf)) {\r\n                // Create an instance callback for passing the base function to the caller\r\n                baseFuncs[name] = _instFuncProxy(thisTarget, baseProto, name);\r\n            }\r\n        });\r\n\r\n        // We need to find all possible functions that might be overloaded by walking the entire prototype chain\r\n        // This avoids the caller from needing to check whether it's direct base class implements the function or not\r\n        // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\r\n        visited.push(baseProto);\r\n        baseProto = _getObjProto(baseProto);\r\n    }\r\n\r\n    return baseFuncs;\r\n}\r\n\r\nfunction _getInstFunc(target: any, funcName: string, proto: any, currentDynProtoProxy: any) {\r\n    let instFunc = null;\r\n\r\n    // We need to check whether the class name is defined directly on this prototype otherwise\r\n    // it will walk the proto chain and return any parent proto classname.\r\n    if (target && objHasOwnProperty(proto, DynClassName)) {\r\n\r\n        let instFuncTable = target[DynInstFuncTable] || objCreate(null);\r\n        instFunc = (instFuncTable[proto[DynClassName]] || objCreate(null))[funcName];\r\n\r\n        if (!instFunc) {\r\n            // Avoid stack overflow from recursive calling the same function\r\n            _throwTypeError(\"Missing [\" + funcName + \"] \" + strFunction);\r\n        }\r\n\r\n        // We have the instance function, lets check it we can speed up further calls\r\n        // by adding the instance function back directly on the instance (avoiding the dynamic func lookup)\r\n        if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {\r\n            // If the instance already has an instance function we can't replace it\r\n            let canAddInst = !objHasOwnProperty(target, funcName);\r\n\r\n            // Get current prototype\r\n            let objProto = _getObjProto(target);\r\n            let visited:any[] = [];\r\n\r\n            // Lookup the function starting at the top (instance level prototype) and traverse down, if the first matching function\r\n            // if nothing is found or if the first hit is a dynamic proto instance then we can safely add an instance shortcut\r\n            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {\r\n                let protoFunc = objProto[funcName];\r\n                if (protoFunc) {\r\n                    canAddInst = (protoFunc === currentDynProtoProxy);\r\n                    break;\r\n                }\r\n\r\n                // We need to find all possible initial functions to ensure that we don't bypass a valid override function\r\n                visited.push(objProto);\r\n                objProto = _getObjProto(objProto);\r\n            }\r\n\r\n            try {\r\n                if (canAddInst) {\r\n                    // This instance doesn't have an instance func and the class hierarchy does have a higher level prototype version\r\n                    // so it's safe to directly assign for any subsequent calls (for better performance)\r\n                    target[funcName] = instFunc;\r\n                }\r\n\r\n                // Block further attempts to set the instance function for any\r\n                instFunc[DynInstChkTag] = 1;\r\n            } catch (e) {\r\n                // Don't crash if the object is readonly or the runtime doesn't allow changing this\r\n                // And set a flag so we don't try again for any function\r\n                instFuncTable[DynAllowInstChkTag] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return instFunc;\r\n}\r\n\r\nfunction _getProtoFunc(funcName: string, proto: any, currentDynProtoProxy: any) {\r\n    let protoFunc = proto[funcName];\r\n\r\n    // Check that the prototype function is not a self reference -- try to avoid stack overflow!\r\n    if (protoFunc === currentDynProtoProxy) {\r\n        // It is so lookup the base prototype\r\n        protoFunc = _getObjProto(proto)[funcName];\r\n    }\r\n\r\n    if (typeof protoFunc !== strFunction) {\r\n        _throwTypeError(\"[\" + funcName + \"] is not a \" + strFunction);\r\n    }\r\n\r\n    return protoFunc;\r\n}\r\n\r\n/**\r\n * Add the required dynamic prototype methods to the the class prototype\r\n * @param proto - The class prototype\r\n * @param className - The instance classname \r\n * @param target - The target instance\r\n * @param baseInstFuncs - The base instance functions\r\n * @param setInstanceFunc - Flag to allow prototype function to reset the instance function if one does not exist\r\n * @ignore\r\n */\r\nfunction _populatePrototype(proto:any, className:string, target:any, baseInstFuncs:any, setInstanceFunc:boolean) {\r\n    function _createDynamicPrototype(proto:any, funcName:string) {\r\n        let dynProtoProxy = function() {\r\n            // Use the instance or prototype function\r\n            let instFunc = _getInstFunc(this, funcName, proto, dynProtoProxy) || _getProtoFunc(funcName, proto, dynProtoProxy);\r\n            // eslint-disable-next-line prefer-rest-params\r\n            return instFunc.apply(this, arguments);\r\n        };\r\n        \r\n        // Tag this function as a proxy to support replacing dynamic proxy elements (primary use case is for unit testing\r\n        // via which can dynamically replace the prototype function reference)\r\n        (dynProtoProxy as any)[DynProxyTag] = 1;\r\n        return dynProtoProxy;\r\n    }\r\n    \r\n    if (!_isObjectOrArrayPrototype(proto)) {\r\n        let instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || objCreate(null);\r\n        if (!_isObjectOrArrayPrototype(instFuncTable)) {\r\n            let instFuncs = instFuncTable[className] = (instFuncTable[className] || objCreate(null)); // fetch and assign if as it may not exist yet\r\n\r\n            // Set whether we are allow to lookup instances, if someone has set to false then do not re-enable\r\n            if (instFuncTable[DynAllowInstChkTag] !== false) {\r\n                instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;\r\n            }\r\n\r\n            if (!_isObjectOrArrayPrototype(instFuncs)) {\r\n                _forEachProp(target, (name) => {\r\n                    // Only add overridden functions\r\n                    if (_isDynamicCandidate(target, name, false) && target[name] !== baseInstFuncs[name] ) {\r\n                        // Save the instance Function to the lookup table and remove it from the instance as it's not a dynamic proto function\r\n                        instFuncs[name] = target[name];\r\n                        delete target[name];\r\n                        \r\n                        // Add a dynamic proto if one doesn't exist or if a prototype function exists and it's not a dynamic one\r\n                        if (!objHasOwnProperty(proto, name) || (proto[name] && !proto[name][DynProxyTag])) {\r\n                            proto[name] = _createDynamicPrototype(proto, name);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether the passed prototype object appears to be correct by walking the prototype hierarchy of the instance\r\n * @param classProto The class prototype instance\r\n * @param thisTarget The current instance that will be checked whether the passed prototype instance is in the hierarchy\r\n * @ignore\r\n */\r\nfunction _checkPrototype(classProto:any, thisTarget:any) {\r\n    // This method doesn't existing in older browsers (e.g. IE8)\r\n    if (_objGetPrototypeOf) {\r\n        // As this is primarily a coding time check, don't bother checking if running in IE8 or lower\r\n        let visited:any[] = [];\r\n        let thisProto = _getObjProto(thisTarget);\r\n        while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {\r\n            if (thisProto === classProto) {\r\n                return true;\r\n            }\r\n\r\n            // This avoids the caller from needing to check whether it's direct base class implements the function or not\r\n            // by walking the entire chain it simplifies the usage and issues from upgrading any of the base classes.\r\n            visited.push(thisProto);\r\n            thisProto = _getObjProto(thisProto);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // If objGetPrototypeOf doesn't exist then just assume everything is ok.\r\n    return true;\r\n}\r\n\r\n/**\r\n * Gets the current prototype name using the ES6 name if available otherwise falling back to a use unknown as the name.\r\n * It's not critical for this to return a name, it's used to decorate the generated unique name for easier debugging only.\r\n * @param target \r\n * @param unknownValue \r\n * @ignore\r\n */\r\nfunction _getObjName(target:any, unknownValue?:string) {\r\n    if (objHasOwnProperty(target, Prototype)) {\r\n        // Look like a prototype\r\n        return target.name || unknownValue || UnknownValue\r\n    }\r\n\r\n    return (((target || {})[Constructor]) || {}).name || unknownValue || UnknownValue;\r\n}\r\n\r\n/**\r\n * Interface to define additional configuration options to control how the dynamic prototype functions operate.\r\n */\r\nexport interface IDynamicProtoOpts {\r\n\r\n    /**\r\n     * Should the dynamic prototype attempt to set an instance function for instances that do not already have an\r\n     * function of the same name or have been extended by a class with a (non-dynamic proto) prototype function.\r\n     */\r\n    setInstFuncs: boolean,\r\n\r\n    /**\r\n     * When looking for base (super) functions if it finds a dynamic proto instances can it use the instance functions\r\n     * and bypass the prototype lookups. Defaults to true.\r\n     */\r\n    useBaseInst?: boolean\r\n}\r\n\r\n/**\r\n * The delegate signature for the function used as the callback for dynamicProto() \r\n * @typeparam DPType This is the generic type of the class, used to keep intellisense valid for the proxy instance, even \r\n * though it is only a proxy that only contains the functions \r\n * @param theTarget This is the real \"this\" of the current target object\r\n * @param baseFuncProxy The is a proxy object which ONLY contains this function that existed on the \"this\" instance before\r\n * calling dynamicProto, it does NOT contain properties of this. This is basically equivalent to using the \"super\" keyword.\r\n */\r\nexport type DynamicProtoDelegate<DPType> = (theTarget:DPType, baseFuncProxy?:DPType) => void;\r\n\r\n/**\r\n * Helper function when creating dynamic (inline) functions for classes, this helper performs the following tasks :-\r\n * - Saves references to all defined base class functions\r\n * - Calls the delegateFunc with the current target (this) and a base object reference that can be used to call all \"super\" functions.\r\n * - Will populate the class prototype for all overridden functions to support class extension that call the prototype instance.\r\n * Callers should use this helper when declaring all function within the constructor of a class, as mentioned above the delegateFunc is \r\n * passed both the target \"this\" and an object that can be used to call any base (super) functions, using this based object in place of\r\n * super.XXX() (which gets expanded to _super.prototype.XXX()) provides a better minification outcome and also ensures the correct \"this\"\r\n * context is maintained as TypeScript creates incorrect references using super.XXXX() for dynamically defined functions i.e. Functions\r\n * defined in the constructor or some other function (rather than declared as complete typescript functions).\r\n * ### Usage\r\n * ```typescript\r\n * import dynamicProto from \"@microsoft/dynamicproto-js\";\r\n * class ExampleClass extends BaseClass {\r\n *     constructor() {\r\n *         dynamicProto(ExampleClass, this, (_self, base) => {\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.newFunc = () => {\r\n *                 // Access any \"this\" instance property  \r\n *                 if (_self.someProperty) {\r\n *                     ...\r\n *                 }\r\n *             }\r\n *             // This will define a function that will be converted to a prototype function\r\n *             _self.myFunction = () => {\r\n *                 // Access any \"this\" instance property\r\n *                 if (_self.someProperty) {\r\n *                     // Call the base version of the function that we are overriding\r\n *                     base.myFunction();\r\n *                 }\r\n *                 ...\r\n *             }\r\n *             _self.initialize = () => {\r\n *                 ...\r\n *             }\r\n *             // Warnings: While the following will work as _self is simply a reference to\r\n *             // this, if anyone overrides myFunction() the overridden will be called first\r\n *             // as the normal JavaScript method resolution will occur and the defined\r\n *             // _self.initialize() function is actually gets removed from the instance and\r\n *             // a proxy prototype version is created to reference the created method.\r\n *             _self.initialize();\r\n *         });\r\n *     }\r\n * }\r\n * ```\r\n * @typeparam DPType This is the generic type of the class, used to keep intellisense valid\r\n * @typeparam DPCls The type that contains the prototype of the current class\r\n * @param theClass - This is the current class instance which contains the prototype for the current class\r\n * @param target - The current \"this\" (target) reference, when the class has been extended this.prototype will not be the 'theClass' value.\r\n * @param delegateFunc - The callback function (closure) that will create the dynamic function\r\n * @param options - Additional options to configure how the dynamic prototype operates\r\n */\r\nexport default function dynamicProto<DPType, DPCls>(theClass:DPCls, target:DPType, delegateFunc: DynamicProtoDelegate<DPType>, options?:IDynamicProtoOpts): void {\r\n    // Make sure that the passed theClass argument looks correct\r\n    if (!objHasOwnProperty(theClass, Prototype)) {\r\n        _throwTypeError(\"theClass is an invalid class definition.\");\r\n    }\r\n\r\n    // Quick check to make sure that the passed theClass argument looks correct (this is a common copy/paste error)\r\n    let classProto = theClass[Prototype];\r\n    if (!_checkPrototype(classProto, target)) {\r\n        _throwTypeError(\"[\" + _getObjName(theClass) + \"] not in hierarchy of [\" + _getObjName(target) + \"]\");\r\n    }\r\n\r\n    let className = null;\r\n    if (objHasOwnProperty(classProto, DynClassName)) {\r\n        // Only grab the class name if it's defined on this prototype (i.e. don't walk the prototype chain)\r\n        className = classProto[DynClassName];\r\n    } else {\r\n        // As not all browser support name on the prototype creating a unique dynamic one if we have not already\r\n        // assigned one, so we can use a simple string as the lookup rather than an object for the dynamic instance\r\n        // function table lookup.\r\n        className = DynClassNamePrefix + _getObjName(theClass, \"_\") + \"$\" + _gblInst.n ;\r\n        _gblInst.n++;\r\n        classProto[DynClassName] = className;\r\n    }\r\n\r\n    let perfOptions = dynamicProto[DynProtoDefaultOptions];\r\n    let useBaseInst = !!perfOptions[strUseBaseInst];\r\n    if (useBaseInst && options && options[strUseBaseInst] !== undefined) {\r\n        useBaseInst = !!options[strUseBaseInst];\r\n    }\r\n\r\n    // Get the current instance functions\r\n    let instFuncs = _getInstanceFuncs(target);\r\n\r\n    // Get all of the functions for any base instance (before they are potentially overridden)\r\n    let baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);\r\n\r\n    // Execute the delegate passing in both the current target \"this\" and \"base\" function references\r\n    // Note casting the same type as we don't actually have the base class here and this will provide some intellisense support\r\n    delegateFunc(target, baseFuncs as DPType);\r\n\r\n    // Don't allow setting instance functions for older IE instances\r\n    let setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];\r\n    if (setInstanceFunc && options) {\r\n        setInstanceFunc = !!options[strSetInstFuncs];\r\n    }\r\n\r\n    // Populate the Prototype for any overridden instance functions\r\n    _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);\r\n}\r\n\r\n/**\r\n * Exposes the default global options to allow global configuration, if the global values are disabled these will override\r\n * any passed values. This is primarily exposed to support unit-testing without the need for individual classes to expose\r\n * their internal usage of dynamic proto.\r\n */\r\ndynamicProto[DynProtoDefaultOptions] = _gblInst.o;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}