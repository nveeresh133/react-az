{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Common, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\nimport { __assignFn as __assign } from \"@microsoft/applicationinsights-shims\";\nimport { arrForEach, arrMap, isArray, isError, isFunction, isNullOrUndefined, isObject, isString, strTrim } from \"@microsoft/applicationinsights-core-js\";\nimport { getWindow, strIndexOf } from \"@nevware21/ts-utils\";\nimport { strNotSpecified } from \"../Constants\";\nimport { _DYN_ASSEMBLY, _DYN_EXCEPTIONS, _DYN_FILE_NAME, _DYN_HAS_FULL_STACK, _DYN_IS_MANUAL, _DYN_LENGTH, _DYN_LEVEL, _DYN_LINE, _DYN_MEASUREMENTS, _DYN_MESSAGE, _DYN_METHOD, _DYN_NAME, _DYN_PARSED_STACK, _DYN_PROBLEM_GROUP, _DYN_PROPERTIES, _DYN_PUSH, _DYN_SEVERITY_LEVEL, _DYN_SIZE_IN_BYTES, _DYN_SPLIT, _DYN_STRINGIFY, _DYN_TO_STRING, _DYN_TYPE_NAME, _DYN__CREATE_FROM_INTERFA1 } from \"../__DynamicConstants\";\nimport { dataSanitizeException, dataSanitizeMeasurements, dataSanitizeMessage, dataSanitizeProperties, dataSanitizeString } from \"./Common/DataSanitizer\";\nvar NoMethod = \"<no_method>\";\nvar strError = \"error\";\nvar strStack = \"stack\";\nvar strStackDetails = \"stackDetails\";\nvar strErrorSrc = \"errorSrc\";\nvar strMessage = \"message\";\nvar strDescription = \"description\";\nfunction _stringify(value, convertToString) {\n  var result = value;\n  if (result && !isString(result)) {\n    if (JSON && JSON[_DYN_STRINGIFY /* @min:%2estringify */]) {\n      result = JSON[_DYN_STRINGIFY /* @min:%2estringify */](value);\n      if (convertToString && (!result || result === \"{}\")) {\n        if (isFunction(value[_DYN_TO_STRING /* @min:%2etoString */])) {\n          result = value[_DYN_TO_STRING /* @min:%2etoString */]();\n        } else {\n          result = \"\" + value;\n        }\n      }\n    } else {\n      result = \"\" + value + \" - (Missing JSON.stringify)\";\n    }\n  }\n  return result || \"\";\n}\nfunction _formatMessage(theEvent, errorType) {\n  var evtMessage = theEvent;\n  if (theEvent) {\n    if (evtMessage && !isString(evtMessage)) {\n      evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;\n    }\n    // Make sure the message is a string\n    if (evtMessage && !isString(evtMessage)) {\n      // tslint:disable-next-line: prefer-conditional-expression\n      evtMessage = _stringify(evtMessage, true);\n    }\n    if (theEvent[\"filename\"]) {\n      // Looks like an event object with filename\n      evtMessage = evtMessage + \" @\" + (theEvent[\"filename\"] || \"\") + \":\" + (theEvent[\"lineno\"] || \"?\") + \":\" + (theEvent[\"colno\"] || \"?\");\n    }\n  }\n  // Automatically add the error type to the message if it does already appear to be present\n  if (errorType && errorType !== \"String\" && errorType !== \"Object\" && errorType !== \"Error\" && strIndexOf(evtMessage || \"\", errorType) === -1) {\n    evtMessage = errorType + \": \" + evtMessage;\n  }\n  return evtMessage || \"\";\n}\nfunction _isExceptionDetailsInternal(value) {\n  try {\n    if (isObject(value)) {\n      return \"hasFullStack\" in value && \"typeName\" in value;\n    }\n  } catch (e) {\n    // This can happen with some native browser objects, but should not happen for the type we are checking for\n  }\n  return false;\n}\nfunction _isExceptionInternal(value) {\n  try {\n    if (isObject(value)) {\n      return \"ver\" in value && \"exceptions\" in value && \"properties\" in value;\n    }\n  } catch (e) {\n    // This can happen with some native browser objects, but should not happen for the type we are checking for\n  }\n  return false;\n}\nfunction _isStackDetails(details) {\n  return details && details.src && isString(details.src) && details.obj && isArray(details.obj);\n}\nfunction _convertStackObj(errorStack) {\n  var src = errorStack || \"\";\n  if (!isString(src)) {\n    if (isString(src[strStack])) {\n      src = src[strStack];\n    } else {\n      src = \"\" + src;\n    }\n  }\n  var items = src[_DYN_SPLIT /* @min:%2esplit */](\"\\n\");\n  return {\n    src: src,\n    obj: items\n  };\n}\nfunction _getOperaStack(errorMessage) {\n  var stack = [];\n  var lines = errorMessage[_DYN_SPLIT /* @min:%2esplit */](\"\\n\");\n  for (var lp = 0; lp < lines[_DYN_LENGTH /* @min:%2elength */]; lp++) {\n    var entry = lines[lp];\n    if (lines[lp + 1]) {\n      entry += \"@\" + lines[lp + 1];\n      lp++;\n    }\n    stack[_DYN_PUSH /* @min:%2epush */](entry);\n  }\n  return {\n    src: errorMessage,\n    obj: stack\n  };\n}\nfunction _getStackFromErrorObj(errorObj) {\n  var details = null;\n  if (errorObj) {\n    try {\n      /* Using bracket notation is support older browsers (IE 7/8 -- dont remember the version) that throw when using dot\r\n      notation for undefined objects and we don't want to loose the error from being reported */\n      if (errorObj[strStack]) {\n        // Chrome/Firefox\n        details = _convertStackObj(errorObj[strStack]);\n      } else if (errorObj[strError] && errorObj[strError][strStack]) {\n        // Edge error event provides the stack and error object\n        details = _convertStackObj(errorObj[strError][strStack]);\n      } else if (errorObj[\"exception\"] && errorObj.exception[strStack]) {\n        details = _convertStackObj(errorObj.exception[strStack]);\n      } else if (_isStackDetails(errorObj)) {\n        details = errorObj;\n      } else if (_isStackDetails(errorObj[strStackDetails])) {\n        details = errorObj[strStackDetails];\n      } else if (getWindow() && getWindow()[\"opera\"] && errorObj[strMessage]) {\n        // Opera\n        details = _getOperaStack(errorObj[_DYN_MESSAGE /* @min:%2emessage */]);\n      } else if (errorObj[\"reason\"] && errorObj.reason[strStack]) {\n        // UnhandledPromiseRejection\n        details = _convertStackObj(errorObj.reason[strStack]);\n      } else if (isString(errorObj)) {\n        details = _convertStackObj(errorObj);\n      } else {\n        var evtMessage = errorObj[strMessage] || errorObj[strDescription] || \"\";\n        if (isString(errorObj[strErrorSrc])) {\n          if (evtMessage) {\n            evtMessage += \"\\n\";\n          }\n          evtMessage += \" from \" + errorObj[strErrorSrc];\n        }\n        if (evtMessage) {\n          details = _convertStackObj(evtMessage);\n        }\n      }\n    } catch (e) {\n      // something unexpected happened so to avoid failing to report any error lets swallow the exception\n      // and fallback to the callee/caller method\n      details = _convertStackObj(e);\n    }\n  }\n  return details || {\n    src: \"\",\n    obj: null\n  };\n}\nfunction _formatStackTrace(stackDetails) {\n  var stack = \"\";\n  if (stackDetails) {\n    if (stackDetails.obj) {\n      arrForEach(stackDetails.obj, function (entry) {\n        stack += entry + \"\\n\";\n      });\n    } else {\n      stack = stackDetails.src || \"\";\n    }\n  }\n  return stack;\n}\nfunction _parseStack(stack) {\n  var parsedStack;\n  var frames = stack.obj;\n  if (frames && frames[_DYN_LENGTH /* @min:%2elength */] > 0) {\n    parsedStack = [];\n    var level_1 = 0;\n    var totalSizeInBytes_1 = 0;\n    arrForEach(frames, function (frame) {\n      var theFrame = frame[_DYN_TO_STRING /* @min:%2etoString */]();\n      if (_StackFrame.regex.test(theFrame)) {\n        var parsedFrame = new _StackFrame(theFrame, level_1++);\n        totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\n        parsedStack[_DYN_PUSH /* @min:%2epush */](parsedFrame);\n      }\n    });\n    // DP Constraint - exception parsed stack must be < 32KB\n    // remove frames from the middle to meet the threshold\n    var exceptionParsedStackThreshold = 32 * 1024;\n    if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {\n      var left = 0;\n      var right = parsedStack[_DYN_LENGTH /* @min:%2elength */] - 1;\n      var size = 0;\n      var acceptedLeft = left;\n      var acceptedRight = right;\n      while (left < right) {\n        // check size\n        var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\n        var rSize = parsedStack[right][_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\n        size += lSize + rSize;\n        if (size > exceptionParsedStackThreshold) {\n          // remove extra frames from the middle\n          var howMany = acceptedRight - acceptedLeft + 1;\n          parsedStack.splice(acceptedLeft, howMany);\n          break;\n        }\n        // update pointers\n        acceptedLeft = left;\n        acceptedRight = right;\n        left++;\n        right--;\n      }\n    }\n  }\n  return parsedStack;\n}\nfunction _getErrorType(errorType) {\n  // Gets the Error Type by passing the constructor (used to get the true type of native error object).\n  var typeName = \"\";\n  if (errorType) {\n    typeName = errorType.typeName || errorType[_DYN_NAME /* @min:%2ename */] || \"\";\n    if (!typeName) {\n      try {\n        var funcNameRegex = /function (.{1,200})\\(/;\n        var results = funcNameRegex.exec(errorType.constructor[_DYN_TO_STRING /* @min:%2etoString */]());\n        typeName = results && results[_DYN_LENGTH /* @min:%2elength */] > 1 ? results[1] : \"\";\n      } catch (e) {\n        // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do\n      }\n    }\n  }\n  return typeName;\n}\n/**\r\n * Formats the provided errorObj for display and reporting, it may be a String, Object, integer or undefined depending on the browser.\r\n * @param errorObj - The supplied errorObj\r\n */\nexport function _formatErrorCode(errorObj) {\n  if (errorObj) {\n    try {\n      if (!isString(errorObj)) {\n        var errorType = _getErrorType(errorObj);\n        var result = _stringify(errorObj, false);\n        if (!result || result === \"{}\") {\n          if (errorObj[strError]) {\n            // Looks like an MS Error Event\n            errorObj = errorObj[strError];\n            errorType = _getErrorType(errorObj);\n          }\n          result = _stringify(errorObj, true);\n        }\n        if (strIndexOf(result, errorType) !== 0 && errorType !== \"String\") {\n          return errorType + \":\" + result;\n        }\n        return result;\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do\n    }\n  }\n  // Fallback to just letting the object format itself into a string\n  return \"\" + (errorObj || \"\");\n}\nvar Exception = /** @class */function () {\n  /**\r\n   * Constructs a new instance of the ExceptionTelemetry object\r\n   */\n  function Exception(logger, exception, properties, measurements, severityLevel, id) {\n    this.aiDataContract = {\n      ver: 1 /* FieldType.Required */,\n      exceptions: 1 /* FieldType.Required */,\n      severityLevel: 0 /* FieldType.Default */,\n      properties: 0 /* FieldType.Default */,\n      measurements: 0 /* FieldType.Default */\n    };\n    var _self = this;\n    _self.ver = 2; // TODO: handle the CS\"4.0\" ==> breeze 2 conversion in a better way\n    if (!_isExceptionInternal(exception)) {\n      if (!properties) {\n        properties = {};\n      }\n      if (id) {\n        properties.id = id;\n      }\n      _self[_DYN_EXCEPTIONS /* @min:%2eexceptions */] = [new _ExceptionDetails(logger, exception, properties)];\n      _self[_DYN_PROPERTIES /* @min:%2eproperties */] = dataSanitizeProperties(logger, properties);\n      _self[_DYN_MEASUREMENTS /* @min:%2emeasurements */] = dataSanitizeMeasurements(logger, measurements);\n      if (severityLevel) {\n        _self[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = severityLevel;\n      }\n      if (id) {\n        _self.id = id;\n      }\n    } else {\n      _self[_DYN_EXCEPTIONS /* @min:%2eexceptions */] = exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */] || [];\n      _self[_DYN_PROPERTIES /* @min:%2eproperties */] = exception[_DYN_PROPERTIES /* @min:%2eproperties */];\n      _self[_DYN_MEASUREMENTS /* @min:%2emeasurements */] = exception[_DYN_MEASUREMENTS /* @min:%2emeasurements */];\n      if (exception[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */]) {\n        _self[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = exception[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */];\n      }\n      if (exception.id) {\n        _self.id = exception.id;\n        exception[_DYN_PROPERTIES /* @min:%2eproperties */].id = exception.id;\n      }\n      if (exception[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */]) {\n        _self[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */] = exception[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */];\n      }\n      // bool/int types, use isNullOrUndefined\n      if (!isNullOrUndefined(exception[_DYN_IS_MANUAL /* @min:%2eisManual */])) {\n        _self[_DYN_IS_MANUAL /* @min:%2eisManual */] = exception[_DYN_IS_MANUAL /* @min:%2eisManual */];\n      }\n    }\n  }\n  Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {\n    var _a;\n    var errorType = _getErrorType(error || evt || message);\n    return _a = {}, _a[_DYN_MESSAGE /* @min:message */] = _formatMessage(message, errorType), _a.url = url, _a.lineNumber = lineNumber, _a.columnNumber = columnNumber, _a.error = _formatErrorCode(error || evt || message), _a.evt = _formatErrorCode(evt || message), _a[_DYN_TYPE_NAME /* @min:typeName */] = errorType, _a.stackDetails = _getStackFromErrorObj(stack || error || evt), _a.errorSrc = errorSrc, _a;\n  };\n  Exception.CreateFromInterface = function (logger, exception, properties, measurements) {\n    var exceptions = exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */] && arrMap(exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */], function (ex) {\n      return _ExceptionDetails[_DYN__CREATE_FROM_INTERFA1 /* @min:%2eCreateFromInterface */](logger, ex);\n    });\n    var exceptionData = new Exception(logger, __assign(__assign({}, exception), {\n      exceptions: exceptions\n    }), properties, measurements);\n    return exceptionData;\n  };\n  Exception.prototype.toInterface = function () {\n    var _a;\n    var _b = this,\n      exceptions = _b.exceptions,\n      properties = _b.properties,\n      measurements = _b.measurements,\n      severityLevel = _b.severityLevel,\n      problemGroup = _b.problemGroup,\n      id = _b.id,\n      isManual = _b.isManual;\n    var exceptionDetailsInterface = exceptions instanceof Array && arrMap(exceptions, function (exception) {\n      return exception.toInterface();\n    }) || undefined;\n    return _a = {\n      ver: \"4.0\"\n    }, _a[_DYN_EXCEPTIONS /* @min:exceptions */] = exceptionDetailsInterface, _a.severityLevel = severityLevel, _a.properties = properties, _a.measurements = measurements, _a.problemGroup = problemGroup, _a.id = id, _a.isManual = isManual, _a;\n  };\n  /**\r\n   * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.\r\n   */\n  Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {\n    var _a;\n    return {\n      exceptions: [(_a = {}, _a[_DYN_HAS_FULL_STACK /* @min:hasFullStack */] = true, _a.message = message, _a.stack = details, _a.typeName = typeName, _a)]\n    };\n  };\n  Exception.envelopeType = \"Microsoft.ApplicationInsights.{0}.Exception\";\n  Exception.dataType = \"ExceptionData\";\n  Exception.formatError = _formatErrorCode;\n  return Exception;\n}();\nexport { Exception };\nvar _ExceptionDetails = /** @class */function () {\n  function _ExceptionDetails(logger, exception, properties) {\n    this.aiDataContract = {\n      id: 0 /* FieldType.Default */,\n      outerId: 0 /* FieldType.Default */,\n      typeName: 1 /* FieldType.Required */,\n      message: 1 /* FieldType.Required */,\n      hasFullStack: 0 /* FieldType.Default */,\n      stack: 0 /* FieldType.Default */,\n      parsedStack: 2 /* FieldType.Array */\n    };\n    var _self = this;\n    if (!_isExceptionDetailsInternal(exception)) {\n      var error = exception;\n      var evt = error && error.evt;\n      if (!isError(error)) {\n        error = error[strError] || evt || error;\n      }\n      _self[_DYN_TYPE_NAME /* @min:%2etypeName */] = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified;\n      _self[_DYN_MESSAGE /* @min:%2emessage */] = dataSanitizeMessage(logger, _formatMessage(exception || error, _self[_DYN_TYPE_NAME /* @min:%2etypeName */])) || strNotSpecified;\n      var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);\n      _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] = _parseStack(stack);\n      // after parsedStack is inited, iterate over each frame object, sanitize its assembly field\n      if (isArray(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */])) {\n        arrMap(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) {\n          frame[_DYN_ASSEMBLY /* @min:%2eassembly */] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY /* @min:%2eassembly */]);\n          frame[_DYN_FILE_NAME /* @min:%2efileName */] = dataSanitizeString(logger, frame[_DYN_FILE_NAME /* @min:%2efileName */]);\n        });\n      }\n      _self[strStack] = dataSanitizeException(logger, _formatStackTrace(stack));\n      _self.hasFullStack = isArray(_self.parsedStack) && _self.parsedStack[_DYN_LENGTH /* @min:%2elength */] > 0;\n      if (properties) {\n        properties[_DYN_TYPE_NAME /* @min:%2etypeName */] = properties[_DYN_TYPE_NAME /* @min:%2etypeName */] || _self[_DYN_TYPE_NAME /* @min:%2etypeName */];\n      }\n    } else {\n      _self[_DYN_TYPE_NAME /* @min:%2etypeName */] = exception[_DYN_TYPE_NAME /* @min:%2etypeName */];\n      _self[_DYN_MESSAGE /* @min:%2emessage */] = exception[_DYN_MESSAGE /* @min:%2emessage */];\n      _self[strStack] = exception[strStack];\n      _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] = exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */] || [];\n      _self[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */] = exception[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */];\n    }\n  }\n  _ExceptionDetails.prototype.toInterface = function () {\n    var _a;\n    var _self = this;\n    var parsedStack = _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] instanceof Array && arrMap(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) {\n      return frame.toInterface();\n    });\n    var exceptionDetailsInterface = (_a = {\n      id: _self.id,\n      outerId: _self.outerId,\n      typeName: _self[_DYN_TYPE_NAME /* @min:%2etypeName */],\n      message: _self[_DYN_MESSAGE /* @min:%2emessage */],\n      hasFullStack: _self[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */],\n      stack: _self[strStack]\n    }, _a[_DYN_PARSED_STACK /* @min:parsedStack */] = parsedStack || undefined, _a);\n    return exceptionDetailsInterface;\n  };\n  _ExceptionDetails.CreateFromInterface = function (logger, exception) {\n    var parsedStack = exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */] instanceof Array && arrMap(exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) {\n      return _StackFrame[_DYN__CREATE_FROM_INTERFA1 /* @min:%2eCreateFromInterface */](frame);\n    }) || exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */];\n    var exceptionDetails = new _ExceptionDetails(logger, __assign(__assign({}, exception), {\n      parsedStack: parsedStack\n    }));\n    return exceptionDetails;\n  };\n  return _ExceptionDetails;\n}();\nexport { _ExceptionDetails };\nvar _StackFrame = /** @class */function () {\n  function _StackFrame(sourceFrame, level) {\n    this.aiDataContract = {\n      level: 1 /* FieldType.Required */,\n      method: 1 /* FieldType.Required */,\n      assembly: 0 /* FieldType.Default */,\n      fileName: 0 /* FieldType.Default */,\n      line: 0 /* FieldType.Default */\n    };\n    var _self = this;\n    _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = 0;\n    // Not converting this to isString() as typescript uses this logic to \"understand\" the different\n    // types for the 2 different code paths\n    if (typeof sourceFrame === \"string\") {\n      var frame = sourceFrame;\n      _self[_DYN_LEVEL /* @min:%2elevel */] = level;\n      _self[_DYN_METHOD /* @min:%2emethod */] = NoMethod;\n      _self[_DYN_ASSEMBLY /* @min:%2eassembly */] = strTrim(frame);\n      _self[_DYN_FILE_NAME /* @min:%2efileName */] = \"\";\n      _self[_DYN_LINE /* @min:%2eline */] = 0;\n      var matches = frame.match(_StackFrame.regex);\n      if (matches && matches[_DYN_LENGTH /* @min:%2elength */] >= 5) {\n        _self[_DYN_METHOD /* @min:%2emethod */] = strTrim(matches[2]) || _self[_DYN_METHOD /* @min:%2emethod */];\n        _self[_DYN_FILE_NAME /* @min:%2efileName */] = strTrim(matches[4]);\n        _self[_DYN_LINE /* @min:%2eline */] = parseInt(matches[5]) || 0;\n      }\n    } else {\n      _self[_DYN_LEVEL /* @min:%2elevel */] = sourceFrame[_DYN_LEVEL /* @min:%2elevel */];\n      _self[_DYN_METHOD /* @min:%2emethod */] = sourceFrame[_DYN_METHOD /* @min:%2emethod */];\n      _self[_DYN_ASSEMBLY /* @min:%2eassembly */] = sourceFrame[_DYN_ASSEMBLY /* @min:%2eassembly */];\n      _self[_DYN_FILE_NAME /* @min:%2efileName */] = sourceFrame[_DYN_FILE_NAME /* @min:%2efileName */];\n      _self[_DYN_LINE /* @min:%2eline */] = sourceFrame[_DYN_LINE /* @min:%2eline */];\n      _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = 0;\n    }\n    _self.sizeInBytes += _self.method[_DYN_LENGTH /* @min:%2elength */];\n    _self.sizeInBytes += _self.fileName[_DYN_LENGTH /* @min:%2elength */];\n    _self.sizeInBytes += _self.assembly[_DYN_LENGTH /* @min:%2elength */];\n    // todo: these might need to be removed depending on how the back-end settles on their size calculation\n    _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] += _StackFrame.baseSize;\n    _self.sizeInBytes += _self.level.toString()[_DYN_LENGTH /* @min:%2elength */];\n    _self.sizeInBytes += _self.line.toString()[_DYN_LENGTH /* @min:%2elength */];\n  }\n  _StackFrame.CreateFromInterface = function (frame) {\n    return new _StackFrame(frame, null /* level is available in frame interface */);\n  };\n  _StackFrame.prototype.toInterface = function () {\n    var _self = this;\n    return {\n      level: _self[_DYN_LEVEL /* @min:%2elevel */],\n      method: _self[_DYN_METHOD /* @min:%2emethod */],\n      assembly: _self[_DYN_ASSEMBLY /* @min:%2eassembly */],\n      fileName: _self[_DYN_FILE_NAME /* @min:%2efileName */],\n      line: _self[_DYN_LINE /* @min:%2eline */]\n    };\n  };\n  // regex to match stack frames from ie/chrome/ff\n  // methodName=$2, fileName=$4, lineNo=$5, column=$6\n  _StackFrame.regex = /^([\\s]+at)?[\\s]{0,50}([^\\@\\()]+?)[\\s]{0,50}(\\@|\\()([^\\(\\n]+):([0-9]+):([0-9]+)(\\)?)$/;\n  _StackFrame.baseSize = 58; // '{\"method\":\"\",\"level\":,\"assembly\":\"\",\"fileName\":\"\",\"line\":}'.length\n  return _StackFrame;\n}();\nexport { _StackFrame };","map":{"version":3,"names":["__assignFn","__assign","arrForEach","arrMap","isArray","isError","isFunction","isNullOrUndefined","isObject","isString","strTrim","getWindow","strIndexOf","strNotSpecified","_DYN_ASSEMBLY","_DYN_EXCEPTIONS","_DYN_FILE_NAME","_DYN_HAS_FULL_STACK","_DYN_IS_MANUAL","_DYN_LENGTH","_DYN_LEVEL","_DYN_LINE","_DYN_MEASUREMENTS","_DYN_MESSAGE","_DYN_METHOD","_DYN_NAME","_DYN_PARSED_STACK","_DYN_PROBLEM_GROUP","_DYN_PROPERTIES","_DYN_PUSH","_DYN_SEVERITY_LEVEL","_DYN_SIZE_IN_BYTES","_DYN_SPLIT","_DYN_STRINGIFY","_DYN_TO_STRING","_DYN_TYPE_NAME","_DYN__CREATE_FROM_INTERFA1","dataSanitizeException","dataSanitizeMeasurements","dataSanitizeMessage","dataSanitizeProperties","dataSanitizeString","NoMethod","strError","strStack","strStackDetails","strErrorSrc","strMessage","strDescription","_stringify","value","convertToString","result","JSON","_formatMessage","theEvent","errorType","evtMessage","_isExceptionDetailsInternal","e","_isExceptionInternal","_isStackDetails","details","src","obj","_convertStackObj","errorStack","items","_getOperaStack","errorMessage","stack","lines","lp","entry","_getStackFromErrorObj","errorObj","exception","reason","_formatStackTrace","stackDetails","_parseStack","parsedStack","frames","level_1","totalSizeInBytes_1","frame","theFrame","_StackFrame","regex","test","parsedFrame","exceptionParsedStackThreshold","left","right","size","acceptedLeft","acceptedRight","lSize","rSize","howMany","splice","_getErrorType","typeName","funcNameRegex","results","exec","constructor","_formatErrorCode","Exception","logger","properties","measurements","severityLevel","id","aiDataContract","ver","exceptions","_self","_ExceptionDetails","CreateAutoException","message","url","lineNumber","columnNumber","error","evt","errorSrc","_a","CreateFromInterface","ex","exceptionData","prototype","toInterface","_b","problemGroup","isManual","exceptionDetailsInterface","Array","undefined","CreateSimpleException","assembly","fileName","line","envelopeType","dataType","formatError","outerId","hasFullStack","exceptionDetails","sourceFrame","level","method","matches","match","parseInt","sizeInBytes","baseSize","toString"],"sources":["/home/veeresh133/app/my-app/node_modules/@microsoft/applicationinsights-common/dist-es5/Telemetry/Exception.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport { __assign } from \"tslib\";\r\nimport { arrForEach, arrMap, isArray, isError, isFunction, isNullOrUndefined, isObject, isString, strTrim } from \"@microsoft/applicationinsights-core-js\";\r\nimport { getWindow, strIndexOf } from \"@nevware21/ts-utils\";\r\nimport { strNotSpecified } from \"../Constants\";\r\nimport { _DYN_ASSEMBLY, _DYN_EXCEPTIONS, _DYN_FILE_NAME, _DYN_HAS_FULL_STACK, _DYN_IS_MANUAL, _DYN_LENGTH, _DYN_LEVEL, _DYN_LINE, _DYN_MEASUREMENTS, _DYN_MESSAGE, _DYN_METHOD, _DYN_NAME, _DYN_PARSED_STACK, _DYN_PROBLEM_GROUP, _DYN_PROPERTIES, _DYN_PUSH, _DYN_SEVERITY_LEVEL, _DYN_SIZE_IN_BYTES, _DYN_SPLIT, _DYN_STRINGIFY, _DYN_TO_STRING, _DYN_TYPE_NAME, _DYN__CREATE_FROM_INTERFA1 } from \"../__DynamicConstants\";\r\nimport { dataSanitizeException, dataSanitizeMeasurements, dataSanitizeMessage, dataSanitizeProperties, dataSanitizeString } from \"./Common/DataSanitizer\";\r\nvar NoMethod = \"<no_method>\";\r\nvar strError = \"error\";\r\nvar strStack = \"stack\";\r\nvar strStackDetails = \"stackDetails\";\r\nvar strErrorSrc = \"errorSrc\";\r\nvar strMessage = \"message\";\r\nvar strDescription = \"description\";\r\nfunction _stringify(value, convertToString) {\r\n    var result = value;\r\n    if (result && !isString(result)) {\r\n        if (JSON && JSON[_DYN_STRINGIFY /* @min:%2estringify */]) {\r\n            result = JSON[_DYN_STRINGIFY /* @min:%2estringify */](value);\r\n            if (convertToString && (!result || result === \"{}\")) {\r\n                if (isFunction(value[_DYN_TO_STRING /* @min:%2etoString */])) {\r\n                    result = value[_DYN_TO_STRING /* @min:%2etoString */]();\r\n                }\r\n                else {\r\n                    result = \"\" + value;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            result = \"\" + value + \" - (Missing JSON.stringify)\";\r\n        }\r\n    }\r\n    return result || \"\";\r\n}\r\nfunction _formatMessage(theEvent, errorType) {\r\n    var evtMessage = theEvent;\r\n    if (theEvent) {\r\n        if (evtMessage && !isString(evtMessage)) {\r\n            evtMessage = theEvent[strMessage] || theEvent[strDescription] || evtMessage;\r\n        }\r\n        // Make sure the message is a string\r\n        if (evtMessage && !isString(evtMessage)) {\r\n            // tslint:disable-next-line: prefer-conditional-expression\r\n            evtMessage = _stringify(evtMessage, true);\r\n        }\r\n        if (theEvent[\"filename\"]) {\r\n            // Looks like an event object with filename\r\n            evtMessage = evtMessage + \" @\" + (theEvent[\"filename\"] || \"\") + \":\" + (theEvent[\"lineno\"] || \"?\") + \":\" + (theEvent[\"colno\"] || \"?\");\r\n        }\r\n    }\r\n    // Automatically add the error type to the message if it does already appear to be present\r\n    if (errorType && errorType !== \"String\" && errorType !== \"Object\" && errorType !== \"Error\" && strIndexOf(evtMessage || \"\", errorType) === -1) {\r\n        evtMessage = errorType + \": \" + evtMessage;\r\n    }\r\n    return evtMessage || \"\";\r\n}\r\nfunction _isExceptionDetailsInternal(value) {\r\n    try {\r\n        if (isObject(value)) {\r\n            return \"hasFullStack\" in value && \"typeName\" in value;\r\n        }\r\n    }\r\n    catch (e) {\r\n        // This can happen with some native browser objects, but should not happen for the type we are checking for\r\n    }\r\n    return false;\r\n}\r\nfunction _isExceptionInternal(value) {\r\n    try {\r\n        if (isObject(value)) {\r\n            return (\"ver\" in value && \"exceptions\" in value && \"properties\" in value);\r\n        }\r\n    }\r\n    catch (e) {\r\n        // This can happen with some native browser objects, but should not happen for the type we are checking for\r\n    }\r\n    return false;\r\n}\r\nfunction _isStackDetails(details) {\r\n    return details && details.src && isString(details.src) && details.obj && isArray(details.obj);\r\n}\r\nfunction _convertStackObj(errorStack) {\r\n    var src = errorStack || \"\";\r\n    if (!isString(src)) {\r\n        if (isString(src[strStack])) {\r\n            src = src[strStack];\r\n        }\r\n        else {\r\n            src = \"\" + src;\r\n        }\r\n    }\r\n    var items = src[_DYN_SPLIT /* @min:%2esplit */](\"\\n\");\r\n    return {\r\n        src: src,\r\n        obj: items\r\n    };\r\n}\r\nfunction _getOperaStack(errorMessage) {\r\n    var stack = [];\r\n    var lines = errorMessage[_DYN_SPLIT /* @min:%2esplit */](\"\\n\");\r\n    for (var lp = 0; lp < lines[_DYN_LENGTH /* @min:%2elength */]; lp++) {\r\n        var entry = lines[lp];\r\n        if (lines[lp + 1]) {\r\n            entry += \"@\" + lines[lp + 1];\r\n            lp++;\r\n        }\r\n        stack[_DYN_PUSH /* @min:%2epush */](entry);\r\n    }\r\n    return {\r\n        src: errorMessage,\r\n        obj: stack\r\n    };\r\n}\r\nfunction _getStackFromErrorObj(errorObj) {\r\n    var details = null;\r\n    if (errorObj) {\r\n        try {\r\n            /* Using bracket notation is support older browsers (IE 7/8 -- dont remember the version) that throw when using dot\r\n            notation for undefined objects and we don't want to loose the error from being reported */\r\n            if (errorObj[strStack]) {\r\n                // Chrome/Firefox\r\n                details = _convertStackObj(errorObj[strStack]);\r\n            }\r\n            else if (errorObj[strError] && errorObj[strError][strStack]) {\r\n                // Edge error event provides the stack and error object\r\n                details = _convertStackObj(errorObj[strError][strStack]);\r\n            }\r\n            else if (errorObj[\"exception\"] && errorObj.exception[strStack]) {\r\n                details = _convertStackObj(errorObj.exception[strStack]);\r\n            }\r\n            else if (_isStackDetails(errorObj)) {\r\n                details = errorObj;\r\n            }\r\n            else if (_isStackDetails(errorObj[strStackDetails])) {\r\n                details = errorObj[strStackDetails];\r\n            }\r\n            else if (getWindow() && getWindow()[\"opera\"] && errorObj[strMessage]) {\r\n                // Opera\r\n                details = _getOperaStack(errorObj[_DYN_MESSAGE /* @min:%2emessage */]);\r\n            }\r\n            else if (errorObj[\"reason\"] && errorObj.reason[strStack]) {\r\n                // UnhandledPromiseRejection\r\n                details = _convertStackObj(errorObj.reason[strStack]);\r\n            }\r\n            else if (isString(errorObj)) {\r\n                details = _convertStackObj(errorObj);\r\n            }\r\n            else {\r\n                var evtMessage = errorObj[strMessage] || errorObj[strDescription] || \"\";\r\n                if (isString(errorObj[strErrorSrc])) {\r\n                    if (evtMessage) {\r\n                        evtMessage += \"\\n\";\r\n                    }\r\n                    evtMessage += \" from \" + errorObj[strErrorSrc];\r\n                }\r\n                if (evtMessage) {\r\n                    details = _convertStackObj(evtMessage);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            // something unexpected happened so to avoid failing to report any error lets swallow the exception\r\n            // and fallback to the callee/caller method\r\n            details = _convertStackObj(e);\r\n        }\r\n    }\r\n    return details || {\r\n        src: \"\",\r\n        obj: null\r\n    };\r\n}\r\nfunction _formatStackTrace(stackDetails) {\r\n    var stack = \"\";\r\n    if (stackDetails) {\r\n        if (stackDetails.obj) {\r\n            arrForEach(stackDetails.obj, function (entry) {\r\n                stack += entry + \"\\n\";\r\n            });\r\n        }\r\n        else {\r\n            stack = stackDetails.src || \"\";\r\n        }\r\n    }\r\n    return stack;\r\n}\r\nfunction _parseStack(stack) {\r\n    var parsedStack;\r\n    var frames = stack.obj;\r\n    if (frames && frames[_DYN_LENGTH /* @min:%2elength */] > 0) {\r\n        parsedStack = [];\r\n        var level_1 = 0;\r\n        var totalSizeInBytes_1 = 0;\r\n        arrForEach(frames, function (frame) {\r\n            var theFrame = frame[_DYN_TO_STRING /* @min:%2etoString */]();\r\n            if (_StackFrame.regex.test(theFrame)) {\r\n                var parsedFrame = new _StackFrame(theFrame, level_1++);\r\n                totalSizeInBytes_1 += parsedFrame[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                parsedStack[_DYN_PUSH /* @min:%2epush */](parsedFrame);\r\n            }\r\n        });\r\n        // DP Constraint - exception parsed stack must be < 32KB\r\n        // remove frames from the middle to meet the threshold\r\n        var exceptionParsedStackThreshold = 32 * 1024;\r\n        if (totalSizeInBytes_1 > exceptionParsedStackThreshold) {\r\n            var left = 0;\r\n            var right = parsedStack[_DYN_LENGTH /* @min:%2elength */] - 1;\r\n            var size = 0;\r\n            var acceptedLeft = left;\r\n            var acceptedRight = right;\r\n            while (left < right) {\r\n                // check size\r\n                var lSize = parsedStack[left][_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                var rSize = parsedStack[right][_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */];\r\n                size += lSize + rSize;\r\n                if (size > exceptionParsedStackThreshold) {\r\n                    // remove extra frames from the middle\r\n                    var howMany = acceptedRight - acceptedLeft + 1;\r\n                    parsedStack.splice(acceptedLeft, howMany);\r\n                    break;\r\n                }\r\n                // update pointers\r\n                acceptedLeft = left;\r\n                acceptedRight = right;\r\n                left++;\r\n                right--;\r\n            }\r\n        }\r\n    }\r\n    return parsedStack;\r\n}\r\nfunction _getErrorType(errorType) {\r\n    // Gets the Error Type by passing the constructor (used to get the true type of native error object).\r\n    var typeName = \"\";\r\n    if (errorType) {\r\n        typeName = errorType.typeName || errorType[_DYN_NAME /* @min:%2ename */] || \"\";\r\n        if (!typeName) {\r\n            try {\r\n                var funcNameRegex = /function (.{1,200})\\(/;\r\n                var results = (funcNameRegex).exec((errorType).constructor[_DYN_TO_STRING /* @min:%2etoString */]());\r\n                typeName = (results && results[_DYN_LENGTH /* @min:%2elength */] > 1) ? results[1] : \"\";\r\n            }\r\n            catch (e) {\r\n                // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do\r\n            }\r\n        }\r\n    }\r\n    return typeName;\r\n}\r\n/**\r\n * Formats the provided errorObj for display and reporting, it may be a String, Object, integer or undefined depending on the browser.\r\n * @param errorObj - The supplied errorObj\r\n */\r\nexport function _formatErrorCode(errorObj) {\r\n    if (errorObj) {\r\n        try {\r\n            if (!isString(errorObj)) {\r\n                var errorType = _getErrorType(errorObj);\r\n                var result = _stringify(errorObj, false);\r\n                if (!result || result === \"{}\") {\r\n                    if (errorObj[strError]) {\r\n                        // Looks like an MS Error Event\r\n                        errorObj = errorObj[strError];\r\n                        errorType = _getErrorType(errorObj);\r\n                    }\r\n                    result = _stringify(errorObj, true);\r\n                }\r\n                if (strIndexOf(result, errorType) !== 0 && errorType !== \"String\") {\r\n                    return errorType + \":\" + result;\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // eslint-disable-next-line no-empty -- Ignoring any failures as nothing we can do\r\n        }\r\n    }\r\n    // Fallback to just letting the object format itself into a string\r\n    return \"\" + (errorObj || \"\");\r\n}\r\nvar Exception = /** @class */ (function () {\r\n    /**\r\n     * Constructs a new instance of the ExceptionTelemetry object\r\n     */\r\n    function Exception(logger, exception, properties, measurements, severityLevel, id) {\r\n        this.aiDataContract = {\r\n            ver: 1 /* FieldType.Required */,\r\n            exceptions: 1 /* FieldType.Required */,\r\n            severityLevel: 0 /* FieldType.Default */,\r\n            properties: 0 /* FieldType.Default */,\r\n            measurements: 0 /* FieldType.Default */\r\n        };\r\n        var _self = this;\r\n        _self.ver = 2; // TODO: handle the CS\"4.0\" ==> breeze 2 conversion in a better way\r\n        if (!_isExceptionInternal(exception)) {\r\n            if (!properties) {\r\n                properties = {};\r\n            }\r\n            if (id) {\r\n                properties.id = id;\r\n            }\r\n            _self[_DYN_EXCEPTIONS /* @min:%2eexceptions */] = [new _ExceptionDetails(logger, exception, properties)];\r\n            _self[_DYN_PROPERTIES /* @min:%2eproperties */] = dataSanitizeProperties(logger, properties);\r\n            _self[_DYN_MEASUREMENTS /* @min:%2emeasurements */] = dataSanitizeMeasurements(logger, measurements);\r\n            if (severityLevel) {\r\n                _self[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = severityLevel;\r\n            }\r\n            if (id) {\r\n                _self.id = id;\r\n            }\r\n        }\r\n        else {\r\n            _self[_DYN_EXCEPTIONS /* @min:%2eexceptions */] = exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */] || [];\r\n            _self[_DYN_PROPERTIES /* @min:%2eproperties */] = exception[_DYN_PROPERTIES /* @min:%2eproperties */];\r\n            _self[_DYN_MEASUREMENTS /* @min:%2emeasurements */] = exception[_DYN_MEASUREMENTS /* @min:%2emeasurements */];\r\n            if (exception[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */]) {\r\n                _self[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */] = exception[_DYN_SEVERITY_LEVEL /* @min:%2eseverityLevel */];\r\n            }\r\n            if (exception.id) {\r\n                _self.id = exception.id;\r\n                exception[_DYN_PROPERTIES /* @min:%2eproperties */].id = exception.id;\r\n            }\r\n            if (exception[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */]) {\r\n                _self[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */] = exception[_DYN_PROBLEM_GROUP /* @min:%2eproblemGroup */];\r\n            }\r\n            // bool/int types, use isNullOrUndefined\r\n            if (!isNullOrUndefined(exception[_DYN_IS_MANUAL /* @min:%2eisManual */])) {\r\n                _self[_DYN_IS_MANUAL /* @min:%2eisManual */] = exception[_DYN_IS_MANUAL /* @min:%2eisManual */];\r\n            }\r\n        }\r\n    }\r\n    Exception.CreateAutoException = function (message, url, lineNumber, columnNumber, error, evt, stack, errorSrc) {\r\n        var _a;\r\n        var errorType = _getErrorType(error || evt || message);\r\n        return _a = {},\r\n            _a[_DYN_MESSAGE /* @min:message */] = _formatMessage(message, errorType),\r\n            _a.url = url,\r\n            _a.lineNumber = lineNumber,\r\n            _a.columnNumber = columnNumber,\r\n            _a.error = _formatErrorCode(error || evt || message),\r\n            _a.evt = _formatErrorCode(evt || message),\r\n            _a[_DYN_TYPE_NAME /* @min:typeName */] = errorType,\r\n            _a.stackDetails = _getStackFromErrorObj(stack || error || evt),\r\n            _a.errorSrc = errorSrc,\r\n            _a;\r\n    };\r\n    Exception.CreateFromInterface = function (logger, exception, properties, measurements) {\r\n        var exceptions = exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */]\r\n            && arrMap(exception[_DYN_EXCEPTIONS /* @min:%2eexceptions */], function (ex) { return _ExceptionDetails[_DYN__CREATE_FROM_INTERFA1 /* @min:%2eCreateFromInterface */](logger, ex); });\r\n        var exceptionData = new Exception(logger, __assign(__assign({}, exception), { exceptions: exceptions }), properties, measurements);\r\n        return exceptionData;\r\n    };\r\n    Exception.prototype.toInterface = function () {\r\n        var _a;\r\n        var _b = this, exceptions = _b.exceptions, properties = _b.properties, measurements = _b.measurements, severityLevel = _b.severityLevel, problemGroup = _b.problemGroup, id = _b.id, isManual = _b.isManual;\r\n        var exceptionDetailsInterface = exceptions instanceof Array\r\n            && arrMap(exceptions, function (exception) { return exception.toInterface(); })\r\n            || undefined;\r\n        return _a = {\r\n                ver: \"4.0\"\r\n            },\r\n            _a[_DYN_EXCEPTIONS /* @min:exceptions */] = exceptionDetailsInterface,\r\n            _a.severityLevel = severityLevel,\r\n            _a.properties = properties,\r\n            _a.measurements = measurements,\r\n            _a.problemGroup = problemGroup,\r\n            _a.id = id,\r\n            _a.isManual = isManual,\r\n            _a;\r\n    };\r\n    /**\r\n     * Creates a simple exception with 1 stack frame. Useful for manual constracting of exception.\r\n     */\r\n    Exception.CreateSimpleException = function (message, typeName, assembly, fileName, details, line) {\r\n        var _a;\r\n        return {\r\n            exceptions: [\r\n                (_a = {},\r\n                    _a[_DYN_HAS_FULL_STACK /* @min:hasFullStack */] = true,\r\n                    _a.message = message,\r\n                    _a.stack = details,\r\n                    _a.typeName = typeName,\r\n                    _a)\r\n            ]\r\n        };\r\n    };\r\n    Exception.envelopeType = \"Microsoft.ApplicationInsights.{0}.Exception\";\r\n    Exception.dataType = \"ExceptionData\";\r\n    Exception.formatError = _formatErrorCode;\r\n    return Exception;\r\n}());\r\nexport { Exception };\r\nvar _ExceptionDetails = /** @class */ (function () {\r\n    function _ExceptionDetails(logger, exception, properties) {\r\n        this.aiDataContract = {\r\n            id: 0 /* FieldType.Default */,\r\n            outerId: 0 /* FieldType.Default */,\r\n            typeName: 1 /* FieldType.Required */,\r\n            message: 1 /* FieldType.Required */,\r\n            hasFullStack: 0 /* FieldType.Default */,\r\n            stack: 0 /* FieldType.Default */,\r\n            parsedStack: 2 /* FieldType.Array */\r\n        };\r\n        var _self = this;\r\n        if (!_isExceptionDetailsInternal(exception)) {\r\n            var error = exception;\r\n            var evt = error && error.evt;\r\n            if (!isError(error)) {\r\n                error = error[strError] || evt || error;\r\n            }\r\n            _self[_DYN_TYPE_NAME /* @min:%2etypeName */] = dataSanitizeString(logger, _getErrorType(error)) || strNotSpecified;\r\n            _self[_DYN_MESSAGE /* @min:%2emessage */] = dataSanitizeMessage(logger, _formatMessage(exception || error, _self[_DYN_TYPE_NAME /* @min:%2etypeName */])) || strNotSpecified;\r\n            var stack = exception[strStackDetails] || _getStackFromErrorObj(exception);\r\n            _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] = _parseStack(stack);\r\n            // after parsedStack is inited, iterate over each frame object, sanitize its assembly field\r\n            if (isArray(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */])) {\r\n                arrMap(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) {\r\n                    frame[_DYN_ASSEMBLY /* @min:%2eassembly */] = dataSanitizeString(logger, frame[_DYN_ASSEMBLY /* @min:%2eassembly */]);\r\n                    frame[_DYN_FILE_NAME /* @min:%2efileName */] = dataSanitizeString(logger, frame[_DYN_FILE_NAME /* @min:%2efileName */]);\r\n                });\r\n            }\r\n            _self[strStack] = dataSanitizeException(logger, _formatStackTrace(stack));\r\n            _self.hasFullStack = isArray(_self.parsedStack) && _self.parsedStack[_DYN_LENGTH /* @min:%2elength */] > 0;\r\n            if (properties) {\r\n                properties[_DYN_TYPE_NAME /* @min:%2etypeName */] = properties[_DYN_TYPE_NAME /* @min:%2etypeName */] || _self[_DYN_TYPE_NAME /* @min:%2etypeName */];\r\n            }\r\n        }\r\n        else {\r\n            _self[_DYN_TYPE_NAME /* @min:%2etypeName */] = exception[_DYN_TYPE_NAME /* @min:%2etypeName */];\r\n            _self[_DYN_MESSAGE /* @min:%2emessage */] = exception[_DYN_MESSAGE /* @min:%2emessage */];\r\n            _self[strStack] = exception[strStack];\r\n            _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] = exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */] || [];\r\n            _self[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */] = exception[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */];\r\n        }\r\n    }\r\n    _ExceptionDetails.prototype.toInterface = function () {\r\n        var _a;\r\n        var _self = this;\r\n        var parsedStack = _self[_DYN_PARSED_STACK /* @min:%2eparsedStack */] instanceof Array\r\n            && arrMap(_self[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return frame.toInterface(); });\r\n        var exceptionDetailsInterface = (_a = {\r\n                id: _self.id,\r\n                outerId: _self.outerId,\r\n                typeName: _self[_DYN_TYPE_NAME /* @min:%2etypeName */],\r\n                message: _self[_DYN_MESSAGE /* @min:%2emessage */],\r\n                hasFullStack: _self[_DYN_HAS_FULL_STACK /* @min:%2ehasFullStack */],\r\n                stack: _self[strStack]\r\n            },\r\n            _a[_DYN_PARSED_STACK /* @min:parsedStack */] = parsedStack || undefined,\r\n            _a);\r\n        return exceptionDetailsInterface;\r\n    };\r\n    _ExceptionDetails.CreateFromInterface = function (logger, exception) {\r\n        var parsedStack = (exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */] instanceof Array\r\n            && arrMap(exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */], function (frame) { return _StackFrame[_DYN__CREATE_FROM_INTERFA1 /* @min:%2eCreateFromInterface */](frame); }))\r\n            || exception[_DYN_PARSED_STACK /* @min:%2eparsedStack */];\r\n        var exceptionDetails = new _ExceptionDetails(logger, __assign(__assign({}, exception), { parsedStack: parsedStack }));\r\n        return exceptionDetails;\r\n    };\r\n    return _ExceptionDetails;\r\n}());\r\nexport { _ExceptionDetails };\r\nvar _StackFrame = /** @class */ (function () {\r\n    function _StackFrame(sourceFrame, level) {\r\n        this.aiDataContract = {\r\n            level: 1 /* FieldType.Required */,\r\n            method: 1 /* FieldType.Required */,\r\n            assembly: 0 /* FieldType.Default */,\r\n            fileName: 0 /* FieldType.Default */,\r\n            line: 0 /* FieldType.Default */\r\n        };\r\n        var _self = this;\r\n        _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = 0;\r\n        // Not converting this to isString() as typescript uses this logic to \"understand\" the different\r\n        // types for the 2 different code paths\r\n        if (typeof sourceFrame === \"string\") {\r\n            var frame = sourceFrame;\r\n            _self[_DYN_LEVEL /* @min:%2elevel */] = level;\r\n            _self[_DYN_METHOD /* @min:%2emethod */] = NoMethod;\r\n            _self[_DYN_ASSEMBLY /* @min:%2eassembly */] = strTrim(frame);\r\n            _self[_DYN_FILE_NAME /* @min:%2efileName */] = \"\";\r\n            _self[_DYN_LINE /* @min:%2eline */] = 0;\r\n            var matches = frame.match(_StackFrame.regex);\r\n            if (matches && matches[_DYN_LENGTH /* @min:%2elength */] >= 5) {\r\n                _self[_DYN_METHOD /* @min:%2emethod */] = strTrim(matches[2]) || _self[_DYN_METHOD /* @min:%2emethod */];\r\n                _self[_DYN_FILE_NAME /* @min:%2efileName */] = strTrim(matches[4]);\r\n                _self[_DYN_LINE /* @min:%2eline */] = parseInt(matches[5]) || 0;\r\n            }\r\n        }\r\n        else {\r\n            _self[_DYN_LEVEL /* @min:%2elevel */] = sourceFrame[_DYN_LEVEL /* @min:%2elevel */];\r\n            _self[_DYN_METHOD /* @min:%2emethod */] = sourceFrame[_DYN_METHOD /* @min:%2emethod */];\r\n            _self[_DYN_ASSEMBLY /* @min:%2eassembly */] = sourceFrame[_DYN_ASSEMBLY /* @min:%2eassembly */];\r\n            _self[_DYN_FILE_NAME /* @min:%2efileName */] = sourceFrame[_DYN_FILE_NAME /* @min:%2efileName */];\r\n            _self[_DYN_LINE /* @min:%2eline */] = sourceFrame[_DYN_LINE /* @min:%2eline */];\r\n            _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] = 0;\r\n        }\r\n        _self.sizeInBytes += _self.method[_DYN_LENGTH /* @min:%2elength */];\r\n        _self.sizeInBytes += _self.fileName[_DYN_LENGTH /* @min:%2elength */];\r\n        _self.sizeInBytes += _self.assembly[_DYN_LENGTH /* @min:%2elength */];\r\n        // todo: these might need to be removed depending on how the back-end settles on their size calculation\r\n        _self[_DYN_SIZE_IN_BYTES /* @min:%2esizeInBytes */] += _StackFrame.baseSize;\r\n        _self.sizeInBytes += _self.level.toString()[_DYN_LENGTH /* @min:%2elength */];\r\n        _self.sizeInBytes += _self.line.toString()[_DYN_LENGTH /* @min:%2elength */];\r\n    }\r\n    _StackFrame.CreateFromInterface = function (frame) {\r\n        return new _StackFrame(frame, null /* level is available in frame interface */);\r\n    };\r\n    _StackFrame.prototype.toInterface = function () {\r\n        var _self = this;\r\n        return {\r\n            level: _self[_DYN_LEVEL /* @min:%2elevel */],\r\n            method: _self[_DYN_METHOD /* @min:%2emethod */],\r\n            assembly: _self[_DYN_ASSEMBLY /* @min:%2eassembly */],\r\n            fileName: _self[_DYN_FILE_NAME /* @min:%2efileName */],\r\n            line: _self[_DYN_LINE /* @min:%2eline */]\r\n        };\r\n    };\r\n    // regex to match stack frames from ie/chrome/ff\r\n    // methodName=$2, fileName=$4, lineNo=$5, column=$6\r\n    _StackFrame.regex = /^([\\s]+at)?[\\s]{0,50}([^\\@\\()]+?)[\\s]{0,50}(\\@|\\()([^\\(\\n]+):([0-9]+):([0-9]+)(\\)?)$/;\r\n    _StackFrame.baseSize = 58; // '{\"method\":\"\",\"level\":,\"assembly\":\"\",\"fileName\":\"\",\"line\":}'.length\r\n    return _StackFrame;\r\n}());\r\nexport { _StackFrame };\r\n//# sourceMappingURL=Exception.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}