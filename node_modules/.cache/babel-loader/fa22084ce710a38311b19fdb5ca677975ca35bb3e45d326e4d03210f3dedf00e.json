{"ast":null,"code":"/*\n * Application Insights JavaScript SDK - Core, 3.3.1\n * Copyright (c) Microsoft and contributors. All rights reserved.\n */\n\n\"use strict\";\n\nvar _a;\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\nimport { isFunction, objDefine } from \"@nevware21/ts-utils\";\nimport { createDynamicConfig } from \"../Config/DynamicConfig\";\nimport { _DYN_CREATE_NEW, _DYN_DIAG_LOG, _DYN_GET_NEXT, _DYN_GET_PROCESS_TEL_CONT2, _DYN_INITIALIZE, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_PROCESS_NEXT, _DYN_SET_NEXT_PLUGIN, _DYN_TEARDOWN, _DYN_UPDATE, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\nimport { safeGetLogger } from \"./DiagnosticLogger\";\nimport { isNotNullOrUndefined, proxyFunctionAs } from \"./HelperFuncs\";\nimport { STR_CORE, STR_EXTENSION_CONFIG, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext } from \"./ProcessTelemetryContext\";\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\nimport { createUnloadHookContainer } from \"./UnloadHookContainer\";\nvar strGetPlugin = \"getPlugin\";\nvar defaultValues = (_a = {}, _a[STR_EXTENSION_CONFIG] = {\n  isVal: isNotNullOrUndefined,\n  v: {}\n}, _a);\n/**\r\n * BaseTelemetryPlugin provides a basic implementation of the ITelemetryPlugin interface so that plugins\r\n * can avoid implementation the same set of boiler plate code as well as provide a base\r\n * implementation so that new default implementations can be added without breaking all plugins.\r\n */\nvar BaseTelemetryPlugin = /** @class */function () {\n  function BaseTelemetryPlugin() {\n    var _self = this; // Setting _self here as it's used outside of the dynamicProto as well\n    // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\n    var _isinitialized;\n    var _rootCtx; // Used as the root context, holding the current config and initialized core\n    var _nextPlugin; // Used for backward compatibility where plugins don't call the main pipeline\n    var _unloadHandlerContainer;\n    var _hookContainer;\n    _initDefaults();\n    dynamicProto(BaseTelemetryPlugin, _self, function (_self) {\n      _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {\n        _setDefaults(config, core, pluginChain);\n        _isinitialized = true;\n      };\n      _self[_DYN_TEARDOWN /* @min:%2eteardown */] = function (unloadCtx, unloadState) {\n        var _a;\n        // If this plugin has already been torn down (not operational) or is not initialized (core is not set)\n        // or the core being used for unload was not the same core used for initialization.\n        var core = _self[STR_CORE /* @min:%2ecore */];\n        if (!core || unloadCtx && core !== unloadCtx[STR_CORE /* @min:%2ecore */]()) {\n          // Do Nothing as either the plugin is not initialized or was not initialized by the current core\n          return;\n        }\n        var result;\n        var unloadDone = false;\n        var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);\n        var theUnloadState = unloadState || (_a = {\n          reason: 0 /* TelemetryUnloadReason.ManualTeardown */\n        }, _a[_DYN_IS_ASYNC /* @min:isAsync */] = false, _a);\n        function _unloadCallback() {\n          if (!unloadDone) {\n            unloadDone = true;\n            _unloadHandlerContainer.run(theUnloadCtx, unloadState);\n            _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */]());\n            if (result === true) {\n              theUnloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](theUnloadState);\n            }\n            _initDefaults();\n          }\n        }\n        if (!_self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] || _self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {\n          _unloadCallback();\n        } else {\n          // Tell the caller that we will be calling processNext()\n          result = true;\n        }\n        return result;\n      };\n      _self[_DYN_UPDATE /* @min:%2eupdate */] = function (updateCtx, updateState) {\n        // If this plugin has already been torn down (not operational) or is not initialized (core is not set)\n        // or the core being used for unload was not the same core used for initialization.\n        var core = _self[STR_CORE /* @min:%2ecore */];\n        if (!core || updateCtx && core !== updateCtx[STR_CORE /* @min:%2ecore */]()) {\n          // Do Nothing\n          return;\n        }\n        var result;\n        var updateDone = false;\n        var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);\n        var theUpdateState = updateState || {\n          reason: 0 /* TelemetryUpdateReason.Unknown */\n        };\n        function _updateCallback() {\n          if (!updateDone) {\n            updateDone = true;\n            _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT /* @min:%2egetNext */]());\n          }\n        }\n        if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {\n          _updateCallback();\n        } else {\n          result = true;\n        }\n        return result;\n      };\n      proxyFunctionAs(_self, \"_addUnloadCb\", function () {\n        return _unloadHandlerContainer;\n      }, \"add\");\n      proxyFunctionAs(_self, \"_addHook\", function () {\n        return _hookContainer;\n      }, \"add\");\n      objDefine(_self, \"_unloadHooks\", {\n        g: function () {\n          return _hookContainer;\n        }\n      });\n    });\n    // These are added after the dynamicProto so that are not moved to the prototype\n    _self[_DYN_DIAG_LOG /* @min:%2ediagLog */] = function (itemCtx) {\n      return _getTelCtx(itemCtx)[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\n    };\n    _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () {\n      return _isinitialized;\n    };\n    _self.setInitialized = function (isInitialized) {\n      _isinitialized = isInitialized;\n    };\n    // _self.getNextPlugin = () => DO NOT IMPLEMENT\n    // Sub-classes of this base class *should* not be relying on this value and instead\n    // should use processNext() function. If you require access to the plugin use the\n    // IProcessTelemetryContext.getNext().getPlugin() while in the pipeline, Note getNext() may return null.\n    _self[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] = function (next) {\n      _nextPlugin = next;\n    };\n    _self[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = function (env, itemCtx) {\n      if (itemCtx) {\n        // Normal core execution sequence\n        itemCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);\n      } else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\n        // Looks like backward compatibility or out of band processing. And as it looks\n        // like a ITelemetryPlugin or ITelemetryPluginChain, just call processTelemetry\n        _nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, null);\n      }\n    };\n    _self._getTelCtx = _getTelCtx;\n    function _getTelCtx(currentCtx) {\n      if (currentCtx === void 0) {\n        currentCtx = null;\n      }\n      var itemCtx = currentCtx;\n      if (!itemCtx) {\n        var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE /* @min:%2ecore */]);\n        // tslint:disable-next-line: prefer-conditional-expression\n        if (_nextPlugin && _nextPlugin[strGetPlugin]) {\n          // Looks like a chain object\n          itemCtx = rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin[strGetPlugin]);\n        } else {\n          itemCtx = rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin);\n        }\n      }\n      return itemCtx;\n    }\n    function _setDefaults(config, core, pluginChain) {\n      // Make sure the extensionConfig exists and the config is dynamic\n      createDynamicConfig(config, defaultValues, safeGetLogger(core));\n      if (!pluginChain && core) {\n        // Get the first plugin from the core\n        pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2 /* @min:%2egetProcessTelContext */]()[_DYN_GET_NEXT /* @min:%2egetNext */]();\n      }\n      var nextPlugin = _nextPlugin;\n      if (_nextPlugin && _nextPlugin[strGetPlugin]) {\n        // If it looks like a proxy/chain then get the plugin\n        nextPlugin = _nextPlugin[strGetPlugin]();\n      }\n      // Support legacy plugins where core was defined as a property\n      _self[STR_CORE /* @min:%2ecore */] = core;\n      _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);\n    }\n    function _initDefaults() {\n      _isinitialized = false;\n      _self[STR_CORE /* @min:%2ecore */] = null;\n      _rootCtx = null;\n      _nextPlugin = null;\n      _hookContainer = createUnloadHookContainer();\n      _unloadHandlerContainer = createUnloadHandlerContainer();\n    }\n  }\n  // Removed Stub for BaseTelemetryPlugin.prototype.initialize.\n  // Removed Stub for BaseTelemetryPlugin.prototype.teardown.\n  // Removed Stub for BaseTelemetryPlugin.prototype.update.\n  // Removed Stub for BaseTelemetryPlugin.prototype._addUnloadCb.\n  // Removed Stub for BaseTelemetryPlugin.prototype._addHook.\n  // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any\n  // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n  BaseTelemetryPlugin.__ieDyn = 1;\n  return BaseTelemetryPlugin;\n}();\nexport { BaseTelemetryPlugin };","map":{"version":3,"names":["_a","dynamicProto","isFunction","objDefine","createDynamicConfig","_DYN_CREATE_NEW","_DYN_DIAG_LOG","_DYN_GET_NEXT","_DYN_GET_PROCESS_TEL_CONT2","_DYN_INITIALIZE","_DYN_IS_ASYNC","_DYN_IS_INITIALIZED","_DYN_PROCESS_NEXT","_DYN_SET_NEXT_PLUGIN","_DYN_TEARDOWN","_DYN_UPDATE","_DYN__DO_TEARDOWN","safeGetLogger","isNotNullOrUndefined","proxyFunctionAs","STR_CORE","STR_EXTENSION_CONFIG","STR_PROCESS_TELEMETRY","createProcessTelemetryContext","createProcessTelemetryUnloadContext","createProcessTelemetryUpdateContext","createUnloadHandlerContainer","createUnloadHookContainer","strGetPlugin","defaultValues","isVal","v","BaseTelemetryPlugin","_self","_isinitialized","_rootCtx","_nextPlugin","_unloadHandlerContainer","_hookContainer","_initDefaults","config","core","extensions","pluginChain","_setDefaults","unloadCtx","unloadState","result","unloadDone","theUnloadCtx","theUnloadState","reason","_unloadCallback","run","updateCtx","updateState","updateDone","theUpdateCtx","theUpdateState","_updateCallback","getCfg","_doUpdate","g","itemCtx","_getTelCtx","setInitialized","isInitialized","next","env","currentCtx","rootCtx","nextPlugin"],"sources":["/home/veeresh133/app/json-holder-api/react-az/node_modules/@microsoft/applicationinsights-core-js/dist-es5/JavaScriptSDK/BaseTelemetryPlugin.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n\"use strict\";\r\nvar _a;\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { isFunction, objDefine } from \"@nevware21/ts-utils\";\r\nimport { createDynamicConfig } from \"../Config/DynamicConfig\";\r\nimport { _DYN_CREATE_NEW, _DYN_DIAG_LOG, _DYN_GET_NEXT, _DYN_GET_PROCESS_TEL_CONT2, _DYN_INITIALIZE, _DYN_IS_ASYNC, _DYN_IS_INITIALIZED, _DYN_PROCESS_NEXT, _DYN_SET_NEXT_PLUGIN, _DYN_TEARDOWN, _DYN_UPDATE, _DYN__DO_TEARDOWN } from \"../__DynamicConstants\";\r\nimport { safeGetLogger } from \"./DiagnosticLogger\";\r\nimport { isNotNullOrUndefined, proxyFunctionAs } from \"./HelperFuncs\";\r\nimport { STR_CORE, STR_EXTENSION_CONFIG, STR_PROCESS_TELEMETRY } from \"./InternalConstants\";\r\nimport { createProcessTelemetryContext, createProcessTelemetryUnloadContext, createProcessTelemetryUpdateContext } from \"./ProcessTelemetryContext\";\r\nimport { createUnloadHandlerContainer } from \"./UnloadHandlerContainer\";\r\nimport { createUnloadHookContainer } from \"./UnloadHookContainer\";\r\nvar strGetPlugin = \"getPlugin\";\r\nvar defaultValues = (_a = {},\r\n    _a[STR_EXTENSION_CONFIG] = { isVal: isNotNullOrUndefined, v: {} },\r\n    _a);\r\n/**\r\n * BaseTelemetryPlugin provides a basic implementation of the ITelemetryPlugin interface so that plugins\r\n * can avoid implementation the same set of boiler plate code as well as provide a base\r\n * implementation so that new default implementations can be added without breaking all plugins.\r\n */\r\nvar BaseTelemetryPlugin = /** @class */ (function () {\r\n    function BaseTelemetryPlugin() {\r\n        var _self = this; // Setting _self here as it's used outside of the dynamicProto as well\r\n        // NOTE!: DON'T set default values here, instead set them in the _initDefaults() function as it is also called during teardown()\r\n        var _isinitialized;\r\n        var _rootCtx; // Used as the root context, holding the current config and initialized core\r\n        var _nextPlugin; // Used for backward compatibility where plugins don't call the main pipeline\r\n        var _unloadHandlerContainer;\r\n        var _hookContainer;\r\n        _initDefaults();\r\n        dynamicProto(BaseTelemetryPlugin, _self, function (_self) {\r\n            _self[_DYN_INITIALIZE /* @min:%2einitialize */] = function (config, core, extensions, pluginChain) {\r\n                _setDefaults(config, core, pluginChain);\r\n                _isinitialized = true;\r\n            };\r\n            _self[_DYN_TEARDOWN /* @min:%2eteardown */] = function (unloadCtx, unloadState) {\r\n                var _a;\r\n                // If this plugin has already been torn down (not operational) or is not initialized (core is not set)\r\n                // or the core being used for unload was not the same core used for initialization.\r\n                var core = _self[STR_CORE /* @min:%2ecore */];\r\n                if (!core || (unloadCtx && core !== unloadCtx[STR_CORE /* @min:%2ecore */]())) {\r\n                    // Do Nothing as either the plugin is not initialized or was not initialized by the current core\r\n                    return;\r\n                }\r\n                var result;\r\n                var unloadDone = false;\r\n                var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);\r\n                var theUnloadState = unloadState || (_a = {\r\n                        reason: 0 /* TelemetryUnloadReason.ManualTeardown */\r\n                    },\r\n                    _a[_DYN_IS_ASYNC /* @min:isAsync */] = false,\r\n                    _a);\r\n                function _unloadCallback() {\r\n                    if (!unloadDone) {\r\n                        unloadDone = true;\r\n                        _unloadHandlerContainer.run(theUnloadCtx, unloadState);\r\n                        _hookContainer.run(theUnloadCtx[_DYN_DIAG_LOG /* @min:%2ediagLog */]());\r\n                        if (result === true) {\r\n                            theUnloadCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](theUnloadState);\r\n                        }\r\n                        _initDefaults();\r\n                    }\r\n                }\r\n                if (!_self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */] || _self[_DYN__DO_TEARDOWN /* @min:%2e_doTeardown */](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {\r\n                    _unloadCallback();\r\n                }\r\n                else {\r\n                    // Tell the caller that we will be calling processNext()\r\n                    result = true;\r\n                }\r\n                return result;\r\n            };\r\n            _self[_DYN_UPDATE /* @min:%2eupdate */] = function (updateCtx, updateState) {\r\n                // If this plugin has already been torn down (not operational) or is not initialized (core is not set)\r\n                // or the core being used for unload was not the same core used for initialization.\r\n                var core = _self[STR_CORE /* @min:%2ecore */];\r\n                if (!core || (updateCtx && core !== updateCtx[STR_CORE /* @min:%2ecore */]())) {\r\n                    // Do Nothing\r\n                    return;\r\n                }\r\n                var result;\r\n                var updateDone = false;\r\n                var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);\r\n                var theUpdateState = updateState || {\r\n                    reason: 0 /* TelemetryUpdateReason.Unknown */\r\n                };\r\n                function _updateCallback() {\r\n                    if (!updateDone) {\r\n                        updateDone = true;\r\n                        _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT /* @min:%2egetNext */]());\r\n                    }\r\n                }\r\n                if (!_self._doUpdate || _self._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {\r\n                    _updateCallback();\r\n                }\r\n                else {\r\n                    result = true;\r\n                }\r\n                return result;\r\n            };\r\n            proxyFunctionAs(_self, \"_addUnloadCb\", function () { return _unloadHandlerContainer; }, \"add\");\r\n            proxyFunctionAs(_self, \"_addHook\", function () { return _hookContainer; }, \"add\");\r\n            objDefine(_self, \"_unloadHooks\", { g: function () { return _hookContainer; } });\r\n        });\r\n        // These are added after the dynamicProto so that are not moved to the prototype\r\n        _self[_DYN_DIAG_LOG /* @min:%2ediagLog */] = function (itemCtx) {\r\n            return _getTelCtx(itemCtx)[_DYN_DIAG_LOG /* @min:%2ediagLog */]();\r\n        };\r\n        _self[_DYN_IS_INITIALIZED /* @min:%2eisInitialized */] = function () {\r\n            return _isinitialized;\r\n        };\r\n        _self.setInitialized = function (isInitialized) {\r\n            _isinitialized = isInitialized;\r\n        };\r\n        // _self.getNextPlugin = () => DO NOT IMPLEMENT\r\n        // Sub-classes of this base class *should* not be relying on this value and instead\r\n        // should use processNext() function. If you require access to the plugin use the\r\n        // IProcessTelemetryContext.getNext().getPlugin() while in the pipeline, Note getNext() may return null.\r\n        _self[_DYN_SET_NEXT_PLUGIN /* @min:%2esetNextPlugin */] = function (next) {\r\n            _nextPlugin = next;\r\n        };\r\n        _self[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */] = function (env, itemCtx) {\r\n            if (itemCtx) {\r\n                // Normal core execution sequence\r\n                itemCtx[_DYN_PROCESS_NEXT /* @min:%2eprocessNext */](env);\r\n            }\r\n            else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */])) {\r\n                // Looks like backward compatibility or out of band processing. And as it looks\r\n                // like a ITelemetryPlugin or ITelemetryPluginChain, just call processTelemetry\r\n                _nextPlugin[STR_PROCESS_TELEMETRY /* @min:%2eprocessTelemetry */](env, null);\r\n            }\r\n        };\r\n        _self._getTelCtx = _getTelCtx;\r\n        function _getTelCtx(currentCtx) {\r\n            if (currentCtx === void 0) { currentCtx = null; }\r\n            var itemCtx = currentCtx;\r\n            if (!itemCtx) {\r\n                var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE /* @min:%2ecore */]);\r\n                // tslint:disable-next-line: prefer-conditional-expression\r\n                if (_nextPlugin && _nextPlugin[strGetPlugin]) {\r\n                    // Looks like a chain object\r\n                    itemCtx = rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin[strGetPlugin]);\r\n                }\r\n                else {\r\n                    itemCtx = rootCtx[_DYN_CREATE_NEW /* @min:%2ecreateNew */](null, _nextPlugin);\r\n                }\r\n            }\r\n            return itemCtx;\r\n        }\r\n        function _setDefaults(config, core, pluginChain) {\r\n            // Make sure the extensionConfig exists and the config is dynamic\r\n            createDynamicConfig(config, defaultValues, safeGetLogger(core));\r\n            if (!pluginChain && core) {\r\n                // Get the first plugin from the core\r\n                pluginChain = core[_DYN_GET_PROCESS_TEL_CONT2 /* @min:%2egetProcessTelContext */]()[_DYN_GET_NEXT /* @min:%2egetNext */]();\r\n            }\r\n            var nextPlugin = _nextPlugin;\r\n            if (_nextPlugin && _nextPlugin[strGetPlugin]) {\r\n                // If it looks like a proxy/chain then get the plugin\r\n                nextPlugin = _nextPlugin[strGetPlugin]();\r\n            }\r\n            // Support legacy plugins where core was defined as a property\r\n            _self[STR_CORE /* @min:%2ecore */] = core;\r\n            _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);\r\n        }\r\n        function _initDefaults() {\r\n            _isinitialized = false;\r\n            _self[STR_CORE /* @min:%2ecore */] = null;\r\n            _rootCtx = null;\r\n            _nextPlugin = null;\r\n            _hookContainer = createUnloadHookContainer();\r\n            _unloadHandlerContainer = createUnloadHandlerContainer();\r\n        }\r\n    }\r\n    BaseTelemetryPlugin.prototype.initialize = function (config, core, extensions, pluginChain) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Tear down the plugin and remove any hooked value, the plugin should be removed so that it is no longer initialized and\r\n     * therefore could be re-initialized after being torn down. The plugin should ensure that once this has been called any further\r\n     * processTelemetry calls are ignored and it just calls the processNext() with the provided context.\r\n     * @param unloadCtx - This is the context that should be used during unloading.\r\n     * @param unloadState - The details / state of the unload process, it holds details like whether it should be unloaded synchronously or asynchronously and the reason for the unload.\r\n     * @returns boolean - true if the plugin has or will call processNext(), this for backward compatibility as previously teardown was synchronous and returned nothing.\r\n     */\r\n    BaseTelemetryPlugin.prototype.teardown = function (unloadCtx, unloadState) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n        return false;\r\n    };\r\n    /**\r\n     * The the plugin should re-evaluate configuration and update any cached configuration settings.\r\n     * @param updateCtx - This is the context that should be used during updating.\r\n     * @param updateState - The details / state of the update process, it holds details like the current and previous configuration.\r\n     * @returns boolean - true if the plugin has or will call updateCtx.processNext(), this allows the plugin to perform any asynchronous operations.\r\n     */\r\n    BaseTelemetryPlugin.prototype.update = function (updateCtx, updateState) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add an unload handler that will be called when the SDK is being unloaded\r\n     * @param handler - the handler\r\n     */\r\n    BaseTelemetryPlugin.prototype._addUnloadCb = function (handler) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Add this hook so that it is automatically removed during unloading\r\n     * @param hooks - The single hook or an array of IInstrumentHook objects\r\n     */\r\n    BaseTelemetryPlugin.prototype._addHook = function (hooks) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return BaseTelemetryPlugin;\r\n}());\r\nexport { BaseTelemetryPlugin };\r\n//# sourceMappingURL=BaseTelemetryPlugin.js.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}