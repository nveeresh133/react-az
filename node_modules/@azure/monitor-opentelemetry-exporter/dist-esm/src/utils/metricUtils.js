// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { DataPointType } from "@opentelemetry/sdk-metrics";
import { createTagsFromResource } from "./common";
import { BreezePerformanceCounterNames, OTelPerformanceCounterNames } from "../types";
const breezePerformanceCountersMap = new Map([
    [OTelPerformanceCounterNames.PRIVATE_BYTES, BreezePerformanceCounterNames.PRIVATE_BYTES],
    [OTelPerformanceCounterNames.AVAILABLE_BYTES, BreezePerformanceCounterNames.AVAILABLE_BYTES],
    [OTelPerformanceCounterNames.PROCESSOR_TIME, BreezePerformanceCounterNames.PROCESSOR_TIME],
    [OTelPerformanceCounterNames.PROCESS_TIME, BreezePerformanceCounterNames.PROCESS_TIME],
    [OTelPerformanceCounterNames.REQUEST_RATE, BreezePerformanceCounterNames.REQUEST_RATE],
    [OTelPerformanceCounterNames.REQUEST_DURATION, BreezePerformanceCounterNames.REQUEST_DURATION],
]);
function createPropertiesFromMetricAttributes(attributes) {
    const properties = {};
    if (attributes) {
        for (const key of Object.keys(attributes)) {
            properties[key] = attributes[key];
        }
    }
    return properties;
}
/**
 * Metric to Azure envelope parsing.
 * @internal
 */
export function resourceMetricsToEnvelope(metrics, ikey, isStatsbeat) {
    const envelopes = [];
    const time = new Date();
    const instrumentationKey = ikey;
    const tags = createTagsFromResource(metrics.resource);
    let envelopeName;
    if (isStatsbeat) {
        envelopeName = "Microsoft.ApplicationInsights.Statsbeat";
    }
    else {
        envelopeName = "Microsoft.ApplicationInsights.Metric";
    }
    metrics.scopeMetrics.forEach((scopeMetric) => {
        scopeMetric.metrics.forEach((metric) => {
            metric.dataPoints.forEach((dataPoint) => {
                const baseData = {
                    metrics: [],
                    version: 2,
                    properties: {},
                };
                baseData.properties = createPropertiesFromMetricAttributes(dataPoint.attributes);
                let perfCounterName;
                if (breezePerformanceCountersMap.has(metric.descriptor.name)) {
                    perfCounterName = breezePerformanceCountersMap.get(metric.descriptor.name);
                }
                const metricDataPoint = {
                    name: perfCounterName ? perfCounterName : metric.descriptor.name,
                    value: 0,
                    dataPointType: "Aggregation",
                };
                if (metric.dataPointType === DataPointType.SUM ||
                    metric.dataPointType === DataPointType.GAUGE) {
                    metricDataPoint.value = dataPoint.value;
                    metricDataPoint.count = 1;
                }
                else {
                    metricDataPoint.value = dataPoint.value.sum || 0;
                    metricDataPoint.count = dataPoint.value.count;
                    metricDataPoint.max = dataPoint.value.max;
                    metricDataPoint.min = dataPoint.value.min;
                }
                baseData.metrics.push(metricDataPoint);
                const envelope = {
                    name: envelopeName,
                    time: time,
                    sampleRate: 100, // Metrics are never sampled
                    instrumentationKey: instrumentationKey,
                    tags: tags,
                    version: 1,
                    data: {
                        baseType: "MetricData",
                        baseData: Object.assign({}, baseData),
                    },
                };
                envelopes.push(envelope);
            });
        });
    });
    return envelopes;
}
//# sourceMappingURL=metricUtils.js.map