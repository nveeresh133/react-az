'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var sdkTraceBase = require('@opentelemetry/sdk-trace-base');
var api = require('@opentelemetry/api');
var core = require('@opentelemetry/core');
var url = require('url');
var semanticConventions = require('@opentelemetry/semantic-conventions');
var os$1 = require('os');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var sdkMetrics = require('@opentelemetry/sdk-metrics');
var fs = require('fs');
var path = require('path');
var child_process = require('child_process');
var util = require('util');
var coreClient = require('@azure/core-client');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var os__namespace = /*#__PURE__*/_interopNamespaceDefault(os$1);
var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
var child_process__namespace = /*#__PURE__*/_interopNamespaceDefault(child_process);
var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * AI MS Links.
 * @internal
 */
const MS_LINKS = "_MS.links";
/**
 * AI enqueued time attribute.
 * @internal
 */
const ENQUEUED_TIME = "enqueuedTime";
/**
 * AI time since enqueued attribute.
 * @internal
 */
const TIME_SINCE_ENQUEUED = "timeSinceEnqueued";
/**
 * AzureMonitorTraceExporter version.
 * @internal
 */
const packageVersion = "1.0.0-beta.25";
var DependencyTypes;
(function (DependencyTypes) {
    DependencyTypes["InProc"] = "InProc";
    DependencyTypes["QueueMessage"] = "Queue Message";
    DependencyTypes["Sql"] = "SQL";
    DependencyTypes["Http"] = "Http";
    DependencyTypes["Grpc"] = "GRPC";
    DependencyTypes["Wcf"] = "WCF Service";
})(DependencyTypes || (DependencyTypes = {}));
const AzureMonitorSampleRate = "microsoft.sample_rate";
const ApplicationInsightsBaseType = "_MS.baseType";
const ApplicationInsightsMessageName = "Microsoft.ApplicationInsights.Message";
const ApplicationInsightsExceptionName = "Microsoft.ApplicationInsights.Exception";
const ApplicationInsightsPageViewName = "Microsoft.ApplicationInsights.PageView";
const ApplicationInsightsAvailabilityName = "Microsoft.ApplicationInsights.Availability";
const ApplicationInsightsEventName = "Microsoft.ApplicationInsights.Event";
const ApplicationInsightsMessageBaseType = "MessageData";
const ApplicationInsightsExceptionBaseType = "ExceptionData";
const ApplicationInsightsPageViewBaseType = "PageViewData";
const ApplicationInsightsAvailabilityBaseType = "AvailabilityData";
const ApplicationInsightsEventBaseType = "EventData";

/**
 * ApplicationInsightsSampler is responsible for the following:
 * Implements same trace id hashing algorithm so that traces are sampled the same across multiple nodes
 * Adds item count to span attribute if span is sampled (needed for ingestion service)
 * @param samplingRatio - 0 to 1 value.
 */
class ApplicationInsightsSampler {
    /**
     * Initializes a new instance of the ApplicationInsightsSampler class.
     * @param samplingRatio - Value in the range [0,1], 1 meaning all data will sampled and 0 all Tracing data will be sampled out.
     */
    constructor(samplingRatio = 1) {
        this.samplingRatio = samplingRatio;
        if (this.samplingRatio > 1 || this.samplingRatio < 0 || !Number.isFinite(this.samplingRatio)) {
            throw new Error("Wrong sampling rate, data will not be sampled out");
        }
        this._sampleRate = Math.round(this.samplingRatio * 100);
    }
    /**
     * Checks whether span needs to be created and tracked.
     *
     * @param context - Parent Context which may contain a span.
     * @param traceId - traceif of the span to be created. It can be different from the
     *     traceId in the {@link SpanContext}. Typically in situations when the
     *     span to be created starts a new trace.
     * @param spanName - Name of the span to be created.
     * @param spanKind - Kind of the span to be created.
     * @param attributes - Initial set of SpanAttributes for the Span being constructed.
     * @param links - Collection of links that will be associated with the Span to
     *     be created. Typically useful for batch operations.
     * @returns a {@link SamplingResult}.
     */
    shouldSample(
    // @ts-expect-error unused argument
    context, traceId, 
    // @ts-expect-error unused argument
    spanName, 
    // @ts-expect-error unused argument
    spanKind, attributes, 
    // @ts-expect-error unused argument
    links) {
        let isSampledIn = false;
        if (this._sampleRate === 100) {
            isSampledIn = true;
        }
        else if (this._sampleRate === 0) {
            isSampledIn = false;
        }
        else {
            isSampledIn = this._getSamplingHashCode(traceId) < this._sampleRate;
        }
        // Add sample rate as span attribute
        attributes = attributes || {};
        // Only send the sample rate if it's not 100
        if (this._sampleRate !== 100) {
            attributes[AzureMonitorSampleRate] = this._sampleRate;
        }
        return isSampledIn
            ? { decision: sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED, attributes: attributes }
            : { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, attributes: attributes };
    }
    /**
     * Return Sampler description
     */
    toString() {
        return `ApplicationInsightsSampler{${this.samplingRatio}}`;
    }
    _getSamplingHashCode(input) {
        const csharpMin = -2147483648;
        const csharpMax = 2147483647;
        let hash = 5381;
        if (!input) {
            return 0;
        }
        while (input.length < 8) {
            input = input + input;
        }
        for (let i = 0; i < input.length; i++) {
            // JS doesn't respond to integer overflow by wrapping around. Simulate it with bitwise operators ( | 0)
            hash = ((((hash << 5) + hash) | 0) + input.charCodeAt(i)) | 0;
        }
        hash = hash <= csharpMin ? csharpMax : Math.abs(hash);
        return (hash / csharpMax) * 100;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure service API version.
 */
exports.ServiceApiVersion = void 0;
(function (ServiceApiVersion) {
    /**
     * V2 Version
     */
    ServiceApiVersion["V2"] = "2020-09-15_Preview";
})(exports.ServiceApiVersion || (exports.ServiceApiVersion = {}));
/**
 * Default Breeze endpoint.
 * @internal
 */
const DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
/**
 * Default Breeze API version.
 * @internal
 */
exports.ServiceApiVersion.V2;
/**
 * Default Live Metrics endpoint.
 * @internal
 */
const DEFAULT_LIVEMETRICS_ENDPOINT = "https://rt.services.visualstudio.com";
/**
 * Connection string environment variable name.
 * @internal
 */
const ENV_CONNECTION_STRING = "APPLICATIONINSIGHTS_CONNECTION_STRING";
/**
 * Disable Statsbeat environment variable name.
 * @internal
 */
const ENV_DISABLE_STATSBEAT = "APPLICATION_INSIGHTS_NO_STATSBEAT";
/**
 * QuickPulse metric counter names.
 * @internal
 */
var QuickPulseCounter;
(function (QuickPulseCounter) {
    // Memory
    QuickPulseCounter["COMMITTED_BYTES"] = "\\Memory\\Committed Bytes";
    // CPU
    QuickPulseCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    // Request
    QuickPulseCounter["REQUEST_RATE"] = "\\ApplicationInsights\\Requests/Sec";
    QuickPulseCounter["REQUEST_FAILURE_RATE"] = "\\ApplicationInsights\\Requests Failed/Sec";
    QuickPulseCounter["REQUEST_DURATION"] = "\\ApplicationInsights\\Request Duration";
    // Dependency
    QuickPulseCounter["DEPENDENCY_RATE"] = "\\ApplicationInsights\\Dependency Calls/Sec";
    QuickPulseCounter["DEPENDENCY_FAILURE_RATE"] = "\\ApplicationInsights\\Dependency Calls Failed/Sec";
    QuickPulseCounter["DEPENDENCY_DURATION"] = "\\ApplicationInsights\\Dependency Call Duration";
    // Exception
    QuickPulseCounter["EXCEPTION_RATE"] = "\\ApplicationInsights\\Exceptions/Sec";
})(QuickPulseCounter || (QuickPulseCounter = {}));
/**
 * Performance metric counter names.
 * @internal
 */
var PerformanceCounter;
(function (PerformanceCounter) {
    // Memory
    PerformanceCounter["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
    PerformanceCounter["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
    // CPU
    PerformanceCounter["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    PerformanceCounter["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
    // Requests
    PerformanceCounter["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
    PerformanceCounter["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
})(PerformanceCounter || (PerformanceCounter = {}));
/**
 * Map a PerformanceCounter/QuickPulseCounter to a QuickPulseCounter. If no mapping exists, mapping is *undefined*
 * @internal
 */
({
    [PerformanceCounter.PROCESSOR_TIME]: QuickPulseCounter.PROCESSOR_TIME,
    [PerformanceCounter.REQUEST_RATE]: QuickPulseCounter.REQUEST_RATE,
    [PerformanceCounter.REQUEST_DURATION]: QuickPulseCounter.REQUEST_DURATION,
    // Remap quick pulse only counters
    [QuickPulseCounter.COMMITTED_BYTES]: QuickPulseCounter.COMMITTED_BYTES,
    [QuickPulseCounter.REQUEST_FAILURE_RATE]: QuickPulseCounter.REQUEST_FAILURE_RATE,
    [QuickPulseCounter.DEPENDENCY_RATE]: QuickPulseCounter.DEPENDENCY_RATE,
    [QuickPulseCounter.DEPENDENCY_FAILURE_RATE]: QuickPulseCounter.DEPENDENCY_FAILURE_RATE,
    [QuickPulseCounter.DEPENDENCY_DURATION]: QuickPulseCounter.DEPENDENCY_DURATION,
    [QuickPulseCounter.EXCEPTION_RATE]: QuickPulseCounter.EXCEPTION_RATE,
});

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ConnectionString parser.
 * @internal
 */
class ConnectionStringParser {
    static parse(connectionString) {
        if (!connectionString) {
            return {};
        }
        const kvPairs = connectionString.split(ConnectionStringParser.FIELDS_SEPARATOR);
        let isValid = true;
        const result = kvPairs.reduce((fields, kv) => {
            const kvParts = kv.split(ConnectionStringParser.FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts.length === 2) {
                // only save fields with valid formats
                const key = kvParts[0].toLowerCase();
                const value = kvParts[1];
                return Object.assign(Object.assign({}, fields), { [key]: value });
            }
            api.diag.error(`Connection string key-value pair is invalid: ${kv}`, `Entire connection string will be discarded`, connectionString);
            isValid = false;
            return fields;
        }, {});
        if (isValid && Object.keys(result).length > 0) {
            // this is a valid connection string, so parse the results
            if (result.endpointsuffix) {
                // use endpoint suffix where overrides are not provided
                const locationPrefix = result.location ? `${result.location}.` : "";
                result.ingestionendpoint =
                    result.ingestionendpoint || `https://${locationPrefix}dc.${result.endpointsuffix}`;
                result.liveendpoint =
                    result.liveendpoint || `https://${locationPrefix}live.${result.endpointsuffix}`;
            }
            result.ingestionendpoint = result.ingestionendpoint
                ? ConnectionStringParser.sanitizeUrl(result.ingestionendpoint)
                : DEFAULT_BREEZE_ENDPOINT;
            result.liveendpoint = result.liveendpoint
                ? ConnectionStringParser.sanitizeUrl(result.liveendpoint)
                : DEFAULT_LIVEMETRICS_ENDPOINT;
            if (result.authorization && result.authorization.toLowerCase() !== "ikey") {
                api.diag.warn(`Connection String contains an unsupported 'Authorization' value: ${result.authorization}. Defaulting to 'Authorization=ikey'. Instrumentation Key ${result.instrumentationkey}`);
            }
        }
        else {
            api.diag.error("An invalid connection string was passed in. There may be telemetry loss", connectionString);
        }
        return result;
    }
    static sanitizeUrl(url) {
        let newUrl = url.trim();
        if (newUrl.indexOf("https://") < 0) {
            // Try to update http to https
            newUrl = newUrl.replace("http://", "https://");
        }
        // Remove final slash if present
        if (newUrl[newUrl.length - 1] === "/") {
            newUrl = newUrl.slice(0, -1);
        }
        return newUrl;
    }
    static validateInstrumentationKey(iKey) {
        if (iKey.startsWith("InstrumentationKey=")) {
            const startIndex = iKey.indexOf("InstrumentationKey=") + "InstrumentationKey=".length;
            const endIndex = iKey.indexOf(";", startIndex);
            iKey = iKey.substring(startIndex, endIndex);
        }
        const UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
        const regexp = new RegExp(UUID_Regex);
        return regexp.test(iKey);
    }
}
ConnectionStringParser.FIELDS_SEPARATOR = ";";
ConnectionStringParser.FIELD_KEY_VALUE_SEPARATOR = "=";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure Monitor OpenTelemetry Trace Exporter.
 */
class AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorBaseExporter class.
     * @param AzureMonitorExporterOptions - Exporter configuration.
     */
    constructor(options = {}, isStatsbeatExporter) {
        var _a;
        /**
         * Instrumentation key to be used for exported envelopes
         */
        this.instrumentationKey = "";
        /**
         * Ingestion Endpoint URL
         */
        this.endpointUrl = "";
        /**
         *Flag to determine if exporter will generate Statsbeat data
         */
        this.trackStatsbeat = false;
        this.options = options;
        this.instrumentationKey = "";
        this.endpointUrl = DEFAULT_BREEZE_ENDPOINT;
        const connectionString = this.options.connectionString || process.env[ENV_CONNECTION_STRING];
        this.isStatsbeatExporter = isStatsbeatExporter ? isStatsbeatExporter : false;
        if (connectionString) {
            const parsedConnectionString = ConnectionStringParser.parse(connectionString);
            this.instrumentationKey =
                parsedConnectionString.instrumentationkey || this.instrumentationKey;
            this.endpointUrl = ((_a = parsedConnectionString.ingestionendpoint) === null || _a === void 0 ? void 0 : _a.trim()) || this.endpointUrl;
            this.aadAudience = parsedConnectionString.aadaudience;
        }
        // Instrumentation key is required
        if (!this.instrumentationKey) {
            const message = "No instrumentation key or connection string was provided to the Azure Monitor Exporter";
            api.diag.error(message);
            throw new Error(message);
        }
        if (!ConnectionStringParser.validateInstrumentationKey(this.instrumentationKey)) {
            const message = "Invalid instrumentation key was provided to the Azure Monitor Exporter";
            api.diag.error(message);
            throw new Error(message);
        }
        this.trackStatsbeat = !this.isStatsbeatExporter && !process.env[ENV_DISABLE_STATSBEAT];
        api.diag.debug("AzureMonitorExporter was successfully setup");
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
class FileAccessControl {
    // Check if file access control could be enabled
    static checkFileProtection() {
        if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION &&
            !FileAccessControl.OS_FILE_PROTECTION_CHECKED) {
            FileAccessControl.OS_FILE_PROTECTION_CHECKED = true;
            // Node's chmod levels do not appropriately restrict file access on Windows
            // Use the built-in command line tool ICACLS on Windows to properly restrict
            // access to the temporary directory used for disk retry mode.
            if (FileAccessControl.USE_ICACLS) {
                // This should be async - but it's currently safer to have this synchronous
                // This guarantees we can immediately fail setDiskRetryMode if we need to
                try {
                    FileAccessControl.OS_PROVIDES_FILE_PROTECTION = fs__namespace.existsSync(FileAccessControl.ICACLS_PATH);
                }
                catch (e) {
                    // Ignore error
                }
                if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {
                    api.diag.warn("Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
                }
            }
            else {
                // chmod works everywhere else
                FileAccessControl.OS_PROVIDES_FILE_PROTECTION = true;
            }
        }
    }
    static async applyACLRules(directory) {
        if (FileAccessControl.USE_ICACLS) {
            if (FileAccessControl.ACLED_DIRECTORIES[directory] === undefined) {
                // Avoid multiple calls race condition by setting ACLED_DIRECTORIES to false for this directory immediately
                // If batches are being failed faster than the processes spawned below return, some data won't be stored to disk
                // This is better than the alternative of potentially infinitely spawned processes
                FileAccessControl.ACLED_DIRECTORIES[directory] = false;
                try {
                    // Restrict this directory to only current user and administrator access
                    const identity = await this._getACLIdentity();
                    await this._runICACLS(this._getACLArguments(directory, identity));
                    FileAccessControl.ACLED_DIRECTORIES[directory] = true;
                }
                catch (ex) {
                    FileAccessControl.ACLED_DIRECTORIES[directory] = false; // false is used to cache failed (vs undefined which is "not yet tried")
                    throw ex;
                }
            }
            else {
                if (!FileAccessControl.ACLED_DIRECTORIES[directory]) {
                    throw new Error("Setting ACL restrictions did not succeed (cached result)");
                }
            }
        }
    }
    static applyACLRulesSync(directory) {
        if (FileAccessControl.USE_ICACLS) {
            // For performance, only run ACL rules if we haven't already during this session
            if (FileAccessControl.ACLED_DIRECTORIES[directory] === undefined) {
                this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));
                FileAccessControl.ACLED_DIRECTORIES[directory] = true; // If we get here, it succeeded. _runIACLSSync will throw on failures
                return;
            }
            else if (!FileAccessControl.ACLED_DIRECTORIES[directory]) {
                // falsy but not undefined
                throw new Error("Setting ACL restrictions did not succeed (cached result)");
            }
        }
    }
    static _runICACLS(args) {
        return new Promise((resolve, reject) => {
            const aclProc = child_process__namespace.spawn(FileAccessControl.ICACLS_PATH, args, {
                windowsHide: true,
            });
            aclProc.on("error", (e) => reject(e));
            aclProc.on("close", (code) => {
                if (code === 0) {
                    resolve();
                }
                else {
                    reject(new Error(`Setting ACL restrictions did not succeed (ICACLS returned code ${code})`));
                }
            });
        });
    }
    static _runICACLSSync(args) {
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process__namespace.spawnSync) {
            const aclProc = child_process__namespace.spawnSync(FileAccessControl.ICACLS_PATH, args, {
                windowsHide: true,
            });
            if (aclProc.error) {
                throw aclProc.error;
            }
            else if (aclProc.status !== 0) {
                throw new Error(`Setting ACL restrictions did not succeed (ICACLS returned code ${aclProc.status})`);
            }
        }
        else {
            throw new Error("Could not synchronously call ICACLS under current version of Node.js");
        }
    }
    static _getACLIdentity() {
        return new Promise((resolve, reject) => {
            if (FileAccessControl.ACL_IDENTITY) {
                resolve(FileAccessControl.ACL_IDENTITY);
            }
            const psProc = child_process__namespace.spawn(FileAccessControl.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                windowsHide: true,
                stdio: ["ignore", "pipe", "pipe"], // Needed to prevent hanging on Win 7
            });
            let data = "";
            psProc.stdout.on("data", (d) => (data += d));
            psProc.on("error", (e) => reject(e));
            psProc.on("close", (code) => {
                FileAccessControl.ACL_IDENTITY = data && data.trim();
                if (code === 0) {
                    resolve(FileAccessControl.ACL_IDENTITY);
                }
                else {
                    reject(new Error(`Getting ACL identity did not succeed (PS returned code ${code})`));
                }
            });
        });
    }
    static _getACLIdentitySync() {
        if (FileAccessControl.ACL_IDENTITY) {
            return FileAccessControl.ACL_IDENTITY;
        }
        // Some very old versions of Node (< 0.11) don't have this
        if (child_process__namespace.spawnSync) {
            const psProc = child_process__namespace.spawnSync(FileAccessControl.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
                windowsHide: true,
                stdio: ["ignore", "pipe", "pipe"], // Needed to prevent hanging on Win 7
            });
            if (psProc.error) {
                throw psProc.error;
            }
            else if (psProc.status !== 0) {
                throw new Error(`Getting ACL identity did not succeed (PS returned code ${psProc.status})`);
            }
            FileAccessControl.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();
            return FileAccessControl.ACL_IDENTITY;
        }
        else {
            throw new Error("Could not synchronously get ACL identity under current version of Node.js");
        }
    }
    static _getACLArguments(directory, identity) {
        return [
            directory,
            "/grant",
            "*S-1-5-32-544:(OI)(CI)F", // Full permission for Administrators
            "/grant",
            `${identity}:(OI)(CI)F`, // Full permission for current user
            "/inheritance:r",
        ]; // Remove all inherited permissions
    }
}
FileAccessControl.ICACLS_PATH = `${process.env.systemdrive}/windows/system32/icacls.exe`;
FileAccessControl.POWERSHELL_PATH = `${process.env.systemdrive}/windows/system32/windowspowershell/v1.0/powershell.exe`;
FileAccessControl.ACLED_DIRECTORIES = {};
FileAccessControl.ACL_IDENTITY = null;
FileAccessControl.OS_FILE_PROTECTION_CHECKED = false;
FileAccessControl.OS_PROVIDES_FILE_PROTECTION = false;
FileAccessControl.USE_ICACLS = os__namespace.type() === "Windows_NT";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const readdirAsync$1 = util.promisify(fs__namespace.readdir);
const statAsync$1 = util.promisify(fs__namespace.stat);
const lstatAsync = util.promisify(fs__namespace.lstat);
const mkdirAsync = util.promisify(fs__namespace.mkdir);
/**
 * Computes the size (in bytes) of all files in a directory at the root level. Asynchronously.
 * @internal
 */
const getShallowDirectorySize = async (directory) => {
    let totalSize = 0;
    try {
        // Get the directory listing
        const files = await readdirAsync$1(directory);
        // Query all file sizes
        for (const file of files) {
            const fileStats = await statAsync$1(path__namespace.join(directory, file));
            if (fileStats.isFile()) {
                totalSize += fileStats.size;
            }
        }
        return totalSize;
    }
    catch (err) {
        api.diag.error(`Error getting directory size: ${err}`);
        return 0;
    }
};
/**
 * Validate directory exists.
 * @internal
 */
const confirmDirExists = async (directory) => {
    try {
        const stats = await lstatAsync(directory);
        if (!stats.isDirectory()) {
            throw new Error("Path existed but was not a directory");
        }
    }
    catch (err) {
        if (err && err.code === "ENOENT") {
            try {
                const options = { recursive: true };
                await mkdirAsync(directory, options);
            }
            catch (mkdirErr) {
                if (mkdirErr && mkdirErr.code !== "EEXIST") {
                    // Handle race condition by ignoring EEXIST
                    throw mkdirErr;
                }
            }
        }
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const statAsync = util.promisify(fs__namespace.stat);
const readdirAsync = util.promisify(fs__namespace.readdir);
const readFileAsync = util.promisify(fs__namespace.readFile);
const unlinkAsync = util.promisify(fs__namespace.unlink);
const writeFileAsync = util.promisify(fs__namespace.writeFile);
/**
 * File system persist class.
 * @internal
 */
class FileSystemPersist {
    constructor(instrumentationKey, _options) {
        var _a, _b;
        this._options = _options;
        this.fileRetemptionPeriod = 2 * 24 * 60 * 60 * 1000; // 2 days
        this.cleanupTimeOut = 60 * 60 * 1000; // 1 hour
        this.maxBytesOnDisk = 50000000; // ~50MB
        this._tempDirectory = "";
        this._fileCleanupTimer = null;
        this._instrumentationKey = instrumentationKey;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.disableOfflineStorage) {
            this._enabled = false;
            return;
        }
        this._enabled = true;
        FileAccessControl.checkFileProtection();
        if (!FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {
            this._enabled = false;
            api.diag.error("Sufficient file protection capabilities were not detected. Files will not be persisted");
        }
        if (!this._instrumentationKey) {
            this._enabled = false;
            api.diag.error(`No instrumentation key was provided to FileSystemPersister. Files will not be persisted`);
        }
        if (this._enabled) {
            this._tempDirectory = path__namespace.join(((_b = this._options) === null || _b === void 0 ? void 0 : _b.storageDirectory) || os__namespace.tmpdir(), "Microsoft", "AzureMonitor", FileSystemPersist.TEMPDIR_PREFIX + this._instrumentationKey);
            // Starts file cleanup task
            if (!this._fileCleanupTimer) {
                this._fileCleanupTimer = setTimeout(() => {
                    this._fileCleanupTask();
                }, this.cleanupTimeOut);
                this._fileCleanupTimer.unref();
            }
        }
    }
    push(value) {
        var _a;
        if (this._enabled) {
            api.diag.debug("Pushing value to persistent storage", value.toString());
            return this._storeToDisk(JSON.stringify(value));
        }
        // Only return a false promise if the SDK isn't set to disable offline storage
        if (!((_a = this._options) === null || _a === void 0 ? void 0 : _a.disableOfflineStorage)) {
            return new Promise((resolve) => {
                resolve(false);
            });
        }
        return new Promise((resolve) => {
            resolve(true);
        });
    }
    async shift() {
        if (this._enabled) {
            api.diag.debug("Searching for filesystem persisted files");
            try {
                const buffer = await this._getFirstFileOnDisk();
                if (buffer) {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                    return JSON.parse(buffer.toString("utf8"));
                }
            }
            catch (e) {
                api.diag.debug("Failed to read persisted file", e);
            }
            return null;
        }
        return new Promise((resolve) => {
            resolve(null);
        });
    }
    /**
     * Check for temp telemetry files
     * reads the first file if exist, deletes it and tries to send its load
     */
    async _getFirstFileOnDisk() {
        try {
            const stats = await statAsync(this._tempDirectory);
            if (stats.isDirectory()) {
                const origFiles = await readdirAsync(this._tempDirectory);
                const files = origFiles.filter((f) => path__namespace.basename(f).includes(FileSystemPersist.FILENAME_SUFFIX));
                if (files.length === 0) {
                    return null;
                }
                else {
                    const firstFile = files[0];
                    const filePath = path__namespace.join(this._tempDirectory, firstFile);
                    const payload = await readFileAsync(filePath);
                    // delete the file first to prevent double sending
                    await unlinkAsync(filePath);
                    return payload;
                }
            }
            return null;
        }
        catch (e) {
            if (e.code === "ENOENT") {
                // File does not exist -- return null instead of throwing
                return null;
            }
            else {
                throw e;
            }
        }
    }
    async _storeToDisk(payload) {
        try {
            await confirmDirExists(this._tempDirectory);
        }
        catch (error) {
            api.diag.warn(`Error while checking/creating directory: `, error && error.message);
            return false;
        }
        try {
            const size = await getShallowDirectorySize(this._tempDirectory);
            if (size > this.maxBytesOnDisk) {
                api.diag.warn(`Not saving data due to max size limit being met. Directory size in bytes is: ${size}`);
                return false;
            }
        }
        catch (error) {
            api.diag.warn(`Error while checking size of persistence directory: `, error && error.message);
            return false;
        }
        const fileName = `${new Date().getTime()}${FileSystemPersist.FILENAME_SUFFIX}`;
        const fileFullPath = path__namespace.join(this._tempDirectory, fileName);
        // Mode 600 is w/r for creator and no read access for others
        api.diag.info(`saving data to disk at: ${fileFullPath}`);
        try {
            await writeFileAsync(fileFullPath, payload, { mode: 0o600 });
        }
        catch (writeError) {
            api.diag.warn(`Error writing file to persistent file storage`, writeError);
            return false;
        }
        return true;
    }
    async _fileCleanupTask() {
        try {
            const stats = await statAsync(this._tempDirectory);
            if (stats.isDirectory()) {
                const origFiles = await readdirAsync(this._tempDirectory);
                const files = origFiles.filter((f) => path__namespace.basename(f).includes(FileSystemPersist.FILENAME_SUFFIX));
                if (files.length === 0) {
                    return false;
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-misused-promises
                    files.forEach(async (file) => {
                        // Check expiration
                        const fileCreationDate = new Date(parseInt(file.split(FileSystemPersist.FILENAME_SUFFIX)[0]));
                        const expired = new Date(+new Date() - this.fileRetemptionPeriod) > fileCreationDate;
                        if (expired) {
                            const filePath = path__namespace.join(this._tempDirectory, file);
                            await unlinkAsync(filePath);
                        }
                    });
                    return true;
                }
            }
            return false;
        }
        catch (error) {
            api.diag.info(`Failed cleanup of persistent file storage expired files`, error);
            return false;
        }
    }
}
FileSystemPersist.TEMPDIR_PREFIX = "ot-azure-exporter-";
FileSystemPersist.FILENAME_SUFFIX = ".ai.json";

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link DataPointType} that the service accepts. */
var KnownDataPointType;
(function (KnownDataPointType) {
    /** Measurement */
    KnownDataPointType["Measurement"] = "Measurement";
    /** Aggregation */
    KnownDataPointType["Aggregation"] = "Aggregation";
})(KnownDataPointType || (KnownDataPointType = {}));
/** Known values of {@link SeverityLevel} that the service accepts. */
var KnownSeverityLevel;
(function (KnownSeverityLevel) {
    /** Verbose */
    KnownSeverityLevel["Verbose"] = "Verbose";
    /** Information */
    KnownSeverityLevel["Information"] = "Information";
    /** Warning */
    KnownSeverityLevel["Warning"] = "Warning";
    /** Error */
    KnownSeverityLevel["Error"] = "Error";
    /** Critical */
    KnownSeverityLevel["Critical"] = "Critical";
})(KnownSeverityLevel || (KnownSeverityLevel = {}));
/** Known values of {@link ContextTagKeys} that the service accepts. */
var KnownContextTagKeys;
(function (KnownContextTagKeys) {
    /** AiApplicationVer */
    KnownContextTagKeys["AiApplicationVer"] = "ai.application.ver";
    /** AiDeviceId */
    KnownContextTagKeys["AiDeviceId"] = "ai.device.id";
    /** AiDeviceLocale */
    KnownContextTagKeys["AiDeviceLocale"] = "ai.device.locale";
    /** AiDeviceModel */
    KnownContextTagKeys["AiDeviceModel"] = "ai.device.model";
    /** AiDeviceOemName */
    KnownContextTagKeys["AiDeviceOemName"] = "ai.device.oemName";
    /** AiDeviceOsVersion */
    KnownContextTagKeys["AiDeviceOsVersion"] = "ai.device.osVersion";
    /** AiDeviceType */
    KnownContextTagKeys["AiDeviceType"] = "ai.device.type";
    /** AiLocationIp */
    KnownContextTagKeys["AiLocationIp"] = "ai.location.ip";
    /** AiLocationCountry */
    KnownContextTagKeys["AiLocationCountry"] = "ai.location.country";
    /** AiLocationProvince */
    KnownContextTagKeys["AiLocationProvince"] = "ai.location.province";
    /** AiLocationCity */
    KnownContextTagKeys["AiLocationCity"] = "ai.location.city";
    /** AiOperationId */
    KnownContextTagKeys["AiOperationId"] = "ai.operation.id";
    /** AiOperationName */
    KnownContextTagKeys["AiOperationName"] = "ai.operation.name";
    /** AiOperationParentId */
    KnownContextTagKeys["AiOperationParentId"] = "ai.operation.parentId";
    /** AiOperationSyntheticSource */
    KnownContextTagKeys["AiOperationSyntheticSource"] = "ai.operation.syntheticSource";
    /** AiOperationCorrelationVector */
    KnownContextTagKeys["AiOperationCorrelationVector"] = "ai.operation.correlationVector";
    /** AiSessionId */
    KnownContextTagKeys["AiSessionId"] = "ai.session.id";
    /** AiSessionIsFirst */
    KnownContextTagKeys["AiSessionIsFirst"] = "ai.session.isFirst";
    /** AiUserAccountId */
    KnownContextTagKeys["AiUserAccountId"] = "ai.user.accountId";
    /** AiUserId */
    KnownContextTagKeys["AiUserId"] = "ai.user.id";
    /** AiUserAuthUserId */
    KnownContextTagKeys["AiUserAuthUserId"] = "ai.user.authUserId";
    /** AiCloudRole */
    KnownContextTagKeys["AiCloudRole"] = "ai.cloud.role";
    /** AiCloudRoleVer */
    KnownContextTagKeys["AiCloudRoleVer"] = "ai.cloud.roleVer";
    /** AiCloudRoleInstance */
    KnownContextTagKeys["AiCloudRoleInstance"] = "ai.cloud.roleInstance";
    /** AiCloudLocation */
    KnownContextTagKeys["AiCloudLocation"] = "ai.cloud.location";
    /** AiInternalSdkVersion */
    KnownContextTagKeys["AiInternalSdkVersion"] = "ai.internal.sdkVersion";
    /** AiInternalAgentVersion */
    KnownContextTagKeys["AiInternalAgentVersion"] = "ai.internal.agentVersion";
    /** AiInternalNodeName */
    KnownContextTagKeys["AiInternalNodeName"] = "ai.internal.nodeName";
})(KnownContextTagKeys || (KnownContextTagKeys = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String",
        },
    },
};
const body = {
    parameterPath: "body",
    mapper: {
        serializedName: "body",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Composite",
                    className: "TelemetryItem",
                },
            },
        },
    },
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String",
        },
    },
};
const host = {
    parameterPath: "host",
    mapper: {
        serializedName: "Host",
        required: true,
        type: {
            name: "String",
        },
    },
    skipEncoding: true,
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const TelemetryItem = {
    type: {
        name: "Composite",
        className: "TelemetryItem",
        modelProperties: {
            version: {
                defaultValue: 1,
                serializedName: "ver",
                type: {
                    name: "Number",
                },
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            },
            time: {
                serializedName: "time",
                required: true,
                type: {
                    name: "DateTime",
                },
            },
            sampleRate: {
                defaultValue: 100,
                serializedName: "sampleRate",
                type: {
                    name: "Number",
                },
            },
            sequence: {
                constraints: {
                    MaxLength: 64,
                },
                serializedName: "seq",
                type: {
                    name: "String",
                },
            },
            instrumentationKey: {
                serializedName: "iKey",
                type: {
                    name: "String",
                },
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } },
                },
            },
            data: {
                serializedName: "data",
                type: {
                    name: "Composite",
                    className: "MonitorBase",
                },
            },
        },
    },
};
const MonitorBase = {
    type: {
        name: "Composite",
        className: "MonitorBase",
        modelProperties: {
            baseType: {
                serializedName: "baseType",
                type: {
                    name: "String",
                },
            },
            baseData: {
                serializedName: "baseData",
                type: {
                    name: "Composite",
                    className: "MonitorDomain",
                },
            },
        },
    },
};
const MonitorDomain = {
    type: {
        name: "Composite",
        className: "MonitorDomain",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            version: {
                defaultValue: 2,
                serializedName: "ver",
                required: true,
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const TrackResponse = {
    type: {
        name: "Composite",
        className: "TrackResponse",
        modelProperties: {
            itemsReceived: {
                serializedName: "itemsReceived",
                type: {
                    name: "Number",
                },
            },
            itemsAccepted: {
                serializedName: "itemsAccepted",
                type: {
                    name: "Number",
                },
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TelemetryErrorDetails",
                        },
                    },
                },
            },
        },
    },
};
const TelemetryErrorDetails = {
    type: {
        name: "Composite",
        className: "TelemetryErrorDetails",
        modelProperties: {
            index: {
                serializedName: "index",
                type: {
                    name: "Number",
                },
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "Number",
                },
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String",
                },
            },
        },
    },
};
const MetricDataPoint = {
    type: {
        name: "Composite",
        className: "MetricDataPoint",
        modelProperties: {
            namespace: {
                constraints: {
                    MaxLength: 256,
                },
                serializedName: "ns",
                type: {
                    name: "String",
                },
            },
            name: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            },
            dataPointType: {
                serializedName: "kind",
                type: {
                    name: "String",
                },
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Number",
                },
            },
            count: {
                serializedName: "count",
                nullable: true,
                type: {
                    name: "Number",
                },
            },
            min: {
                serializedName: "min",
                nullable: true,
                type: {
                    name: "Number",
                },
            },
            max: {
                serializedName: "max",
                nullable: true,
                type: {
                    name: "Number",
                },
            },
            stdDev: {
                serializedName: "stdDev",
                nullable: true,
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const TelemetryExceptionDetails = {
    type: {
        name: "Composite",
        className: "TelemetryExceptionDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "Number",
                },
            },
            outerId: {
                serializedName: "outerId",
                type: {
                    name: "Number",
                },
            },
            typeName: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "typeName",
                type: {
                    name: "String",
                },
            },
            message: {
                constraints: {
                    MaxLength: 32768,
                },
                serializedName: "message",
                required: true,
                type: {
                    name: "String",
                },
            },
            hasFullStack: {
                defaultValue: true,
                serializedName: "hasFullStack",
                type: {
                    name: "Boolean",
                },
            },
            stack: {
                constraints: {
                    MaxLength: 32768,
                },
                serializedName: "stack",
                type: {
                    name: "String",
                },
            },
            parsedStack: {
                serializedName: "parsedStack",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StackFrame",
                        },
                    },
                },
            },
        },
    },
};
const StackFrame = {
    type: {
        name: "Composite",
        className: "StackFrame",
        modelProperties: {
            level: {
                serializedName: "level",
                required: true,
                type: {
                    name: "Number",
                },
            },
            method: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "method",
                required: true,
                type: {
                    name: "String",
                },
            },
            assembly: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "assembly",
                type: {
                    name: "String",
                },
            },
            fileName: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "fileName",
                type: {
                    name: "String",
                },
            },
            line: {
                serializedName: "line",
                type: {
                    name: "Number",
                },
            },
        },
    },
};
const AvailabilityData = {
    type: {
        name: "Composite",
        className: "AvailabilityData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512,
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            }, name: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String",
                },
            }, success: {
                serializedName: "success",
                required: true,
                type: {
                    name: "Boolean",
                },
            }, runLocation: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "runLocation",
                type: {
                    name: "String",
                },
            }, message: {
                constraints: {
                    MaxLength: 8192,
                },
                serializedName: "message",
                type: {
                    name: "String",
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } },
                },
            } }),
    },
};
const TelemetryEventData = {
    type: {
        name: "Composite",
        className: "TelemetryEventData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { name: {
                constraints: {
                    MaxLength: 512,
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } },
                },
            } }),
    },
};
const TelemetryExceptionData = {
    type: {
        name: "Composite",
        className: "TelemetryExceptionData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { exceptions: {
                serializedName: "exceptions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TelemetryExceptionDetails",
                        },
                    },
                },
            }, severityLevel: {
                serializedName: "severityLevel",
                nullable: true,
                type: {
                    name: "String",
                },
            }, problemId: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "problemId",
                type: {
                    name: "String",
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } },
                },
            } }),
    },
};
const MessageData = {
    type: {
        name: "Composite",
        className: "MessageData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { message: {
                constraints: {
                    MaxLength: 32768,
                },
                serializedName: "message",
                required: true,
                type: {
                    name: "String",
                },
            }, severityLevel: {
                serializedName: "severityLevel",
                type: {
                    name: "String",
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } },
                },
            } }),
    },
};
const MetricsData = {
    type: {
        name: "Composite",
        className: "MetricsData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { metrics: {
                serializedName: "metrics",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDataPoint",
                        },
                    },
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            } }),
    },
};
const PageViewData = {
    type: {
        name: "Composite",
        className: "PageViewData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512,
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            }, name: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            }, url: {
                constraints: {
                    MaxLength: 2048,
                },
                serializedName: "url",
                type: {
                    name: "String",
                },
            }, duration: {
                serializedName: "duration",
                type: {
                    name: "String",
                },
            }, referredUri: {
                constraints: {
                    MaxLength: 2048,
                },
                serializedName: "referredUri",
                type: {
                    name: "String",
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } },
                },
            } }),
    },
};
const PageViewPerfData = {
    type: {
        name: "Composite",
        className: "PageViewPerfData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512,
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            }, name: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            }, url: {
                constraints: {
                    MaxLength: 2048,
                },
                serializedName: "url",
                type: {
                    name: "String",
                },
            }, duration: {
                serializedName: "duration",
                type: {
                    name: "String",
                },
            }, perfTotal: {
                serializedName: "perfTotal",
                type: {
                    name: "String",
                },
            }, networkConnect: {
                serializedName: "networkConnect",
                type: {
                    name: "String",
                },
            }, sentRequest: {
                serializedName: "sentRequest",
                type: {
                    name: "String",
                },
            }, receivedResponse: {
                serializedName: "receivedResponse",
                type: {
                    name: "String",
                },
            }, domProcessing: {
                serializedName: "domProcessing",
                type: {
                    name: "String",
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } },
                },
            } }),
    },
};
const RemoteDependencyData = {
    type: {
        name: "Composite",
        className: "RemoteDependencyData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512,
                },
                serializedName: "id",
                type: {
                    name: "String",
                },
            }, name: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String",
                },
            }, resultCode: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "resultCode",
                type: {
                    name: "String",
                },
            }, data: {
                constraints: {
                    MaxLength: 8192,
                },
                serializedName: "data",
                type: {
                    name: "String",
                },
            }, type: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "type",
                type: {
                    name: "String",
                },
            }, target: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "target",
                type: {
                    name: "String",
                },
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String",
                },
            }, success: {
                defaultValue: true,
                serializedName: "success",
                type: {
                    name: "Boolean",
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } },
                },
            } }),
    },
};
const RequestData = {
    type: {
        name: "Composite",
        className: "RequestData",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: Object.assign(Object.assign({}, MonitorDomain.type.modelProperties), { id: {
                constraints: {
                    MaxLength: 512,
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String",
                },
            }, name: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "name",
                type: {
                    name: "String",
                },
            }, duration: {
                serializedName: "duration",
                required: true,
                type: {
                    name: "String",
                },
            }, success: {
                defaultValue: true,
                serializedName: "success",
                required: true,
                type: {
                    name: "Boolean",
                },
            }, responseCode: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "responseCode",
                required: true,
                type: {
                    name: "String",
                },
            }, source: {
                constraints: {
                    MaxLength: 1024,
                },
                serializedName: "source",
                type: {
                    name: "String",
                },
            }, url: {
                constraints: {
                    MaxLength: 2048,
                },
                serializedName: "url",
                type: {
                    name: "String",
                },
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" }, constraints: { MaxLength: 8192 } },
                },
            }, measurements: {
                serializedName: "measurements",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } },
                },
            } }),
    },
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AvailabilityData: AvailabilityData,
    MessageData: MessageData,
    MetricDataPoint: MetricDataPoint,
    MetricsData: MetricsData,
    MonitorBase: MonitorBase,
    MonitorDomain: MonitorDomain,
    PageViewData: PageViewData,
    PageViewPerfData: PageViewPerfData,
    RemoteDependencyData: RemoteDependencyData,
    RequestData: RequestData,
    StackFrame: StackFrame,
    TelemetryErrorDetails: TelemetryErrorDetails,
    TelemetryEventData: TelemetryEventData,
    TelemetryExceptionData: TelemetryExceptionData,
    TelemetryExceptionDetails: TelemetryExceptionDetails,
    TelemetryItem: TelemetryItem,
    TrackResponse: TrackResponse
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ApplicationInsightsClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ApplicationInsightsClient class.
     * @param options The parameter options
     */
    constructor(options) {
        var _a, _b;
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
        };
        const packageDetails = `azsdk-js-monitor-opentelemetry-exporter/1.0.0-beta.25`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix,
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{Host}/v2.1" });
        super(optionsWithDefaults);
        // Assigning values to Constant parameters
        this.host = options.host || "https://dc.services.visualstudio.com";
    }
    /**
     * This operation sends a sequence of telemetry events that will be monitored by Azure Monitor.
     * @param body The list of telemetry events to track.
     * @param options The options parameters.
     */
    track(body, options) {
        return this.sendOperationRequest({ body, options }, trackOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const trackOperationSpec = {
    path: "/track",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TrackResponse,
        },
        206: {
            bodyMapper: TrackResponse,
        },
        400: {
            bodyMapper: TrackResponse,
            isError: true,
        },
        402: {
            bodyMapper: TrackResponse,
            isError: true,
        },
        429: {
            bodyMapper: TrackResponse,
            isError: true,
        },
        500: {
            bodyMapper: TrackResponse,
            isError: true,
        },
        503: {
            bodyMapper: TrackResponse,
            isError: true,
        },
    },
    requestBody: body,
    urlParameters: [host],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer,
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
class NetworkStatsbeat {
    constructor(endpoint, host) {
        this.endpoint = endpoint;
        this.host = host;
        this.totalRequestCount = 0;
        this.totalSuccesfulRequestCount = 0;
        this.totalFailedRequestCount = [];
        this.retryCount = [];
        this.exceptionCount = [];
        this.throttleCount = [];
        this.intervalRequestExecutionTime = 0;
        this.lastIntervalRequestExecutionTime = 0;
        this.lastTime = +new Date();
        this.lastRequestCount = 0;
        this.averageRequestExecutionTime = 0;
    }
}
const STATSBEAT_LANGUAGE = "node";
const MAX_STATSBEAT_FAILURES = 3;
const StatsbeatResourceProvider = {
    appsvc: "appsvc",
    aks: "aks",
    functions: "functions",
    vm: "vm",
    unknown: "unknown",
};
var StatsbeatCounter;
(function (StatsbeatCounter) {
    StatsbeatCounter["SUCCESS_COUNT"] = "Request_Success_Count";
    StatsbeatCounter["FAILURE_COUNT"] = "Request_Failure_Count";
    StatsbeatCounter["RETRY_COUNT"] = "Retry_Count";
    StatsbeatCounter["THROTTLE_COUNT"] = "Throttle_Count";
    StatsbeatCounter["EXCEPTION_COUNT"] = "Exception_Count";
    StatsbeatCounter["AVERAGE_DURATION"] = "Request_Duration";
    StatsbeatCounter["ATTACH"] = "Attach";
    StatsbeatCounter["FEATURE"] = "Feature";
})(StatsbeatCounter || (StatsbeatCounter = {}));
const AIMS_URI = "http://169.254.169.254/metadata/instance/compute";
const AIMS_API_VERSION = "api-version=2017-12-01";
const AIMS_FORMAT = "format=json";
const NON_EU_CONNECTION_STRING = "InstrumentationKey=c4a29126-a7cb-47e5-b348-11414998b11e;IngestionEndpoint=https://westus-0.in.applicationinsights.azure.com";
const EU_CONNECTION_STRING = "InstrumentationKey=7dc56bab-3c0c-4e9f-9ebb-d1acadee8d0f;IngestionEndpoint=https://westeurope-5.in.applicationinsights.azure.com";
const EU_ENDPOINTS = [
    "westeurope",
    "northeurope",
    "francecentral",
    "francesouth",
    "germanywestcentral",
    "norwayeast",
    "norwaywest",
    "swedencentral",
    "switzerlandnorth",
    "switzerlandwest",
    "uksouth",
    "ukwest",
];
var StatsbeatFeatureType;
(function (StatsbeatFeatureType) {
    StatsbeatFeatureType[StatsbeatFeatureType["FEATURE"] = 0] = "FEATURE";
    StatsbeatFeatureType[StatsbeatFeatureType["INSTRUMENTATION"] = 1] = "INSTRUMENTATION";
})(StatsbeatFeatureType || (StatsbeatFeatureType = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// eslint-disable-next-line @typescript-eslint/no-require-imports
const os = require("os");
class StatsbeatMetrics {
    constructor() {
        this.resourceProvider = StatsbeatResourceProvider.unknown;
        this.vmInfo = {};
        this.os = os.type();
        this.resourceIdentifier = "";
    }
    async getResourceProvider() {
        // Check resource provider
        this.resourceProvider = StatsbeatResourceProvider.unknown;
        if (process.env.AKS_ARM_NAMESPACE_ID) {
            // AKS
            this.resourceProvider = StatsbeatResourceProvider.aks;
            this.resourceIdentifier = process.env.AKS_ARM_NAMESPACE_ID;
        }
        else if (process.env.WEBSITE_SITE_NAME) {
            // Web apps
            this.resourceProvider = StatsbeatResourceProvider.appsvc;
            this.resourceIdentifier = process.env.WEBSITE_SITE_NAME;
            if (process.env.WEBSITE_HOME_STAMPNAME) {
                this.resourceIdentifier += "/" + process.env.WEBSITE_HOME_STAMPNAME;
            }
        }
        else if (process.env.FUNCTIONS_WORKER_RUNTIME) {
            // Function apps
            this.resourceProvider = StatsbeatResourceProvider.functions;
            if (process.env.WEBSITE_HOSTNAME) {
                this.resourceIdentifier = process.env.WEBSITE_HOSTNAME;
            }
        }
        else if (await this.getAzureComputeMetadata()) {
            this.resourceProvider = StatsbeatResourceProvider.vm;
            this.resourceIdentifier = this.vmInfo.id + "/" + this.vmInfo.subscriptionId;
            // Overrride OS as VM info have higher precedence
            if (this.vmInfo.osType) {
                this.os = this.vmInfo.osType;
            }
        }
        else {
            this.resourceProvider = StatsbeatResourceProvider.unknown;
        }
    }
    async getAzureComputeMetadata() {
        const httpClient = coreRestPipeline.createDefaultHttpClient();
        const method = "GET";
        const options = {
            url: `${AIMS_URI}?${AIMS_API_VERSION}&${AIMS_FORMAT}`,
            timeout: 5000, // 5 seconds
            method: method,
            allowInsecureConnection: true,
        };
        const request = coreRestPipeline.createPipelineRequest(options);
        await httpClient
            .sendRequest(request)
            .then((res) => {
            if (res.status === 200) {
                // Success; VM
                this.vmInfo.isVM = true;
                let virtualMachineData = "";
                res.on("data", (data) => {
                    virtualMachineData += data;
                });
                res.on("end", () => {
                    try {
                        const data = JSON.parse(virtualMachineData);
                        this.vmInfo.id = data["vmId"] || "";
                        this.vmInfo.subscriptionId = data["subscriptionId"] || "";
                        this.vmInfo.osType = data["osType"] || "";
                    }
                    catch (error) {
                        api.diag.debug("Failed to parse JSON: ", error);
                    }
                });
                return true;
            }
            else {
                return false;
            }
        })
            .catch(() => {
            return false;
        });
        return false;
    }
    getConnectionString(endpointUrl) {
        const currentEndpoint = endpointUrl;
        for (let i = 0; i < EU_ENDPOINTS.length; i++) {
            if (currentEndpoint.includes(EU_ENDPOINTS[i])) {
                return EU_CONNECTION_STRING;
            }
        }
        return NON_EU_CONNECTION_STRING;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Performance Counter OpenTelemetry compliant names.
 * @internal
 */
var OTelPerformanceCounterNames;
(function (OTelPerformanceCounterNames) {
    OTelPerformanceCounterNames["PRIVATE_BYTES"] = "Private_Bytes";
    OTelPerformanceCounterNames["AVAILABLE_BYTES"] = "Available_Bytes";
    OTelPerformanceCounterNames["PROCESSOR_TIME"] = "Processor_Time";
    OTelPerformanceCounterNames["PROCESS_TIME"] = "Process_Time";
    OTelPerformanceCounterNames["REQUEST_RATE"] = "Request_Rate";
    OTelPerformanceCounterNames["REQUEST_DURATION"] = "Request_Execution_Time";
})(OTelPerformanceCounterNames || (OTelPerformanceCounterNames = {}));
/**
 * Breeze Performance Counter names.
 * @internal
 */
var BreezePerformanceCounterNames;
(function (BreezePerformanceCounterNames) {
    BreezePerformanceCounterNames["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
    BreezePerformanceCounterNames["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
    BreezePerformanceCounterNames["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
    BreezePerformanceCounterNames["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
    BreezePerformanceCounterNames["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
    BreezePerformanceCounterNames["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
})(BreezePerformanceCounterNames || (BreezePerformanceCounterNames = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const breezePerformanceCountersMap = new Map([
    [OTelPerformanceCounterNames.PRIVATE_BYTES, BreezePerformanceCounterNames.PRIVATE_BYTES],
    [OTelPerformanceCounterNames.AVAILABLE_BYTES, BreezePerformanceCounterNames.AVAILABLE_BYTES],
    [OTelPerformanceCounterNames.PROCESSOR_TIME, BreezePerformanceCounterNames.PROCESSOR_TIME],
    [OTelPerformanceCounterNames.PROCESS_TIME, BreezePerformanceCounterNames.PROCESS_TIME],
    [OTelPerformanceCounterNames.REQUEST_RATE, BreezePerformanceCounterNames.REQUEST_RATE],
    [OTelPerformanceCounterNames.REQUEST_DURATION, BreezePerformanceCounterNames.REQUEST_DURATION],
]);
function createPropertiesFromMetricAttributes(attributes) {
    const properties = {};
    if (attributes) {
        for (const key of Object.keys(attributes)) {
            properties[key] = attributes[key];
        }
    }
    return properties;
}
/**
 * Metric to Azure envelope parsing.
 * @internal
 */
function resourceMetricsToEnvelope(metrics, ikey, isStatsbeat) {
    const envelopes = [];
    const time = new Date();
    const instrumentationKey = ikey;
    const tags = createTagsFromResource(metrics.resource);
    let envelopeName;
    if (isStatsbeat) {
        envelopeName = "Microsoft.ApplicationInsights.Statsbeat";
    }
    else {
        envelopeName = "Microsoft.ApplicationInsights.Metric";
    }
    metrics.scopeMetrics.forEach((scopeMetric) => {
        scopeMetric.metrics.forEach((metric) => {
            metric.dataPoints.forEach((dataPoint) => {
                const baseData = {
                    metrics: [],
                    version: 2,
                    properties: {},
                };
                baseData.properties = createPropertiesFromMetricAttributes(dataPoint.attributes);
                let perfCounterName;
                if (breezePerformanceCountersMap.has(metric.descriptor.name)) {
                    perfCounterName = breezePerformanceCountersMap.get(metric.descriptor.name);
                }
                const metricDataPoint = {
                    name: perfCounterName ? perfCounterName : metric.descriptor.name,
                    value: 0,
                    dataPointType: "Aggregation",
                };
                if (metric.dataPointType === sdkMetrics.DataPointType.SUM ||
                    metric.dataPointType === sdkMetrics.DataPointType.GAUGE) {
                    metricDataPoint.value = dataPoint.value;
                    metricDataPoint.count = 1;
                }
                else {
                    metricDataPoint.value = dataPoint.value.sum || 0;
                    metricDataPoint.count = dataPoint.value.count;
                    metricDataPoint.max = dataPoint.value.max;
                    metricDataPoint.min = dataPoint.value.min;
                }
                baseData.metrics.push(metricDataPoint);
                const envelope = {
                    name: envelopeName,
                    time: time,
                    sampleRate: 100, // Metrics are never sampled
                    instrumentationKey: instrumentationKey,
                    tags: tags,
                    version: 1,
                    data: {
                        baseType: "MetricData",
                        baseData: Object.assign({}, baseData),
                    },
                };
                envelopes.push(envelope);
            });
        });
    });
    return envelopes;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure Monitor Statsbeat Exporter
 */
class AzureMonitorStatsbeatExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorStatsbeatExporter class.
     * @param options - Exporter configuration
     */
    constructor(options) {
        super(options, true);
        /**
         * Flag to determine if the Exporter is shutdown.
         */
        this._isShutdown = false;
        this._sender = new HttpSender({
            endpointUrl: this.endpointUrl,
            instrumentationKey: this.instrumentationKey,
            trackStatsbeat: this.trackStatsbeat,
            exporterOptions: options,
            isStatsbeatSender: true,
        });
    }
    /**
     * Export Statsbeat metrics.
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async export(metrics, resultCallback) {
        if (this._isShutdown) {
            setTimeout(() => resultCallback({ code: core.ExportResultCode.FAILED }), 0);
            return;
        }
        const envelopes = resourceMetricsToEnvelope(metrics, this.instrumentationKey, true);
        // Supress tracing until OpenTelemetry Metrics SDK support it
        api.context.with(core.suppressTracing(api.context.active()), async () => {
            resultCallback(await this._sender.exportEnvelopes(envelopes));
        });
    }
    /**
     * Shutdown AzureMonitorStatsbeatExporter.
     */
    async shutdown() {
        this._isShutdown = true;
        return this._sender.shutdown();
    }
    /**
     * Force flush.
     */
    async forceFlush() {
        return Promise.resolve();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
class NetworkStatsbeatMetrics extends StatsbeatMetrics {
    constructor(options) {
        super();
        this.isInitialized = false;
        this.statsCollectionShortInterval = 900000; // 15 minutes
        this.networkStatsbeatCollection = [];
        this.attach = "Manual";
        this.connectionString = super.getConnectionString(options.endpointUrl);
        this.networkStatsbeatMeterProvider = new sdkMetrics.MeterProvider();
        const exporterConfig = {
            connectionString: this.connectionString,
        };
        this.networkAzureExporter = new AzureMonitorStatsbeatExporter(exporterConfig);
        // Exports Network Statsbeat every 15 minutes
        const networkMetricReaderOptions = {
            exporter: this.networkAzureExporter,
            exportIntervalMillis: options.networkCollectionInterval || this.statsCollectionShortInterval, // 15 minutes
        };
        this.networkMetricReader = new sdkMetrics.PeriodicExportingMetricReader(networkMetricReaderOptions);
        this.networkStatsbeatMeterProvider.addMetricReader(this.networkMetricReader);
        this.networkStatsbeatMeter = this.networkStatsbeatMeterProvider.getMeter("Azure Monitor Network Statsbeat");
        this.endpointUrl = options.endpointUrl;
        this.runtimeVersion = process.version;
        this.language = STATSBEAT_LANGUAGE;
        this.version = packageVersion;
        this.host = this.getShortHost(options.endpointUrl);
        this.cikey = options.instrumentationKey;
        this.successCountGauge = this.networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.SUCCESS_COUNT);
        this.failureCountGauge = this.networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.FAILURE_COUNT);
        this.retryCountGauge = this.networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.RETRY_COUNT);
        this.throttleCountGauge = this.networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.THROTTLE_COUNT);
        this.exceptionCountGauge = this.networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.EXCEPTION_COUNT);
        this.averageDurationGauge = this.networkStatsbeatMeter.createObservableGauge(StatsbeatCounter.AVERAGE_DURATION);
        this.commonProperties = {
            os: this.os,
            rp: this.resourceProvider,
            cikey: this.cikey,
            runtimeVersion: this.runtimeVersion,
            language: this.language,
            version: this.version,
            attach: this.attach,
        };
        this.networkProperties = {
            endpoint: this.endpointUrl,
            host: this.host,
        };
        this.isInitialized = true;
        this.initialize();
    }
    shutdown() {
        return this.networkStatsbeatMeterProvider.shutdown();
    }
    async initialize() {
        try {
            await super.getResourceProvider();
            // Add network observable callbacks
            this.successCountGauge.addCallback(this.successCallback.bind(this));
            this.networkStatsbeatMeter.addBatchObservableCallback(this.failureCallback.bind(this), [
                this.failureCountGauge,
            ]);
            this.networkStatsbeatMeter.addBatchObservableCallback(this.retryCallback.bind(this), [
                this.retryCountGauge,
            ]);
            this.networkStatsbeatMeter.addBatchObservableCallback(this.throttleCallback.bind(this), [
                this.throttleCountGauge,
            ]);
            this.networkStatsbeatMeter.addBatchObservableCallback(this.exceptionCallback.bind(this), [
                this.exceptionCountGauge,
            ]);
            this.averageDurationGauge.addCallback(this.durationCallback.bind(this));
        }
        catch (error) {
            api.diag.debug("Call to get the resource provider failed.");
        }
    }
    // Observable gauge callbacks
    successCallback(observableResult) {
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const attributes = Object.assign(Object.assign({}, this.commonProperties), this.networkProperties);
        observableResult.observe(counter.totalSuccesfulRequestCount, attributes);
        counter.totalSuccesfulRequestCount = 0;
    }
    failureCallback(observableResult) {
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        /*
          Takes the failureCountGauge, value (of the counter), and attributes
          create a unqiue counter based on statusCode as well
          append statusCode to attributes so the newly created attributes are unique.
        */
        const attributes = Object.assign(Object.assign(Object.assign({}, this.networkProperties), this.commonProperties), { statusCode: 0 });
        // For each { statusCode -> count } mapping, call observe, passing the count and attributes that include the statusCode
        for (let i = 0; i < counter.totalFailedRequestCount.length; i++) {
            attributes.statusCode = counter.totalFailedRequestCount[i].statusCode;
            observableResult.observe(this.failureCountGauge, counter.totalFailedRequestCount[i].count, Object.assign({}, attributes));
            counter.totalFailedRequestCount[i].count = 0;
        }
    }
    retryCallback(observableResult) {
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const attributes = Object.assign(Object.assign(Object.assign({}, this.networkProperties), this.commonProperties), { statusCode: 0 });
        for (let i = 0; i < counter.retryCount.length; i++) {
            attributes.statusCode = counter.retryCount[i].statusCode;
            observableResult.observe(this.retryCountGauge, counter.retryCount[i].count, Object.assign({}, attributes));
            counter.retryCount[i].count = 0;
        }
    }
    throttleCallback(observableResult) {
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const attributes = Object.assign(Object.assign(Object.assign({}, this.networkProperties), this.commonProperties), { statusCode: 0 });
        for (let i = 0; i < counter.throttleCount.length; i++) {
            attributes.statusCode = counter.throttleCount[i].statusCode;
            observableResult.observe(this.throttleCountGauge, counter.throttleCount[i].count, Object.assign({}, attributes));
            counter.throttleCount[i].count = 0;
        }
    }
    exceptionCallback(observableResult) {
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const attributes = Object.assign(Object.assign(Object.assign({}, this.networkProperties), this.commonProperties), { exceptionType: "" });
        for (let i = 0; i < counter.exceptionCount.length; i++) {
            attributes.exceptionType = counter.exceptionCount[i].exceptionType;
            observableResult.observe(this.exceptionCountGauge, counter.exceptionCount[i].count, Object.assign({}, attributes));
            counter.exceptionCount[i].count = 0;
        }
    }
    durationCallback(observableResult) {
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const attributes = Object.assign(Object.assign({}, this.networkProperties), this.commonProperties);
        for (let i = 0; i < this.networkStatsbeatCollection.length; i++) {
            const currentCounter = this.networkStatsbeatCollection[i];
            currentCounter.time = Number(new Date());
            const intervalRequests = currentCounter.totalRequestCount - currentCounter.lastRequestCount || 0;
            currentCounter.averageRequestExecutionTime =
                (currentCounter.intervalRequestExecutionTime -
                    currentCounter.lastIntervalRequestExecutionTime) /
                    intervalRequests || 0;
            currentCounter.lastIntervalRequestExecutionTime = currentCounter.intervalRequestExecutionTime; // reset
            currentCounter.lastRequestCount = currentCounter.totalRequestCount;
            currentCounter.lastTime = currentCounter.time;
        }
        observableResult.observe(counter.averageRequestExecutionTime, attributes);
        counter.averageRequestExecutionTime = 0;
    }
    // Public methods to increase counters
    countSuccess(duration) {
        if (!this.isInitialized) {
            return;
        }
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        counter.totalRequestCount++;
        counter.totalSuccesfulRequestCount++;
        counter.intervalRequestExecutionTime += duration;
    }
    countFailure(duration, statusCode) {
        if (!this.isInitialized) {
            return;
        }
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const currentStatusCounter = counter.totalFailedRequestCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.totalFailedRequestCount.push({ statusCode: statusCode, count: 1 });
        }
        counter.totalRequestCount++;
        counter.intervalRequestExecutionTime += duration;
    }
    countRetry(statusCode) {
        if (!this.isInitialized) {
            return;
        }
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const currentStatusCounter = counter.retryCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.retryCount.push({ statusCode: statusCode, count: 1 });
        }
    }
    countThrottle(statusCode) {
        if (!this.isInitialized) {
            return;
        }
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const currentStatusCounter = counter.throttleCount.find((statusCounter) => statusCode === statusCounter.statusCode);
        if (currentStatusCounter) {
            currentStatusCounter.count++;
        }
        else {
            counter.throttleCount.push({ statusCode: statusCode, count: 1 });
        }
    }
    countException(exceptionType) {
        if (!this.isInitialized) {
            return;
        }
        const counter = this.getNetworkStatsbeatCounter(this.endpointUrl, this.host);
        const currentErrorCounter = counter.exceptionCount.find((exceptionCounter) => exceptionType.name === exceptionCounter.exceptionType);
        if (currentErrorCounter) {
            currentErrorCounter.count++;
        }
        else {
            counter.exceptionCount.push({ exceptionType: exceptionType.name, count: 1 });
        }
    }
    // Gets a networkStatsbeat counter if one exists for the given endpoint
    getNetworkStatsbeatCounter(endpoint, host) {
        // Check if the counter is available
        for (let i = 0; i < this.networkStatsbeatCollection.length; i++) {
            // Same object
            if (endpoint === this.networkStatsbeatCollection[i].endpoint &&
                host === this.networkStatsbeatCollection[i].host) {
                return this.networkStatsbeatCollection[i];
            }
        }
        // Create a new counter if not found
        const newCounter = new NetworkStatsbeat(endpoint, host);
        this.networkStatsbeatCollection.push(newCounter);
        return newCounter;
    }
    getShortHost(originalHost) {
        let shortHost = originalHost;
        try {
            const hostRegex = new RegExp(/^https?:\/\/(?:www\.)?([^/.-]+)/);
            const res = hostRegex.exec(originalHost);
            if (res !== null && res.length > 1) {
                shortHost = res[1];
            }
            shortHost = shortHost.replace(".in.applicationinsights.azure.com", "");
        }
        catch (error) {
            api.diag.debug("Failed to get the short host name.");
        }
        return shortHost;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
let instance$1 = null;
/**
 * Long Interval Statsbeat Metrics
 * @internal
 */
class LongIntervalStatsbeatMetrics extends StatsbeatMetrics {
    constructor(options) {
        super();
        this.statsCollectionLongInterval = 86400000; // 1 day
        this.attach = "Manual";
        this.feature = 0;
        this.instrumentation = 0;
        this.isInitialized = false;
        this.connectionString = super.getConnectionString(options.endpointUrl);
        const exporterConfig = {
            connectionString: this.connectionString,
            disableOfflineStorage: options.disableOfflineStorage,
        };
        this.setFeatures();
        this.longIntervalStatsbeatMeterProvider = new sdkMetrics.MeterProvider();
        this.longIntervalAzureExporter = new AzureMonitorStatsbeatExporter(exporterConfig);
        // Export Long Interval Statsbeats every day
        const longIntervalMetricReaderOptions = {
            exporter: this.longIntervalAzureExporter,
            exportIntervalMillis: Number(process.env.LONG_INTERVAL_EXPORT_MILLIS) || this.statsCollectionLongInterval, // 1 day
        };
        this.longIntervalMetricReader = new sdkMetrics.PeriodicExportingMetricReader(longIntervalMetricReaderOptions);
        this.longIntervalStatsbeatMeterProvider.addMetricReader(this.longIntervalMetricReader);
        this.longIntervalStatsbeatMeter = this.longIntervalStatsbeatMeterProvider.getMeter("Azure Monitor Long Interval Statsbeat");
        // Assign Common Properties
        this.runtimeVersion = process.version;
        this.language = STATSBEAT_LANGUAGE;
        this.version = packageVersion;
        this.cikey = options.instrumentationKey;
        this.featureStatsbeatGauge = this.longIntervalStatsbeatMeter.createObservableGauge(StatsbeatCounter.FEATURE);
        this.attachStatsbeatGauge = this.longIntervalStatsbeatMeter.createObservableGauge(StatsbeatCounter.ATTACH);
        this.commonProperties = {
            os: this.os,
            rp: this.resourceProvider,
            cikey: this.cikey,
            runtimeVersion: this.runtimeVersion,
            language: this.language,
            version: this.version,
            attach: this.attach,
        };
        this.attachProperties = {
            rpId: this.resourceIdentifier,
        };
        this.isInitialized = true;
        this.initialize();
    }
    async initialize() {
        try {
            await this.getResourceProvider();
            // Add long interval observable callbacks
            this.attachStatsbeatGauge.addCallback(this.attachCallback.bind(this));
            this.longIntervalStatsbeatMeter.addBatchObservableCallback(this.getEnvironmentStatus.bind(this), [this.featureStatsbeatGauge]);
            // Export Feature/Attach Statsbeat once upon app initialization
            this.longIntervalAzureExporter.export((await this.longIntervalMetricReader.collect()).resourceMetrics, (result) => {
                if (result.code !== core.ExportResultCode.SUCCESS) {
                    api.diag.error(`LongIntervalStatsbeat: metrics export failed (error ${result.error})`);
                }
            });
        }
        catch (error) {
            api.diag.debug("Call to get the resource provider failed.");
        }
    }
    getEnvironmentStatus(observableResult) {
        this.setFeatures();
        let attributes;
        if (this.instrumentation) {
            attributes = Object.assign(Object.assign({}, this.commonProperties), { feature: this.instrumentation, type: StatsbeatFeatureType.INSTRUMENTATION });
            observableResult.observe(this.featureStatsbeatGauge, 1, Object.assign({}, attributes));
        }
        if (this.feature) {
            attributes = Object.assign(Object.assign({}, this.commonProperties), { feature: this.feature, type: StatsbeatFeatureType.FEATURE });
            observableResult.observe(this.featureStatsbeatGauge, 1, Object.assign({}, attributes));
        }
    }
    setFeatures() {
        const statsbeatFeatures = process.env.AZURE_MONITOR_STATSBEAT_FEATURES;
        if (statsbeatFeatures) {
            try {
                this.feature = JSON.parse(statsbeatFeatures).feature;
                this.instrumentation = JSON.parse(statsbeatFeatures).instrumentation;
            }
            catch (error) {
                api.diag.error(`LongIntervalStatsbeat: Failed to parse features/instrumentations (error ${error})`);
            }
        }
    }
    attachCallback(observableResult) {
        const attributes = Object.assign(Object.assign({}, this.commonProperties), this.attachProperties);
        observableResult.observe(1, attributes);
    }
    shutdown() {
        return this.longIntervalStatsbeatMeterProvider.shutdown();
    }
}
/**
 * Singleton LongIntervalStatsbeatMetrics instance.
 * @internal
 */
function getInstance$1(options) {
    if (!instance$1) {
        instance$1 = new LongIntervalStatsbeatMetrics(options);
    }
    return instance$1;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Breeze retriable status codes.
 * @internal
 */
function isRetriable(statusCode) {
    return (statusCode === 206 || // Partial Accept
        statusCode === 401 || // Unauthorized
        statusCode === 403 || // Forbidden
        statusCode === 408 || // Timeout
        statusCode === 429 || // Too many requests
        statusCode === 439 || // Daily quota exceeded (legacy)
        statusCode === 500 || // Server Error
        statusCode === 502 || // Bad Gateway
        statusCode === 503 || // Server Unavailable
        statusCode === 504 // Gateway Timeout
    );
}
//  Convert ms to c# time span format DD.HH:MM:SS.MMMMMM
function msToTimeSpan(totalms) {
    if (isNaN(totalms) || totalms < 0) {
        totalms = 0;
    }
    let sec = ((totalms / 1000) % 60).toFixed(7).replace(/0{0,4}$/, "");
    let min = "" + (Math.floor(totalms / (1000 * 60)) % 60);
    let hour = "" + (Math.floor(totalms / (1000 * 60 * 60)) % 24);
    const days = Math.floor(totalms / (1000 * 60 * 60 * 24));
    sec = sec.indexOf(".") < 2 ? "0" + sec : sec;
    min = min.length < 2 ? "0" + min : min;
    hour = hour.length < 2 ? "0" + hour : hour;
    const daysText = days > 0 ? days + "." : "";
    return daysText + hour + ":" + min + ":" + sec;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const DEFAULT_BATCH_SEND_RETRY_INTERVAL_MS = 60000;
/**
 * Base sender class
 * @internal
 */
class BaseSender {
    constructor(options) {
        this.statsbeatFailureCount = 0;
        this.batchSendRetryIntervalMs = DEFAULT_BATCH_SEND_RETRY_INTERVAL_MS;
        this.numConsecutiveRedirects = 0;
        this.disableOfflineStorage = options.exporterOptions.disableOfflineStorage || false;
        this.persister = new FileSystemPersist(options.instrumentationKey, options.exporterOptions);
        if (options.trackStatsbeat) {
            // Initialize statsbeatMetrics
            this.networkStatsbeatMetrics = new NetworkStatsbeatMetrics({
                instrumentationKey: options.instrumentationKey,
                endpointUrl: options.endpointUrl,
                disableOfflineStorage: this.disableOfflineStorage,
            });
            this.longIntervalStatsbeatMetrics = getInstance$1({
                instrumentationKey: options.instrumentationKey,
                endpointUrl: options.endpointUrl,
                disableOfflineStorage: this.disableOfflineStorage,
            });
        }
        this.retryTimer = null;
        this.isStatsbeatSender = options.isStatsbeatSender || false;
    }
    /**
     * Export envelopes
     */
    async exportEnvelopes(envelopes) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        api.diag.info(`Exporting ${envelopes.length} envelope(s)`);
        if (envelopes.length < 1) {
            return { code: core.ExportResultCode.SUCCESS };
        }
        try {
            const startTime = new Date().getTime();
            const { result, statusCode } = await this.send(envelopes);
            const endTime = new Date().getTime();
            const duration = endTime - startTime;
            this.numConsecutiveRedirects = 0;
            if (statusCode === 200) {
                // Success -- @todo: start retry timer
                if (!this.retryTimer) {
                    this.retryTimer = setTimeout(() => {
                        this.retryTimer = null;
                        this.sendFirstPersistedFile();
                    }, this.batchSendRetryIntervalMs);
                    this.retryTimer.unref();
                }
                // If we are not exportings statsbeat and statsbeat is not disabled -- count success
                (_a = this.networkStatsbeatMetrics) === null || _a === void 0 ? void 0 : _a.countSuccess(duration);
                return { code: core.ExportResultCode.SUCCESS };
            }
            else if (statusCode && isRetriable(statusCode)) {
                // Failed -- persist failed data
                if (statusCode === 429 || statusCode === 439) {
                    (_b = this.networkStatsbeatMetrics) === null || _b === void 0 ? void 0 : _b.countThrottle(statusCode);
                }
                if (result) {
                    api.diag.info(result);
                    const breezeResponse = JSON.parse(result);
                    const filteredEnvelopes = [];
                    if (breezeResponse.errors) {
                        breezeResponse.errors.forEach((error) => {
                            if (error.statusCode && isRetriable(error.statusCode)) {
                                filteredEnvelopes.push(envelopes[error.index]);
                            }
                        });
                    }
                    if (filteredEnvelopes.length > 0) {
                        (_c = this.networkStatsbeatMetrics) === null || _c === void 0 ? void 0 : _c.countRetry(statusCode);
                        // calls resultCallback(ExportResult) based on result of persister.push
                        return await this.persist(filteredEnvelopes);
                    }
                    // Failed -- not retriable
                    (_d = this.networkStatsbeatMetrics) === null || _d === void 0 ? void 0 : _d.countFailure(duration, statusCode);
                    return {
                        code: core.ExportResultCode.FAILED,
                    };
                }
                else {
                    // calls resultCallback(ExportResult) based on result of persister.push
                    (_e = this.networkStatsbeatMetrics) === null || _e === void 0 ? void 0 : _e.countRetry(statusCode);
                    return await this.persist(envelopes);
                }
            }
            else {
                // Failed -- not retriable
                if (this.networkStatsbeatMetrics) {
                    if (statusCode) {
                        this.networkStatsbeatMetrics.countFailure(duration, statusCode);
                    }
                }
                else {
                    this.incrementStatsbeatFailure();
                }
                return {
                    code: core.ExportResultCode.FAILED,
                };
            }
        }
        catch (error) {
            const restError = error;
            if (restError.statusCode &&
                (restError.statusCode === 307 || // Temporary redirect
                    restError.statusCode === 308)) {
                // Permanent redirect
                this.numConsecutiveRedirects++;
                // To prevent circular redirects
                if (this.numConsecutiveRedirects < 10) {
                    if (restError.response && restError.response.headers) {
                        const location = restError.response.headers.get("location");
                        if (location) {
                            // Update sender URL
                            this.handlePermanentRedirect(location);
                            // Send to redirect endpoint as HTTPs library doesn't handle redirect automatically
                            return this.exportEnvelopes(envelopes);
                        }
                    }
                }
                else {
                    const redirectError = new Error("Circular redirect");
                    (_f = this.networkStatsbeatMetrics) === null || _f === void 0 ? void 0 : _f.countException(redirectError);
                    return { code: core.ExportResultCode.FAILED, error: redirectError };
                }
            }
            else if (restError.statusCode && isRetriable(restError.statusCode)) {
                (_g = this.networkStatsbeatMetrics) === null || _g === void 0 ? void 0 : _g.countRetry(restError.statusCode);
                return this.persist(envelopes);
            }
            else if (restError.statusCode === 400 &&
                restError.message.includes("Invalid instrumentation key")) {
                const invalidInstrumentationKeyError = new Error("Invalid instrumentation key");
                this.shutdownStatsbeat();
                return { code: core.ExportResultCode.FAILED, error: invalidInstrumentationKeyError };
            }
            if (this.isNetworkError(restError)) {
                if (restError.statusCode) {
                    (_h = this.networkStatsbeatMetrics) === null || _h === void 0 ? void 0 : _h.countRetry(restError.statusCode);
                }
                if (!this.isStatsbeatSender) {
                    api.diag.error("Retrying due to transient client side error. Error message:", restError.message);
                }
                return this.persist(envelopes);
            }
            (_j = this.networkStatsbeatMetrics) === null || _j === void 0 ? void 0 : _j.countException(restError);
            if (!this.isStatsbeatSender) {
                api.diag.error("Envelopes could not be exported and are not retriable. Error message:", restError.message);
            }
            return { code: core.ExportResultCode.FAILED, error: restError };
        }
    }
    /**
     * Persist envelopes to disk
     */
    async persist(envelopes) {
        try {
            const success = await this.persister.push(envelopes);
            return success
                ? { code: core.ExportResultCode.SUCCESS }
                : {
                    code: core.ExportResultCode.FAILED,
                    error: new Error("Failed to persist envelope in disk."),
                };
        }
        catch (ex) {
            return { code: core.ExportResultCode.FAILED, error: ex };
        }
    }
    /**
     * Disable collection of statsbeat metrics after max failures
     */
    incrementStatsbeatFailure() {
        this.statsbeatFailureCount++;
        if (this.statsbeatFailureCount > MAX_STATSBEAT_FAILURES) {
            this.shutdownStatsbeat();
        }
    }
    /**
     * Shutdown statsbeat metrics
     */
    shutdownStatsbeat() {
        var _a, _b;
        (_a = this.networkStatsbeatMetrics) === null || _a === void 0 ? void 0 : _a.shutdown();
        (_b = this.longIntervalStatsbeatMetrics) === null || _b === void 0 ? void 0 : _b.shutdown();
        this.networkStatsbeatMetrics = undefined;
        this.statsbeatFailureCount = 0;
    }
    async sendFirstPersistedFile() {
        try {
            const envelopes = (await this.persister.shift());
            if (envelopes) {
                await this.send(envelopes);
            }
        }
        catch (err) {
            api.diag.warn(`Failed to fetch persisted file`, err);
        }
    }
    isNetworkError(error) {
        if (error && error.code && error.code === "REQUEST_SEND_ERROR") {
            return true;
        }
        return false;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const applicationInsightsResource = "https://monitor.azure.com//.default";
/**
 * Exporter HTTP sender class
 * @internal
 */
class HttpSender extends BaseSender {
    constructor(options) {
        super(options);
        // Build endpoint using provided configuration or default values
        this.appInsightsClientOptions = Object.assign({ host: options.endpointUrl }, options.exporterOptions);
        if (this.appInsightsClientOptions.credential) {
            // Add credentialScopes
            if (options.aadAudience) {
                this.appInsightsClientOptions.credentialScopes = [options.aadAudience];
            }
            else {
                // Default
                this.appInsightsClientOptions.credentialScopes = [applicationInsightsResource];
            }
        }
        this.appInsightsClient = new ApplicationInsightsClient(this.appInsightsClientOptions);
        // Handle redirects in HTTP Sender
        this.appInsightsClient.pipeline.removePolicy({ name: coreRestPipeline.redirectPolicyName });
    }
    /**
     * Send Azure envelopes
     * @internal
     */
    async send(envelopes) {
        var _a;
        const options = {};
        let response;
        function onResponse(rawResponse, flatResponse) {
            response = rawResponse;
            if (options.onResponse) {
                options.onResponse(rawResponse, flatResponse);
            }
        }
        await this.appInsightsClient.track(envelopes, Object.assign(Object.assign({}, options), { onResponse }));
        return { statusCode: response === null || response === void 0 ? void 0 : response.status, result: (_a = response === null || response === void 0 ? void 0 : response.bodyAsText) !== null && _a !== void 0 ? _a : "" };
    }
    /**
     * Shutdown sender
     * @internal
     */
    // eslint-disable-next-line @typescript-eslint/require-await
    async shutdown() {
        api.diag.info("HttpSender shutting down");
    }
    handlePermanentRedirect(location) {
        if (location) {
            const locUrl = new url.URL(location);
            if (locUrl && locUrl.host) {
                this.appInsightsClient.host = "https://" + locUrl.host;
            }
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
let instance = null;
/**
 * Azure Telemetry context.
 * @internal
 */
class Context {
    constructor() {
        this.tags = {};
        this._loadDeviceContext();
        this._loadInternalContext();
    }
    _loadDeviceContext() {
        this.tags[KnownContextTagKeys.AiDeviceOsVersion] = os__namespace && `${os__namespace.type()} ${os__namespace.release()}`;
    }
    _loadInternalContext() {
        const { node } = process.versions;
        [Context.nodeVersion] = node.split(".");
        Context.opentelemetryVersion = core.SDK_INFO[semanticConventions.SemanticResourceAttributes.TELEMETRY_SDK_VERSION];
        Context.sdkVersion = packageVersion;
        const prefix = process.env["AZURE_MONITOR_PREFIX"] ? process.env["AZURE_MONITOR_PREFIX"] : "";
        const version = process.env["AZURE_MONITOR_DISTRO_VERSION"]
            ? `ext${process.env["AZURE_MONITOR_DISTRO_VERSION"]}`
            : `ext${Context.sdkVersion}`;
        const internalSdkVersion = `${prefix}node${Context.nodeVersion}:otel${Context.opentelemetryVersion}:${version}`;
        this.tags[KnownContextTagKeys.AiInternalSdkVersion] = internalSdkVersion;
    }
}
Context.sdkVersion = null;
Context.opentelemetryVersion = null;
Context.nodeVersion = "";
/**
 * Singleton Context instance
 * @internal
 */
function getInstance() {
    if (!instance) {
        instance = new Context();
    }
    return instance;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function hrTimeToDate(hrTime) {
    return new Date(core.hrTimeToNanoseconds(hrTime) / 1000000);
}
function createTagsFromResource(resource) {
    const context = getInstance();
    const tags = Object.assign({}, context.tags);
    if (resource && resource.attributes) {
        tags[KnownContextTagKeys.AiCloudRole] = getCloudRole(resource);
        tags[KnownContextTagKeys.AiCloudRoleInstance] = getCloudRoleInstance(resource);
        if (resource.attributes[semanticConventions.SEMRESATTRS_DEVICE_ID]) {
            tags[KnownContextTagKeys.AiDeviceId] = String(resource.attributes[semanticConventions.SEMRESATTRS_DEVICE_ID]);
        }
        if (resource.attributes[semanticConventions.SEMRESATTRS_DEVICE_MODEL_NAME]) {
            tags[KnownContextTagKeys.AiDeviceModel] = String(resource.attributes[semanticConventions.SEMRESATTRS_DEVICE_MODEL_NAME]);
        }
        if (resource.attributes[semanticConventions.SEMRESATTRS_SERVICE_VERSION]) {
            tags[KnownContextTagKeys.AiApplicationVer] = String(resource.attributes[semanticConventions.SEMRESATTRS_SERVICE_VERSION]);
        }
    }
    return tags;
}
function getCloudRole(resource) {
    let cloudRole = "";
    // Service attributes
    const serviceName = resource.attributes[semanticConventions.SEMRESATTRS_SERVICE_NAME];
    const serviceNamespace = resource.attributes[semanticConventions.SEMRESATTRS_SERVICE_NAMESPACE];
    if (serviceName) {
        // Custom Service name provided by customer is highest precedence
        if (!String(serviceName).startsWith("unknown_service")) {
            if (serviceNamespace) {
                return `${serviceNamespace}.${serviceName}`;
            }
            else {
                return String(serviceName);
            }
        }
        else {
            // Service attributes will be only used if K8S attributes are not present
            if (serviceNamespace) {
                cloudRole = `${serviceNamespace}.${serviceName}`;
            }
            else {
                cloudRole = String(serviceName);
            }
        }
    }
    // Kubernetes attributes should take precedence
    const kubernetesDeploymentName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_DEPLOYMENT_NAME];
    if (kubernetesDeploymentName) {
        return String(kubernetesDeploymentName);
    }
    const kuberneteReplicasetName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_REPLICASET_NAME];
    if (kuberneteReplicasetName) {
        return String(kuberneteReplicasetName);
    }
    const kubernetesStatefulSetName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_STATEFULSET_NAME];
    if (kubernetesStatefulSetName) {
        return String(kubernetesStatefulSetName);
    }
    const kubernetesJobName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_JOB_NAME];
    if (kubernetesJobName) {
        return String(kubernetesJobName);
    }
    const kubernetesCronjobName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_CRONJOB_NAME];
    if (kubernetesCronjobName) {
        return String(kubernetesCronjobName);
    }
    const kubernetesDaemonsetName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_DAEMONSET_NAME];
    if (kubernetesDaemonsetName) {
        return String(kubernetesDaemonsetName);
    }
    return cloudRole;
}
function getCloudRoleInstance(resource) {
    // Kubernetes attributes should take precedence
    const kubernetesPodName = resource.attributes[semanticConventions.SEMRESATTRS_K8S_POD_NAME];
    if (kubernetesPodName) {
        return String(kubernetesPodName);
    }
    // Service attributes
    const serviceInstanceId = resource.attributes[semanticConventions.SEMRESATTRS_SERVICE_INSTANCE_ID];
    if (serviceInstanceId) {
        return String(serviceInstanceId);
    }
    // Default
    return os$1 && os$1.hostname();
}
function isSqlDB(dbSystem) {
    return (dbSystem === semanticConventions.DBSYSTEMVALUES_DB2 ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_DERBY ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_MARIADB ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_MSSQL ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_ORACLE ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_SQLITE ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_OTHER_SQL ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_HSQLDB ||
        dbSystem === semanticConventions.DBSYSTEMVALUES_H2);
}
function getUrl(attributes) {
    if (!attributes) {
        return "";
    }
    const httpMethod = attributes[semanticConventions.SEMATTRS_HTTP_METHOD];
    if (httpMethod) {
        const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL];
        if (httpUrl) {
            return String(httpUrl);
        }
        else {
            const httpScheme = attributes[semanticConventions.SEMATTRS_HTTP_SCHEME];
            const httpTarget = attributes[semanticConventions.SEMATTRS_HTTP_TARGET];
            if (httpScheme && httpTarget) {
                const httpHost = attributes[semanticConventions.SEMATTRS_HTTP_HOST];
                if (httpHost) {
                    return `${httpScheme}://${httpHost}${httpTarget}`;
                }
                else {
                    const netPeerPort = attributes[semanticConventions.SEMATTRS_NET_PEER_PORT];
                    if (netPeerPort) {
                        const netPeerName = attributes[semanticConventions.SEMATTRS_NET_PEER_NAME];
                        if (netPeerName) {
                            return `${httpScheme}://${netPeerName}:${netPeerPort}${httpTarget}`;
                        }
                        else {
                            const netPeerIp = attributes[semanticConventions.SEMATTRS_NET_PEER_IP];
                            if (netPeerIp) {
                                return `${httpScheme}://${netPeerIp}:${netPeerPort}${httpTarget}`;
                            }
                        }
                    }
                }
            }
        }
    }
    return "";
}
function getDependencyTarget(attributes) {
    if (!attributes) {
        return "";
    }
    const peerService = attributes[semanticConventions.SEMATTRS_PEER_SERVICE];
    const httpHost = attributes[semanticConventions.SEMATTRS_HTTP_HOST];
    const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL];
    const netPeerName = attributes[semanticConventions.SEMATTRS_NET_PEER_NAME];
    const netPeerIp = attributes[semanticConventions.SEMATTRS_NET_PEER_IP];
    if (peerService) {
        return String(peerService);
    }
    else if (httpHost) {
        return String(httpHost);
    }
    else if (httpUrl) {
        return String(httpUrl);
    }
    else if (netPeerName) {
        return String(netPeerName);
    }
    else if (netPeerIp) {
        return String(netPeerIp);
    }
    return "";
}
function createResourceMetricEnvelope(resource, instrumentationKey) {
    if (resource && resource.attributes) {
        const tags = createTagsFromResource(resource);
        const resourceAttributes = {};
        for (const key of Object.keys(resource.attributes)) {
            // Avoid duplication ignoring fields already mapped.
            if (!(key.startsWith("_MS.") ||
                key === semanticConventions.SEMRESATTRS_TELEMETRY_SDK_VERSION ||
                key === semanticConventions.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE ||
                key === semanticConventions.SEMRESATTRS_TELEMETRY_SDK_NAME)) {
                resourceAttributes[key] = resource.attributes[key];
            }
        }
        // Only send event when resource attributes are available
        if (Object.keys(resourceAttributes).length > 0) {
            const baseData = {
                version: 2,
                metrics: [{ name: "_OTELRESOURCE_", value: 1 }],
                properties: resourceAttributes,
            };
            const envelope = {
                name: "Microsoft.ApplicationInsights.Metric",
                time: new Date(),
                sampleRate: 100, // Metrics are never sampled
                instrumentationKey: instrumentationKey,
                version: 1,
                data: {
                    baseType: "MetricData",
                    baseData: baseData,
                },
                tags: tags,
            };
            return envelope;
        }
    }
    return;
}
function shouldCreateResourceMetric() {
    var _a;
    return !(((_a = process.env.ENV_OPENTELEMETRY_RESOURCE_METRIC_DISABLED) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "true");
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure SDK namespace.
 * @internal
 */
const AzNamespace = "az.namespace";
/**
 * Azure SDK Eventhub.
 * @internal
 */
const MicrosoftEventHub = "Microsoft.EventHub";
/**
 * Azure SDK message bus destination.
 * @internal
 */
const MessageBusDestination = "message_bus.destination";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Average span.links[].attributes.enqueuedTime
 */
const getTimeSinceEnqueued = (span) => {
    let countEnqueueDiffs = 0;
    let sumEnqueueDiffs = 0;
    const startTimeMs = core.hrTimeToMilliseconds(span.startTime);
    span.links.forEach(({ attributes }) => {
        const enqueuedTime = attributes === null || attributes === void 0 ? void 0 : attributes[ENQUEUED_TIME];
        if (enqueuedTime) {
            countEnqueueDiffs += 1;
            sumEnqueueDiffs += startTimeMs - (parseFloat(enqueuedTime.toString()) || 0);
        }
    });
    return Math.max(sumEnqueueDiffs / (countEnqueueDiffs || 1), 0);
};
/**
 * Implementation of Mapping to Azure Monitor
 *
 * https://gist.github.com/lmolkova/e4215c0f44a49ef824983382762e6b92#mapping-to-azure-monitor-application-insights-telemetry
 * @internal
 */
const parseEventHubSpan = (span, baseData) => {
    const namespace = span.attributes[AzNamespace];
    const peerAddress = (span.attributes[semanticConventions.SEMATTRS_NET_PEER_NAME] ||
        span.attributes["peer.address"] ||
        "unknown").replace(/\/$/g, ""); // remove trailing "/"
    const messageBusDestination = (span.attributes[MessageBusDestination] || "unknown");
    switch (span.kind) {
        case api.SpanKind.CLIENT:
            baseData.type = namespace;
            baseData.target = `${peerAddress}/${messageBusDestination}`;
            break;
        case api.SpanKind.PRODUCER:
            baseData.type = `Queue Message | ${namespace}`;
            baseData.target = `${peerAddress}/${messageBusDestination}`;
            break;
        case api.SpanKind.CONSUMER:
            baseData.type = `Queue Message | ${namespace}`;
            baseData.source = `${peerAddress}/${messageBusDestination}`;
            baseData.measurements = Object.assign(Object.assign({}, baseData.measurements), { [TIME_SINCE_ENQUEUED]: getTimeSinceEnqueued(span) });
            break;
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function createTagsFromSpan(span) {
    const tags = createTagsFromResource(span.resource);
    tags[KnownContextTagKeys.AiOperationId] = span.spanContext().traceId;
    if (span.parentSpanId) {
        tags[KnownContextTagKeys.AiOperationParentId] = span.parentSpanId;
    }
    const endUserId = span.attributes[semanticConventions.SEMATTRS_ENDUSER_ID];
    if (endUserId) {
        tags[KnownContextTagKeys.AiUserId] = String(endUserId);
    }
    const httpUserAgent = span.attributes[semanticConventions.SEMATTRS_HTTP_USER_AGENT];
    if (httpUserAgent) {
        // TODO: Not exposed in Swagger, need to update def
        tags["ai.user.userAgent"] = String(httpUserAgent);
    }
    if (span.kind === api.SpanKind.SERVER) {
        const httpMethod = span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD];
        const httpClientIp = span.attributes[semanticConventions.SEMATTRS_HTTP_CLIENT_IP];
        const netPeerIp = span.attributes[semanticConventions.SEMATTRS_NET_PEER_IP];
        if (httpMethod) {
            const httpRoute = span.attributes[semanticConventions.SEMATTRS_HTTP_ROUTE];
            const httpUrl = span.attributes[semanticConventions.SEMATTRS_HTTP_URL];
            tags[KnownContextTagKeys.AiOperationName] = span.name; // Default
            if (httpRoute) {
                tags[KnownContextTagKeys.AiOperationName] = `${httpMethod} ${httpRoute}`;
            }
            else if (httpUrl) {
                try {
                    const url$1 = new url.URL(String(httpUrl));
                    tags[KnownContextTagKeys.AiOperationName] = `${httpMethod} ${url$1.pathname}`;
                }
                catch (_a) {
                    /* no-op */
                }
            }
            if (httpClientIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(httpClientIp);
            }
            else if (netPeerIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(netPeerIp);
            }
        }
        else {
            tags[KnownContextTagKeys.AiOperationName] = span.name;
            if (netPeerIp) {
                tags[KnownContextTagKeys.AiLocationIp] = String(netPeerIp);
            }
        }
    }
    // TODO: Operation Name and Location IP TBD for non server spans
    return tags;
}
function createPropertiesFromSpanAttributes(attributes) {
    const properties = {};
    if (attributes) {
        for (const key of Object.keys(attributes)) {
            // Avoid duplication ignoring fields already mapped.
            if (!(key.startsWith("_MS.") ||
                key.startsWith("microsoft.") ||
                key === semanticConventions.SEMATTRS_NET_PEER_IP ||
                key === semanticConventions.SEMATTRS_NET_PEER_NAME ||
                key === semanticConventions.SEMATTRS_PEER_SERVICE ||
                key === semanticConventions.SEMATTRS_HTTP_METHOD ||
                key === semanticConventions.SEMATTRS_HTTP_URL ||
                key === semanticConventions.SEMATTRS_HTTP_STATUS_CODE ||
                key === semanticConventions.SEMATTRS_HTTP_ROUTE ||
                key === semanticConventions.SEMATTRS_HTTP_HOST ||
                key === semanticConventions.SEMATTRS_HTTP_URL ||
                key === semanticConventions.SEMATTRS_DB_SYSTEM ||
                key === semanticConventions.SEMATTRS_DB_STATEMENT ||
                key === semanticConventions.SEMATTRS_DB_OPERATION ||
                key === semanticConventions.SEMATTRS_DB_NAME ||
                key === semanticConventions.SEMATTRS_RPC_SYSTEM ||
                key === semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE ||
                key === semanticConventions.SEMATTRS_EXCEPTION_TYPE ||
                key === semanticConventions.SEMATTRS_EXCEPTION_MESSAGE ||
                key === semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE)) {
                properties[key] = attributes[key];
            }
        }
    }
    return properties;
}
function createPropertiesFromSpan(span) {
    const properties = createPropertiesFromSpanAttributes(span.attributes);
    const measurements = {};
    const links = span.links.map((link) => ({
        operation_Id: link.context.traceId,
        id: link.context.spanId,
    }));
    if (links.length > 0) {
        properties[MS_LINKS] = JSON.stringify(links);
    }
    return [properties, measurements];
}
function createDependencyData(span) {
    var _a;
    const remoteDependencyData = {
        name: span.name, // Default
        id: `${span.spanContext().spanId}`,
        success: ((_a = span.status) === null || _a === void 0 ? void 0 : _a.code) !== api.SpanStatusCode.ERROR,
        resultCode: "0",
        type: "Dependency",
        duration: msToTimeSpan(core.hrTimeToMilliseconds(span.duration)),
        version: 2,
    };
    if (span.kind === api.SpanKind.PRODUCER) {
        remoteDependencyData.type = DependencyTypes.QueueMessage;
    }
    if (span.kind === api.SpanKind.INTERNAL && span.parentSpanId) {
        remoteDependencyData.type = DependencyTypes.InProc;
    }
    const httpMethod = span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD];
    const dbSystem = span.attributes[semanticConventions.SEMATTRS_DB_SYSTEM];
    const rpcSystem = span.attributes[semanticConventions.SEMATTRS_RPC_SYSTEM];
    // HTTP Dependency
    if (httpMethod) {
        const httpUrl = span.attributes[semanticConventions.SEMATTRS_HTTP_URL];
        if (httpUrl) {
            try {
                const dependencyUrl = new url.URL(String(httpUrl));
                remoteDependencyData.name = `${httpMethod} ${dependencyUrl.pathname}`;
            }
            catch (_b) {
                /* no-op */
            }
        }
        remoteDependencyData.type = DependencyTypes.Http;
        remoteDependencyData.data = getUrl(span.attributes);
        const httpStatusCode = span.attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];
        if (httpStatusCode) {
            remoteDependencyData.resultCode = String(httpStatusCode);
        }
        let target = getDependencyTarget(span.attributes);
        if (target) {
            try {
                // Remove default port
                const portRegex = new RegExp(/(https?)(:\/\/.*)(:\d+)(\S*)/);
                const res = portRegex.exec(target);
                if (res !== null) {
                    const protocol = res[1];
                    const port = res[3];
                    if ((protocol === "https" && port === ":443") ||
                        (protocol === "http" && port === ":80")) {
                        // Drop port
                        target = res[1] + res[2] + res[4];
                    }
                }
            }
            catch (_c) {
                /* no-op */
            }
            remoteDependencyData.target = `${target}`;
        }
    }
    // DB Dependency
    else if (dbSystem) {
        // TODO: Remove special logic when Azure UX supports OpenTelemetry dbSystem
        if (String(dbSystem) === semanticConventions.DBSYSTEMVALUES_MYSQL) {
            remoteDependencyData.type = "mysql";
        }
        else if (String(dbSystem) === semanticConventions.DBSYSTEMVALUES_POSTGRESQL) {
            remoteDependencyData.type = "postgresql";
        }
        else if (String(dbSystem) === semanticConventions.DBSYSTEMVALUES_MONGODB) {
            remoteDependencyData.type = "mongodb";
        }
        else if (String(dbSystem) === semanticConventions.DBSYSTEMVALUES_REDIS) {
            remoteDependencyData.type = "redis";
        }
        else if (isSqlDB(String(dbSystem))) {
            remoteDependencyData.type = "SQL";
        }
        else {
            remoteDependencyData.type = String(dbSystem);
        }
        const dbStatement = span.attributes[semanticConventions.SEMATTRS_DB_STATEMENT];
        const dbOperation = span.attributes[semanticConventions.SEMATTRS_DB_OPERATION];
        if (dbStatement) {
            remoteDependencyData.data = String(dbStatement);
        }
        else if (dbOperation) {
            remoteDependencyData.data = String(dbOperation);
        }
        const target = getDependencyTarget(span.attributes);
        const dbName = span.attributes[semanticConventions.SEMATTRS_DB_NAME];
        if (target) {
            remoteDependencyData.target = dbName ? `${target}|${dbName}` : `${target}`;
        }
        else {
            remoteDependencyData.target = dbName ? `${dbName}` : `${dbSystem}`;
        }
    }
    // grpc Dependency
    else if (rpcSystem) {
        if (rpcSystem === DependencyTypes.Wcf) {
            remoteDependencyData.type = DependencyTypes.Wcf;
        }
        else {
            remoteDependencyData.type = DependencyTypes.Grpc;
        }
        const grpcStatusCode = span.attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];
        if (grpcStatusCode) {
            remoteDependencyData.resultCode = String(grpcStatusCode);
        }
        const target = getDependencyTarget(span.attributes);
        if (target) {
            remoteDependencyData.target = `${target}`;
        }
        else if (rpcSystem) {
            remoteDependencyData.target = String(rpcSystem);
        }
    }
    return remoteDependencyData;
}
function createRequestData(span) {
    const requestData = {
        id: `${span.spanContext().spanId}`,
        success: span.status.code !== api.SpanStatusCode.ERROR &&
            (Number(span.attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE]) || 0) < 400,
        responseCode: "0",
        duration: msToTimeSpan(core.hrTimeToMilliseconds(span.duration)),
        version: 2,
        source: undefined,
    };
    const httpMethod = span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD];
    const grpcStatusCode = span.attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];
    if (httpMethod) {
        requestData.url = getUrl(span.attributes);
        const httpStatusCode = span.attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];
        if (httpStatusCode) {
            requestData.responseCode = String(httpStatusCode);
        }
    }
    else if (grpcStatusCode) {
        requestData.responseCode = String(grpcStatusCode);
    }
    return requestData;
}
/**
 * Span to Azure envelope parsing.
 * @internal
 */
function readableSpanToEnvelope(span, ikey) {
    let name;
    let baseType;
    let baseData;
    const time = hrTimeToDate(span.startTime);
    const instrumentationKey = ikey;
    const tags = createTagsFromSpan(span);
    const [properties, measurements] = createPropertiesFromSpan(span);
    switch (span.kind) {
        case api.SpanKind.CLIENT:
        case api.SpanKind.PRODUCER:
        case api.SpanKind.INTERNAL:
            name = "Microsoft.ApplicationInsights.RemoteDependency";
            baseType = "RemoteDependencyData";
            baseData = createDependencyData(span);
            break;
        case api.SpanKind.SERVER:
        case api.SpanKind.CONSUMER:
            name = "Microsoft.ApplicationInsights.Request";
            baseType = "RequestData";
            baseData = createRequestData(span);
            baseData.name = tags[KnownContextTagKeys.AiOperationName];
            break;
        default:
            // never
            api.diag.error(`Unsupported span kind ${span.kind}`);
            throw new Error(`Unsupported span kind ${span.kind}`);
    }
    let sampleRate = 100;
    if (span.attributes[AzureMonitorSampleRate]) {
        sampleRate = Number(span.attributes[AzureMonitorSampleRate]);
    }
    // Azure SDK
    if (span.attributes[AzNamespace]) {
        if (span.kind === api.SpanKind.INTERNAL) {
            baseData.type = `${DependencyTypes.InProc} | ${span.attributes[AzNamespace]}`;
        }
        if (span.attributes[AzNamespace] === MicrosoftEventHub) {
            parseEventHubSpan(span, baseData);
        }
    }
    return {
        name,
        sampleRate,
        time,
        instrumentationKey,
        tags,
        version: 1,
        data: {
            baseType,
            baseData: Object.assign(Object.assign({}, baseData), { properties,
                measurements }),
        },
    };
}
/**
 * Span Events to Azure envelopes parsing.
 * @internal
 */
function spanEventsToEnvelopes(span, ikey) {
    const envelopes = [];
    if (span.events) {
        span.events.forEach((event) => {
            var _a;
            let baseType;
            const time = hrTimeToDate(event.time);
            let name = "";
            let baseData;
            const properties = createPropertiesFromSpanAttributes(event.attributes);
            const tags = createTagsFromResource(span.resource);
            tags[KnownContextTagKeys.AiOperationId] = span.spanContext().traceId;
            const spanId = (_a = span.spanContext()) === null || _a === void 0 ? void 0 : _a.spanId;
            if (spanId) {
                tags[KnownContextTagKeys.AiOperationParentId] = spanId;
            }
            // Only generate exception telemetry for incoming requests
            if (event.name === "exception") {
                if (span.kind === api.SpanKind.SERVER) {
                    name = "Microsoft.ApplicationInsights.Exception";
                    baseType = "ExceptionData";
                    let typeName = "";
                    let message = "Exception";
                    let stack = "";
                    let hasFullStack = false;
                    if (event.attributes) {
                        typeName = String(event.attributes[semanticConventions.SEMATTRS_EXCEPTION_TYPE]);
                        stack = String(event.attributes[semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE]);
                        if (stack) {
                            hasFullStack = true;
                        }
                        const exceptionMsg = event.attributes[semanticConventions.SEMATTRS_EXCEPTION_MESSAGE];
                        if (exceptionMsg) {
                            message = String(exceptionMsg);
                        }
                        const escaped = event.attributes[semanticConventions.SEMATTRS_EXCEPTION_ESCAPED];
                        if (escaped !== undefined) {
                            properties[semanticConventions.SEMATTRS_EXCEPTION_ESCAPED] = String(escaped);
                        }
                    }
                    const exceptionDetails = {
                        typeName: typeName,
                        message: message,
                        stack: stack,
                        hasFullStack: hasFullStack,
                    };
                    const exceptionData = {
                        exceptions: [exceptionDetails],
                        version: 2,
                        properties: properties,
                    };
                    baseData = exceptionData;
                }
                else {
                    // Drop non-server exception span events
                    return;
                }
            }
            else {
                name = "Microsoft.ApplicationInsights.Message";
                baseType = "MessageData";
                const messageData = {
                    message: event.name,
                    version: 2,
                    properties: properties,
                };
                baseData = messageData;
            }
            let sampleRate = 100;
            if (span.attributes[AzureMonitorSampleRate]) {
                sampleRate = Number(span.attributes[AzureMonitorSampleRate]);
            }
            const env = {
                name: name,
                time: time,
                instrumentationKey: ikey,
                version: 1,
                sampleRate: sampleRate,
                data: {
                    baseType: baseType,
                    baseData: baseData,
                },
                tags: tags,
            };
            envelopes.push(env);
        });
    }
    return envelopes;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure Monitor OpenTelemetry Trace Exporter.
 */
class AzureMonitorTraceExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorTraceExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        super(options);
        /**
         * Flag to determine if Exporter is shutdown.
         */
        this.isShutdown = false;
        this.shouldCreateResourceMetric = shouldCreateResourceMetric();
        this.sender = new HttpSender({
            endpointUrl: this.endpointUrl,
            instrumentationKey: this.instrumentationKey,
            trackStatsbeat: this.trackStatsbeat,
            exporterOptions: options,
            aadAudience: this.aadAudience,
        });
        api.diag.debug("AzureMonitorTraceExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry spans.
     * @param spans - Spans to export.
     * @param resultCallback - Result callback.
     */
    async export(spans, resultCallback) {
        if (this.isShutdown) {
            api.diag.info("Exporter shut down. Failed to export spans.");
            setTimeout(() => resultCallback({ code: core.ExportResultCode.FAILED }), 0);
            return;
        }
        api.diag.info(`Exporting ${spans.length} span(s). Converting to envelopes...`);
        if (spans.length > 0) {
            const envelopes = [];
            const resourceMetricEnvelope = createResourceMetricEnvelope(spans[0].resource, this.instrumentationKey);
            if (resourceMetricEnvelope && this.shouldCreateResourceMetric) {
                envelopes.push(resourceMetricEnvelope);
            }
            spans.forEach((span) => {
                envelopes.push(readableSpanToEnvelope(span, this.instrumentationKey));
                const spanEventEnvelopes = spanEventsToEnvelopes(span, this.instrumentationKey);
                if (spanEventEnvelopes.length > 0) {
                    envelopes.push(...spanEventEnvelopes);
                }
            });
            resultCallback(await this.sender.exportEnvelopes(envelopes));
        }
        // No data to export
        resultCallback({ code: core.ExportResultCode.SUCCESS });
    }
    /**
     * Shutdown AzureMonitorTraceExporter.
     */
    async shutdown() {
        this.isShutdown = true;
        api.diag.info("AzureMonitorTraceExporter shutting down");
        return this.sender.shutdown();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure Monitor OpenTelemetry Metric Exporter.
 */
class AzureMonitorMetricExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorMetricExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        super(options);
        /**
         * Flag to determine if Exporter is shutdown.
         */
        this._isShutdown = false;
        this._sender = new HttpSender({
            endpointUrl: this.endpointUrl,
            instrumentationKey: this.instrumentationKey,
            trackStatsbeat: this.trackStatsbeat,
            exporterOptions: options,
            aadAudience: this.aadAudience,
        });
        api.diag.debug("AzureMonitorMetricExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry resource metrics.
     * @param metrics - Resource metrics to export.
     * @param resultCallback - Result callback.
     */
    async export(metrics, resultCallback) {
        if (this._isShutdown) {
            api.diag.info("Exporter shut down. Failed to export spans.");
            setTimeout(() => resultCallback({ code: core.ExportResultCode.FAILED }), 0);
            return;
        }
        api.diag.info(`Exporting ${metrics.scopeMetrics.length} metrics(s). Converting to envelopes...`);
        const envelopes = resourceMetricsToEnvelope(metrics, this.instrumentationKey);
        // Supress tracing until OpenTelemetry Metrics SDK support it
        await api.context.with(core.suppressTracing(api.context.active()), async () => {
            resultCallback(await this._sender.exportEnvelopes(envelopes));
        });
    }
    /**
     * Shutdown AzureMonitorMetricExporter.
     */
    async shutdown() {
        this._isShutdown = true;
        api.diag.info("AzureMonitorMetricExporter shutting down");
        return this._sender.shutdown();
    }
    /**
     * Select aggregation temporality
     */
    selectAggregationTemporality(instrumentType) {
        if (instrumentType === sdkMetrics.InstrumentType.UP_DOWN_COUNTER ||
            instrumentType === sdkMetrics.InstrumentType.OBSERVABLE_UP_DOWN_COUNTER) {
            return sdkMetrics.AggregationTemporality.CUMULATIVE;
        }
        return sdkMetrics.AggregationTemporality.DELTA;
    }
    /**
     * Force flush
     */
    async forceFlush() {
        return Promise.resolve();
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Log to Azure envelope parsing.
 * @internal
 */
function logToEnvelope(log, ikey) {
    const time = hrTimeToDate(log.hrTime);
    const sampleRate = 100;
    const instrumentationKey = ikey;
    const tags = createTagsFromLog(log);
    // eslint-disable-next-line prefer-const
    let [properties, measurements] = createPropertiesFromLog(log);
    let name;
    let baseType;
    let baseData;
    if (!log.attributes[ApplicationInsightsBaseType]) {
        // Get Exception attributes if available
        const exceptionType = log.attributes[semanticConventions.SEMATTRS_EXCEPTION_TYPE];
        if (exceptionType) {
            const exceptionMessage = log.attributes[semanticConventions.SEMATTRS_EXCEPTION_MESSAGE];
            const exceptionStacktrace = log.attributes[semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE];
            name = ApplicationInsightsExceptionName;
            baseType = ApplicationInsightsExceptionBaseType;
            const exceptionDetails = {
                typeName: String(exceptionType),
                message: String(exceptionMessage),
                hasFullStack: exceptionStacktrace ? true : false,
                stack: String(exceptionStacktrace),
            };
            const exceptionData = {
                exceptions: [exceptionDetails],
                severityLevel: String(getSeverity(log.severityNumber)),
                version: 2,
            };
            baseData = exceptionData;
        }
        else {
            name = ApplicationInsightsMessageName;
            baseType = ApplicationInsightsMessageBaseType;
            const messageData = {
                message: String(log.body),
                severityLevel: String(getSeverity(log.severityNumber)),
                version: 2,
            };
            baseData = messageData;
        }
    }
    else {
        // If Legacy Application Insights Log
        baseType = String(log.attributes[ApplicationInsightsBaseType]);
        name = getLegacyApplicationInsightsName(log);
        baseData = getLegacyApplicationInsightsBaseData(log);
        measurements = getLegacyApplicationInsightsMeasurements(log);
        if (!baseData) {
            // Failed to parse log
            return;
        }
    }
    return {
        name,
        sampleRate,
        time,
        instrumentationKey,
        tags,
        version: 1,
        data: {
            baseType,
            baseData: Object.assign(Object.assign({}, baseData), { properties,
                measurements }),
        },
    };
}
function createTagsFromLog(log) {
    var _a, _b;
    const tags = createTagsFromResource(log.resource);
    if ((_a = log.spanContext) === null || _a === void 0 ? void 0 : _a.traceId) {
        tags[KnownContextTagKeys.AiOperationId] = log.spanContext.traceId;
    }
    if ((_b = log.spanContext) === null || _b === void 0 ? void 0 : _b.spanId) {
        tags[KnownContextTagKeys.AiOperationParentId] = log.spanContext.spanId;
    }
    return tags;
}
function createPropertiesFromLog(log) {
    const measurements = {};
    const properties = {};
    if (log.attributes) {
        for (const key of Object.keys(log.attributes)) {
            // Avoid duplication ignoring fields already mapped.
            if (!(key.startsWith("_MS.") ||
                key === semanticConventions.SEMATTRS_EXCEPTION_TYPE ||
                key === semanticConventions.SEMATTRS_EXCEPTION_MESSAGE ||
                key === semanticConventions.SEMATTRS_EXCEPTION_STACKTRACE)) {
                properties[key] = log.attributes[key];
            }
        }
    }
    return [properties, measurements];
}
// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#field-severitynumber
function getSeverity(severityNumber) {
    if (severityNumber) {
        if (severityNumber > 0 && severityNumber < 9) {
            return KnownSeverityLevel.Verbose;
        }
        else if (severityNumber >= 9 && severityNumber < 13) {
            return KnownSeverityLevel.Information;
        }
        else if (severityNumber >= 13 && severityNumber < 17) {
            return KnownSeverityLevel.Warning;
        }
        else if (severityNumber >= 17 && severityNumber < 21) {
            return KnownSeverityLevel.Error;
        }
        else if (severityNumber >= 21 && severityNumber < 25) {
            return KnownSeverityLevel.Critical;
        }
    }
    return;
}
function getLegacyApplicationInsightsName(log) {
    let name = "";
    switch (log.attributes[ApplicationInsightsBaseType]) {
        case ApplicationInsightsAvailabilityBaseType:
            name = ApplicationInsightsAvailabilityName;
            break;
        case ApplicationInsightsExceptionBaseType:
            name = ApplicationInsightsExceptionName;
            break;
        case ApplicationInsightsMessageBaseType:
            name = ApplicationInsightsMessageName;
            break;
        case ApplicationInsightsPageViewBaseType:
            name = ApplicationInsightsPageViewName;
            break;
        case ApplicationInsightsEventBaseType:
            name = ApplicationInsightsEventName;
            break;
    }
    return name;
}
function getLegacyApplicationInsightsMeasurements(log) {
    var _a;
    let measurements = {};
    if ((_a = log.body) === null || _a === void 0 ? void 0 : _a.measurements) {
        measurements = Object.assign({}, log.body.measurements);
    }
    return measurements;
}
function getLegacyApplicationInsightsBaseData(log) {
    let baseData = {
        version: 2,
    };
    if (log.body) {
        try {
            switch (log.attributes[ApplicationInsightsBaseType]) {
                case ApplicationInsightsAvailabilityBaseType:
                    baseData = log.body;
                    break;
                case ApplicationInsightsExceptionBaseType:
                    baseData = log.body;
                    break;
                case ApplicationInsightsMessageBaseType:
                    baseData = log.body;
                    break;
                case ApplicationInsightsPageViewBaseType:
                    baseData = log.body;
                    break;
                case ApplicationInsightsEventBaseType:
                    baseData = log.body;
                    break;
            }
            if (typeof (baseData === null || baseData === void 0 ? void 0 : baseData.message) === "object") {
                baseData.message = JSON.stringify(baseData.message);
            }
        }
        catch (err) {
            api.diag.error("AzureMonitorLogExporter failed to parse Application Insights Telemetry");
        }
    }
    return baseData;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Azure Monitor OpenTelemetry Log Exporter.
 */
class AzureMonitorLogExporter extends AzureMonitorBaseExporter {
    /**
     * Initializes a new instance of the AzureMonitorLogExporter class.
     * @param AzureExporterConfig - Exporter configuration.
     */
    constructor(options = {}) {
        super(options);
        /**
         * Flag to determine if Exporter is shutdown.
         */
        this._isShutdown = false;
        this._sender = new HttpSender({
            endpointUrl: this.endpointUrl,
            instrumentationKey: this.instrumentationKey,
            trackStatsbeat: this.trackStatsbeat,
            exporterOptions: options,
            aadAudience: this.aadAudience,
        });
        api.diag.debug("AzureMonitorLogExporter was successfully setup");
    }
    /**
     * Export OpenTelemetry logs.
     * @param logs - Logs to export.
     * @param resultCallback - Result callback.
     */
    async export(logs, resultCallback) {
        if (this._isShutdown) {
            api.diag.info("Exporter shut down. Failed to export spans.");
            setTimeout(() => resultCallback({ code: core.ExportResultCode.FAILED }), 0);
            return;
        }
        api.diag.info(`Exporting ${logs.length} logs(s). Converting to envelopes...`);
        const envelopes = [];
        logs.forEach((log) => {
            const envelope = logToEnvelope(log, this.instrumentationKey);
            if (envelope) {
                envelopes.push(envelope);
            }
        });
        // Supress tracing until OpenTelemetry Logs SDK support it
        await api.context.with(core.suppressTracing(api.context.active()), async () => {
            resultCallback(await this._sender.exportEnvelopes(envelopes));
        });
    }
    /**
     * Shutdown AzureMonitorLogExporter.
     */
    async shutdown() {
        this._isShutdown = true;
        api.diag.info("AzureMonitorLogExporter shutting down");
        return this._sender.shutdown();
    }
}

exports.ApplicationInsightsSampler = ApplicationInsightsSampler;
exports.AzureMonitorBaseExporter = AzureMonitorBaseExporter;
exports.AzureMonitorLogExporter = AzureMonitorLogExporter;
exports.AzureMonitorMetricExporter = AzureMonitorMetricExporter;
exports.AzureMonitorTraceExporter = AzureMonitorTraceExporter;
//# sourceMappingURL=index.js.map
